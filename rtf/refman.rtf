{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment My Project }My Project}
{\comment Generated by doxygen 1.11.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt My Project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Analyse av <tt>finalproject.out</tt> filen\par \pard\plain 
{\tc\tcl1 \v Analyse av <tt>finalproject.out</tt> filen}
{\xe \v Analyse av <tt>finalproject.out</tt> filen}
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
 \par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Filnavn
\par}
{\tc\tcl2 \v Filnavn}
{\f2 C:/Users/obsfe/workspace_v10/FinalProject/binary/finalproject.out} \par}
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Inngangspunkt
\par}
{\tc\tcl2 \v Inngangspunkt}
{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
**_c_int00** ved adresse {\b 000824f5} \par}
\par
\par}
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Minnekonfigurasjon
\par}
{\tc\tcl2 \v Minnekonfigurasjon}
Denne delen viser minnekonfigurasjonen for ulike minneomr\'E5der som brukes av prosjektet:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b RAMM0} : Startadresse 00000123, lengde 000002dd, alt ubrukte.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b RAMLS05} : Startadresse 00008000, lengde 00003000, brukt 00000298.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b FLASH} : Inkluderer omr\'E5der som FLASHA, FLASHB osv., hvor data blir lagret og brukt.\par}
\par
\par}
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Seksjonsallokeringskart
\par}
{\tc\tcl2 \v Seksjonsallokeringskart}
Dette kartet viser hvordan forskjellige seksjoner av programmet ditt er fordelt i minnet. For eksempel:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b codestart} : Startadresse 00080000, lengde 00000002\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
**.cinit**: Startadresse 00082e18, lengde 00000155, inneholder seksjoner fra forskjellige .obj filer som UART_Chip_Main.obj, LEDPatterns.obj osv.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
**.stack**: Startadresse 0000b000, lengde 00000800, uinitialisert.\par}
\par
\par}
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modulsammendrag
\par}
{\tc\tcl2 \v Modulsammendrag}
Dette gir en oversikt over modulene som brukes i prosjektet, inkludert kode, initialiserte og uinitialiserte data:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b F28379dSerial.obj} : 1884 bytes kode, 0 bytes initialisert data, 12080 bytes uinitialisert data.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b F2837xD_GlobalVariableDefs.obj} : 0 bytes kode, 0 bytes initialisert data, 8232 bytes uinitialisert data.\par}
\par
\par}
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Globale datasymboler
\par}
{\tc\tcl2 \v Globale datasymboler}
Sortert etter dataside og alfabetisk:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
**_AdcaResultRegs**: Adresse 00000b00, side 2c.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
**_CpuTimer0Regs**: Adresse 00000c00, side 30.\par}
\par
\par}
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Symboler sortert alfabetisk
\par}
{\tc\tcl2 \v Symboler sortert alfabetisk}
Gir en alfabetisk oversikt over symbolene med deres adresse og side:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
**_abort**: Adresse 00082630, side 0.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
**_memcpy**: Adresse 00082749, side 0.\par}
\par
\par}
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Generelle observasjoner
\par}
{\tc\tcl2 \v Generelle observasjoner}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Prosjektet bruker en omfattende mengde forskjellige minneomr\'E5der inkludert RAM og FLASH.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b LEDPatterns.obj}  inneholder mange .cinit-seksjoner som initierer forskjellige LED-m\'F8nstre.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Modulsammendraget viser at {\b F28379dSerial.obj}  og {\b F2837xD_GlobalVariableDefs.obj}  er de st\'F8rste modulene med betydelig mengde uinitialiserte data.\par}
\par
\par}
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Konklusjon
\par}
{\tc\tcl2 \v Konklusjon}
Den genererte .map-filen gir en omfattende oversikt over minnebruken og seksjonsallokeringen i prosjektet ditt. Dette kan hjelpe til med \'E5 forst\'E5 hvordan minnet er organisert, identifisere eventuelle problemer med minnebruk, og optimalisere programmet ditt.\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par}
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Beskrivelse av UART_Chip_Main
\par}
{\tc\tcl2 \v Beskrivelse av UART_Chip_Main}
Denne C-koden er designet for \'E5 kj\'F8re p\'E5 en Texas Instruments F28379D mikrokontroller. Programmet initierer flere periferi-enheter og h\'E5ndterer tidsintervaller og UART-kommunikasjon. Nedenfor er en detaljert beskrivelse av hovedkomponentene i programmet.\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Inkluderte filer
\par}
{\tc\tcl3 \v Inkluderte filer}
Koden inkluderer flere bibliotek og header-filer som gir tilgang til forskjellige funksjoner og definisjoner:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Standard C-bibliotek: {\f2 <stdio.h>} , {\f2 <stdlib.h>} , {\f2 <stdarg.h>} , {\f2 <string.h>} , {\f2 <math.h>} , {\f2 <limits.h>} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Spesifikke filer for F28x-prosjektet og enheten: {\f2 F28x_Project.h} , {\f2 driverlib.h} , {\f2 device.h} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Filer for spesifikke funksjoner: {\f2 {\b f28379dSerial.h}} , {\f2 {\b LEDPatterns.h}} , {\f2 {\b song.h}} \par}
\par
\par}
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Konstanter
\par}
{\tc\tcl3 \v Konstanter}
Definerer noen matematiske konstanter:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 PI} , {\f2 TWOPI} , {\f2 HALFPI} \par}
\par
\par}
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Avbruddsrutiner
\par}
{\tc\tcl3 \v Avbruddsrutiner}
Forh\'E5ndsdefinerer avbruddsrutiner:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b cpu_timer0_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b cpu_timer1_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b cpu_timer2_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b SWI_isr(void)};} \par}
\par
\par}
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funksjonsprototyper
\par}
{\tc\tcl3 \v Funksjonsprototyper}
Deklarerer funksjoner for h\'E5ndtering av UART-mottak:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b serialRXA(serial_t *s, char data)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b serialRXC(serial_t *s, char data)};} \par}
\par
\par}
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Globale variabler
\par}
{\tc\tcl3 \v Globale variabler}
Deklarerer flere globale tellevariabler:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 uint32_t numTimer0calls, numSWIcalls, numRXA} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 uint1616_t UARTPrint, LEDdisplaynum} \par}
\par
\par}
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Main-funksjonen
\par}
{\tc\tcl3 \v Main-funksjonen}
Hovedfunksjonen inneholder f\'F8lgende trinn:\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Systeminitialisering:
\par}
{\tc\tcl4 \v Systeminitialisering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer systemkontrollen: {\f2 {\b InitSysCtrl()}} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer GPIO (generelle inn-/utganger): {\f2 InitGpio()} \par}
\par
\par}
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
LED-konfigurasjon:
\par}
{\tc\tcl4 \v LED-konfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Setter opp flere GPIO-pinner for LED-er ved hjelp av {\f2 GPIO_SetupPinMux()}  og {\f2 GPIO_SetupPinOptions()} .\par}
\par
\par}
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Push-knapp konfigurasjon:
\par}
{\tc\tcl4 \v Push-knapp konfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Setter opp GPIO-pinner for push-knapper.\par}
\par
\par}
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Avbruddsh\'E5ndtering:
\par}
{\tc\tcl4 \v Avbruddsh\'E5ndtering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Deaktiverer CPU-avbrudd: {\f2 DINT} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer PIE-kontroll (Peripheral Interrupt Expansion) og vektor-tabellen.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Mapper avbrudd til ISR-funksjoner.\par}
\par
\par}
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Timerkonfigurasjon:
\par}
{\tc\tcl4 \v Timerkonfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer CPU-timere og setter avbruddsperioder.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Aktiverer CPU-timer avbrudd.\par}
\par
\par}
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
UART-initialisering:
\par}
{\tc\tcl4 \v UART-initialisering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer seriell kommunikasjon: {\f2 init_serial(&SerialA,115200,serialRXA)} , {\f2 init_serial(&SerialC,9600,serialRXC)} .\par}
\par
\par}
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Global avbrudd aktivering:
\par}
{\tc\tcl4 \v Global avbrudd aktivering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Aktiverer globale avbrudd: {\f2 EINT} , {\f2 ERTM} \par}
\par
\par}
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Hovedl\'F8kken:
\par}
{\tc\tcl4 \v Hovedl\'F8kken:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
En uendelig l\'F8kke som sjekker {\f2 UARTPrint}  og sender data over UART.\par}
\par
\par}
\par}
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Avbruddsrutiner (ISR)
\par}
{\tc\tcl3 \v Avbruddsrutiner (ISR)}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b SWI_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 numSWIcalls}  hver gang det kalles.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b cpu_timer0_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 numTimer0calls}  og toggler en r\'F8d LED.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b cpu_timer1_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 CpuTimer1.InterruptCount} .\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b cpu_timer2_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Toggler en bl\'E5 LED og \'F8ker {\f2 CpuTimer2.InterruptCount} . Setter {\f2 UARTPrint}  til 1 for hver 50. gang.\par}
}
\par
\par}
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
UART mottaksh\'E5ndtering
\par}
{\tc\tcl3 \v UART mottaksh\'E5ndtering}
{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b serialRXA} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 numRXA}  hver gang en karakter mottas.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b serialRXC} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Lagrer de siste 10 mottatte tegnene og utf\'F8rer handlinger basert p\'E5 spesifikke tegnsekvenser.\par}
}
\par
\par}
\par}
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Oppsummering
\par}
{\tc\tcl2 \v Oppsummering}
Denne koden setter opp og administrerer grunnleggende funksjonalitet for en F28379D mikrokontroller, inkludert GPIO, timere og UART-kommunikasjon. Koden bruker avbruddsrutiner for effektiv h\'E5ndtering av tidsstyrte og hendelsesbaserte prosesser.\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par}
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Beskrivelse av UART_Segbot
\par}
{\tc\tcl2 \v Beskrivelse av UART_Segbot}
Denne C-koden er utviklet for en Texas Instruments F28379D mikrokontroller og er designet for \'E5 kontrollere en selvbalanserende robot ved hjelp av et kontrollpanel. Programmet initialiserer flere periferi-enheter, h\'E5ndterer tidsintervaller, ADC og SPI-kommunikasjon, samt UART-kommunikasjon. Nedenfor f\'F8lger en detaljert beskrivelse av de viktigste komponentene i programmet.\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Inkluderte filer
\par}
{\tc\tcl3 \v Inkluderte filer}
Koden inkluderer flere bibliotek og header-filer som gir tilgang til ulike funksjoner og definisjoner:\par
{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Standard C-bibliotek: {\f2 <stdio.h>} , {\f2 <stdlib.h>} , {\f2 <stdarg.h>} , {\f2 <string.h>} , {\f2 <math.h>} , {\f2 <limits.h>} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Spesifikke filer for F28x-prosjektet og enheten: {\f2 F28x_Project.h} , {\f2 driverlib.h} , {\f2 device.h} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Filer for spesifikke funksjoner: {\f2 {\b f28379dSerial.h}} , {\f2 {\b LEDPatterns.h}} , {\f2 {\b song.h}} \par}
\par
\par}
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Konstanter
\par}
{\tc\tcl3 \v Konstanter}
Definerer noen matematiske konstanter:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 PI} , {\f2 TWOPI} , {\f2 HALFPI} \par}
\par
\par}
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Avbruddsrutiner
\par}
{\tc\tcl3 \v Avbruddsrutiner}
Forh\'E5ndsdefinerer avbruddsrutiner:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b cpu_timer0_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b cpu_timer1_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b cpu_timer2_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b SWI_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b SPIB_isr(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 __interrupt void {\b ADCA_ISR(void)};} \par}
\par
\par}
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funksjonsprototyper
\par}
{\tc\tcl3 \v Funksjonsprototyper}
Deklarerer funksjoner for oppsett og h\'E5ndtering av forskjellige enheter:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b setupSpib(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b serialRXA(serial_t *s, char data)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b serialRXC(serial_t *s, char data)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b init_eQEPs(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 float {\b readEncLeft(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 float {\b readEncRight(void)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b setEPWM2A(float)};} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\f2 void {\b setEPWM2B(float)};} \par}
\par
\par}
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Globale variabler
\par}
{\tc\tcl3 \v Globale variabler}
Deklarerer flere globale variabler som brukes i kontroll og beregninger:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Tellere: {\f2 uint32_t numTimer0calls, numSWIcalls, numRXA} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Kontrollvariabler: {\f2 uint16_t UARTPrint, LEDdisplaynum} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Sensorvariabler: {\f2 int16_t accelxraw, accelyraw, accelzraw, gyroxraw, gyroyraw, gyrozraw} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Fysiske m\'E5linger: {\f2 float accelx, accely, accelz, gyrox, gyroy, gyroz} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Kontrollparametre: {\f2 float K1, K2, K3, Kp, Ki, Kd} \par}
\par
\par}
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Main-funksjonen
\par}
{\tc\tcl3 \v Main-funksjonen}
Hovedfunksjonen inneholder f\'F8lgende trinn:\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Systeminitialisering:
\par}
{\tc\tcl4 \v Systeminitialisering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer systemkontrollen: {\f2 {\b InitSysCtrl()}} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer GPIO (generelle inn-/utganger): {\f2 InitGpio()} \par}
\par
\par}
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
LED-konfigurasjon:
\par}
{\tc\tcl4 \v LED-konfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Setter opp flere GPIO-pinner for LED-er ved hjelp av {\f2 GPIO_SetupPinMux()}  og {\f2 GPIO_SetupPinOptions()} .\par}
\par
\par}
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Push-knapp konfigurasjon:
\par}
{\tc\tcl4 \v Push-knapp konfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Setter opp GPIO-pinner for push-knapper.\par}
\par
\par}
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Avbruddsh\'E5ndtering:
\par}
{\tc\tcl4 \v Avbruddsh\'E5ndtering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Deaktiverer CPU-avbrudd: {\f2 DINT} \par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer PIE-kontroll (Peripheral Interrupt Expansion) og vektor-tabellen.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Mapper avbrudd til ISR-funksjoner.\par}
\par
\par}
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Timerkonfigurasjon:
\par}
{\tc\tcl4 \v Timerkonfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer CPU-timere og setter avbruddsperioder.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Aktiverer CPU-timer avbrudd.\par}
\par
\par}
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
UART-initialisering:
\par}
{\tc\tcl4 \v UART-initialisering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer seriell kommunikasjon: {\f2 init_serial(&SerialA,115200,serialRXA)} , {\f2 init_serial(&SerialC,9600,serialRXC)} .\par}
\par
\par}
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
PWM-konfigurasjon:
\par}
{\tc\tcl4 \v PWM-konfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Setter opp PWM for motorstyring.\par}
\par
\par}
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
ADC-konfigurasjon:
\par}
{\tc\tcl4 \v ADC-konfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Konfigurerer ADC for \'E5 lese sensordata.\par}
\par
\par}
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
eQEP-konfigurasjon:
\par}
{\tc\tcl4 \v eQEP-konfigurasjon:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer eQEP for \'E5 lese enkodere p\'E5 hjulene: {\f2 {\b init_eQEPs()}} \par}
\par
\par}
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Global avbrudd aktivering:
\par}
{\tc\tcl4 \v Global avbrudd aktivering:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Aktiverer globale avbrudd: {\f2 EINT} , {\f2 ERTM} \par}
\par
\par}
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Hovedl\'F8kken:
\par}
{\tc\tcl4 \v Hovedl\'F8kken:}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
En uendelig l\'F8kke som sjekker {\f2 UARTPrint}  og sender data over UART.\par}
\par
\par}
\par}
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Avbruddsrutiner (ISR)
\par}
{\tc\tcl3 \v Avbruddsrutiner (ISR)}
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b SWI_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Utf\'F8rer balansekontrollalgoritmen og sender kontrollsignalene til motorene.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b cpu_timer0_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 numTimer0calls}  og h\'E5ndterer eventuelle periodiske oppgaver.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b cpu_timer1_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 CpuTimer1.InterruptCount} .\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b cpu_timer2_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 CpuTimer2.InterruptCount} .\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b ADCA_ISR} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Leser ADC-verdier og triggere SPI-overf\'F8ring for \'E5 lese gyroskop- og akselerometerdata.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b SPIB_isr} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Henter sensordata fra SPI og utf\'F8rer kalibrering og filtrering.\par}
}
\par
\par}
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
UART mottaksh\'E5ndtering
\par}
{\tc\tcl3 \v UART mottaksh\'E5ndtering}
{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b serialRXA} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\'D8ker {\f2 numRXA}  hver gang en karakter mottas.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b serialRXC} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
H\'E5ndterer innkommende data fra Bluetooth og justerer kontrollparametrene basert p\'E5 kommandoer.\par}
}
\par
\par}
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ekstra funksjoner
\par}
{\tc\tcl3 \v Ekstra funksjoner}
{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b setupSpib} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Setter opp SPIB for kommunikasjon med IMU (Inertial Measurement Unit).\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b init_eQEPs} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialiserer eQEP-moduler for \'E5 lese posisjon fra hjulenkodere.\par}
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
{\b setEPWM2A}  og {\b setEPWM2B} :{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Setter PWM-signaler basert p\'E5 beregnede kontrollverdier.\par}
}
\par
\par}
\par}
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Oppsummering
\par}
{\tc\tcl2 \v Oppsummering}
Denne koden setter opp og administrerer grunnleggende funksjonalitet for en F28379D mikrokontroller, inkludert GPIO, timere, ADC, SPI og UART-kommunikasjon. Koden bruker avbruddsrutiner for effektiv h\'E5ndtering av tidsstyrte og hendelsesbaserte prosesser, samt implementerer en balansekontrollalgoritme for en selvbalanserende robot. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Index\par \pard\plain 
{\tc \v Topic Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Topics\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all topics with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Real Fast Fourier Transforms\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DSP Library Definitions and Types\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b buffer_s} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b phonedata_s} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RFFT_ADC_F32_STRUCT} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT with ADC input })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RFFT_F32_STRUCT} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b serial_s} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b buffer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dsp.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DSP Library Definitions and Types })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F28379dSerial.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F28379dSerial.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_Adc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_CpuTimers.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_DefaultISR.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_EPwm.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_GlobalVariableDefs.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_Gpio.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_PieCtrl.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_PieVect.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_Spi.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F2837xD_SysCtrl.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b fpu_rfft.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LEDPatterns.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LEDPatterns.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Segbot_Steer_and_Celebrate.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b song.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b UART_Chip_Main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b UART_Segbot..c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b UART_Segbot2.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b UART_Segbot3.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b UART_Segbot4.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Documentation{\tc \v Topic Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Real Fast Fourier Transforms\par \pard\plain 
{\tc\tcl2 \v Real Fast Fourier Transforms}
{\xe \v Real Fast Fourier Transforms}
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RFFT_F32_STRUCT}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright: Copyright (C) 2023 Texas Instruments Incorporated - All rights reserved not granted herein. Limited License.\par
Texas Instruments Incorporated grants a world-wide, royalty-free, non-exclusive license under copyrights and patents it now or hereafter owns or controls to make, have made, use, import, offer to sell and sell ("Utilize") this software subject to the terms herein. With respect to the foregoing patent license, such license is granted solely to the extent that any such patent is necessary to Utilize the software alone. The patent license shall not apply to any combinations which include this software, other than combinations with devices manufactured by or for TI ("TI Devices"). No hardware patent is licensed hereunder.\par
Redistributions must preserve existing copyright notices and reproduce this license (including the above copyright notice and the disclaimer and (if applicable) source code license limitations below) in the documentation and/or other materials provided with the distribution.\par
Redistribution and use in binary form, without modification, are permitted provided that the following conditions are met:\par
{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
No reverse engineering, decompilation, or disassembly of this software is permitted with respect to any software provided in binary form.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Any redistribution and use are licensed by TI for use only with TI Devices.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Nothing shall obligate TI to provide you with source code for the software licensed and provided to you in object code.\par}
\par
If software source code is provided to you, modification and redistribution of the source code are permitted provided that the following conditions are met:\par
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
any redistribution and use of the source code, including any resulting derivative works, are licensed by TI for use only with TI Devices.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
any redistribution and use of any object code compiled from the source code and any resulting derivative works, are licensed by TI for use only with TI Devices.\par}
\par
Neither the name of Texas Instruments Incorporated nor the names of its suppliers may be used to endorse or promote products derived from this software without specific prior written permission.    \par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DSP Library Definitions and Types\par \pard\plain 
{\tc\tcl2 \v DSP Library Definitions and Types}
{\xe \v DSP Library Definitions and Types}
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
 \par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
buffer_s Struct Reference\par \pard\plain 
{\tc\tcl2 \v buffer_s}
{\xe \v buffer_s}
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
\par
{
{\f2 #include <buffer.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile char {\b buf} [{\b BUF_SIZE}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile Uint16 {\b head}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile Uint16 {\b tail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile Uint16 {\b size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 7} of file {\b buffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v buf\:buffer_s}
{\xe \v buffer_s\:buf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile char buf[{\b BUF_SIZE}]}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b buffer.h}.}\par
}
{\xe \v head\:buffer_s}
{\xe \v buffer_s\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile Uint16 head}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b buffer.h}.}\par
}
{\xe \v size\:buffer_s}
{\xe \v buffer_s\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile Uint16 size}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b buffer.h}.}\par
}
{\xe \v tail\:buffer_s}
{\xe \v buffer_s\:tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile Uint16 tail}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b buffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b buffer.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
phonedata_s Union Reference\par \pard\plain 
{\tc\tcl2 \v phonedata_s}
{\xe \v phonedata_s}
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b rawdata} [6]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fltdata} [3]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 50} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v fltdata\:phonedata_s}
{\xe \v phonedata_s\:fltdata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float fltdata}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v rawdata\:phonedata_s}
{\xe \v phonedata_s\:rawdata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t rawdata}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this union was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Segbot_Steer_and_Celebrate.c}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UART_Segbot2.c}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UART_Segbot3.c}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UART_Segbot4.c}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RFFT_ADC_F32_STRUCT Struct Reference\par \pard\plain 
{\tc\tcl2 \v RFFT_ADC_F32_STRUCT}
{\xe \v RFFT_ADC_F32_STRUCT}
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT with ADC input. }}\par
{
{\f2 #include <fpu_rfft.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t * {\b InBuf}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the input buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b Tail}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Null pointer to the OutBuf of {\b RFFT_F32_STRUCT}. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT with ADC input. \par
}{
Definition at line {\b 92} of file {\b fpu_rfft.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v InBuf\:RFFT_ADC_F32_STRUCT}
{\xe \v RFFT_ADC_F32_STRUCT\:InBuf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t* InBuf}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the input buffer. }}\par
{
Definition at line {\b 93} of file {\b fpu_rfft.h}.}\par
}
{\xe \v Tail\:RFFT_ADC_F32_STRUCT}
{\xe \v RFFT_ADC_F32_STRUCT\:Tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* Tail}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Null pointer to the OutBuf of {\b RFFT_F32_STRUCT}. }}\par
{
Definition at line {\b 94} of file {\b fpu_rfft.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fpu_rfft.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RFFT_F32_STRUCT Struct Reference\par \pard\plain 
{\tc\tcl2 \v RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT}
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT. }}\par
{
{\f2 #include <fpu_rfft.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float * {\b InBuf}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the input buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float * {\b OutBuf}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the output buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float * {\b CosSinBuf}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the twiddle factors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float * {\b MagBuf}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the magnitude buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float * {\b PhaseBuf}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the phase buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b FFTSize}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the FFT (number of real data points) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b FFTStages}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of FFT stages. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT. \par
}{
Definition at line {\b 76} of file {\b fpu_rfft.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v CosSinBuf\:RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT\:CosSinBuf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float* CosSinBuf}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the twiddle factors. }}\par
{
Definition at line {\b 79} of file {\b fpu_rfft.h}.}\par
}
{\xe \v FFTSize\:RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT\:FFTSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t FFTSize}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Size of the FFT (number of real data points) }}\par
{
Definition at line {\b 82} of file {\b fpu_rfft.h}.}\par
}
{\xe \v FFTStages\:RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT\:FFTStages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t FFTStages}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of FFT stages. }}\par
{
Definition at line {\b 83} of file {\b fpu_rfft.h}.}\par
}
{\xe \v InBuf\:RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT\:InBuf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float* InBuf}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the input buffer. }}\par
{
Definition at line {\b 77} of file {\b fpu_rfft.h}.}\par
}
{\xe \v MagBuf\:RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT\:MagBuf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float* MagBuf}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the magnitude buffer. }}\par
{
Definition at line {\b 80} of file {\b fpu_rfft.h}.}\par
}
{\xe \v OutBuf\:RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT\:OutBuf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float* OutBuf}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the output buffer. }}\par
{
Definition at line {\b 78} of file {\b fpu_rfft.h}.}\par
}
{\xe \v PhaseBuf\:RFFT_F32_STRUCT}
{\xe \v RFFT_F32_STRUCT\:PhaseBuf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float* PhaseBuf}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to the phase buffer. }}\par
{
Definition at line {\b 81} of file {\b fpu_rfft.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fpu_rfft.h}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
serial_s Struct Reference\par \pard\plain 
{\tc\tcl2 \v serial_s}
{\xe \v serial_s}
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
\par
{
{\f2 #include <F28379dSerial.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct {\b buffer_s} {\b TX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SCI_REGS * {\b sci}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b got_data} )(struct {\b serial_s} *s, char data)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 15} of file {\b F28379dSerial.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v got_data\:serial_s}
{\xe \v serial_s\:got_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* got_data) (struct {\b serial_s} *s, char data)}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b F28379dSerial.h}.}\par
}
{\xe \v sci\:serial_s}
{\xe \v serial_s\:sci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SCI_REGS* sci}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b F28379dSerial.h}.}\par
}
{\xe \v TX\:serial_s}
{\xe \v serial_s\:TX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct {\b buffer_s} TX}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b F28379dSerial.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F28379dSerial.h}}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bed\'F8mmelse_av_AI.md File Reference\par \pard\plain 
{\tc\tcl2 \v bed\'F8mmelse_av_AI.md}
{\xe \v bed\'F8mmelse_av_AI.md}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
buffer.h File Reference\par \pard\plain 
{\tc\tcl2 \v buffer.h}
{\xe \v buffer.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b buffer_s}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BUF_SIZE}\~ (4*1000 + 8)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b buf_clear}(b)\~ {\b init_buffer}(b)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef volatile struct {\b buffer_s} {\b buffer_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_buffer} ({\b buffer_t} *b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b buf_write_1} ({\b buffer_t} *b, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b buf_read_1} ({\b buffer_t} *b, Uint16 offset, char *data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b buf_remove} ({\b buffer_t} *b, Uint16 len)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v buf_clear\:buffer.h}
{\xe \v buffer.h\:buf_clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define buf_clear( b)\~ {\b init_buffer}(b)}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b buffer.h}.}\par
}
{\xe \v BUF_SIZE\:buffer.h}
{\xe \v buffer.h\:BUF_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BUF_SIZE\~ (4*1000 + 8)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b buffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v buffer_t\:buffer.h}
{\xe \v buffer.h\:buffer_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef volatile struct {\b buffer_s} {\b buffer_t}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v buf_read_1\:buffer.h}
{\xe \v buffer.h\:buf_read_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t buf_read_1 ({\b buffer_t} * b, Uint16 offset, char * data){\f2 [extern]}, {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b buffer.h}.}\par
}
{\xe \v buf_remove\:buffer.h}
{\xe \v buffer.h\:buf_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t buf_remove ({\b buffer_t} * b, Uint16 len){\f2 [extern]}, {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b buffer.h}.}\par
}
{\xe \v buf_write_1\:buffer.h}
{\xe \v buffer.h\:buf_write_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t buf_write_1 ({\b buffer_t} * b, char data){\f2 [extern]}, {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b buffer.h}.}\par
}
{\xe \v init_buffer\:buffer.h}
{\xe \v buffer.h\:init_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_buffer ({\b buffer_t} * b){\f2 [extern]}, {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b buffer.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
buffer.h\par \pard\plain 
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00002 {\cf21 #ifndef __BUFFER_H__}\par
00003 {\cf21 #define __BUFFER_H__}\par
00004 \par
00005 {\cf21 #define BUF_SIZE        (4*1000 + 8)}\par
00006 \par
00007 {\cf17 typedef} {\cf17 volatile} {\cf17 struct }buffer_s \{\par
00008     {\cf17 volatile} {\cf18 char} buf[BUF_SIZE];\par
00009     {\cf17 volatile} Uint16 head, tail, size;\par
00010 \} buffer_t;\par
00011 \par
00012 \par
00013 \par
00014 {\cf17 extern} {\cf17 inline} {\cf18 void} init_buffer(buffer_t *b)\par
00015 \{\par
00016     b->size = b->head = b->tail = 0;\par
00017 \}\par
00018 {\cf21 #define buf_clear(b)            init_buffer(b)}\par
00019 \par
00020 {\cf21 #ifdef _FLASH}\par
00021 {\cf21 #pragma CODE_SECTION(buf_write_1, ".TI.ramfunc");}\par
00022 {\cf21 #endif}\par
00023 {\cf17 extern} {\cf17 inline} uint16_t buf_write_1(buffer_t *b, {\cf18 char} data)\par
00024 \{\par
00025     {\cf19 if} (b->size == BUF_SIZE) {\cf19 return} 2;\par
00026     b->buf[b->head] = data;\par
00027     b->head = (b->head+1)%BUF_SIZE;\par
00028     b->size++;\par
00029     {\cf19 return} 0;\par
00030 \}\par
00031 \par
00032 {\cf21 #ifdef _FLASH}\par
00033 {\cf21 #pragma CODE_SECTION(buf_read_1, ".TI.ramfunc");}\par
00034 {\cf21 #endif}\par
00035 {\cf17 extern} {\cf17 inline} uint16_t buf_read_1(buffer_t *b, Uint16 offset, {\cf18 char} *data)\par
00036 \{\par
00037     {\cf19 if} (b->size == 0 || b->size < offset) {\cf19 return} 3;\par
00038     *data = b->buf[ (b->tail+offset)%BUF_SIZE ];\par
00039     {\cf19 return} 0;\par
00040 \}\par
00041 \par
00042 {\cf21 #ifdef _FLASH}\par
00043 {\cf21 #pragma CODE_SECTION(buf_remove, ".TI.ramfunc");}\par
00044 {\cf21 #endif}\par
00045 {\cf17 extern} {\cf17 inline} uint16_t buf_remove(buffer_t *b, Uint16 len)\par
00046 \{\par
00047     len = (len > b->size) ? b->size : len;\par
00048     b->tail = (b->tail+len)%BUF_SIZE;\par
00049     b->size -= len;\par
00050     {\cf19 return} len;\par
00051 \}\par
00052 \par
00053 {\cf21 #endif }{\cf20 /* __BUFFER_H__ */}{\cf21 }\par
00054 \par
00055 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dsp.h File Reference\par \pard\plain 
{\tc\tcl2 \v dsp.h}
{\xe \v dsp.h}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DSP Library Definitions and Types. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _RTS_IN_USE_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LIBRARY_VERSION}\~ "2.05.00.00"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DSP Library Version. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b C2000_IEEE754_TYPES}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef float {\b float32_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long double {\b float64_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b v_pfn_v}) (void *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function pointer with a void pointer argument returning nothing. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DSP Library Definitions and Types. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Vishal Coelho \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Date\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Jan 11, 2016 \par
}}}{
Definition in file {\b dsp.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _RTS_IN_USE_\:dsp.h}
{\xe \v dsp.h\:_RTS_IN_USE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _RTS_IN_USE_}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b dsp.h}.}\par
}
{\xe \v C2000_IEEE754_TYPES\:dsp.h}
{\xe \v dsp.h\:C2000_IEEE754_TYPES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define C2000_IEEE754_TYPES}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b dsp.h}.}\par
}
{\xe \v LIBRARY_VERSION\:dsp.h}
{\xe \v dsp.h\:LIBRARY_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LIBRARY_VERSION\~ "2.05.00.00"}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DSP Library Version. }}\par
{
Definition at line {\b 45} of file {\b dsp.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v float32_t\:dsp.h}
{\xe \v dsp.h\:float32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef float {\b float32_t}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b dsp.h}.}\par
}
{\xe \v float64_t\:dsp.h}
{\xe \v dsp.h\:float64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long double {\b float64_t}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b dsp.h}.}\par
}
{\xe \v v_pfn_v\:dsp.h}
{\xe \v dsp.h\:v_pfn_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* v_pfn_v) (void *)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function pointer with a void pointer argument returning nothing. }}\par
{
Definition at line {\b 105} of file {\b dsp.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dsp.h\par \pard\plain 
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef _DSP_H_}\par
00002 {\cf21 #define _DSP_H_}\par
00003 {\cf20 //#############################################################################}\par
00004 {\cf20 //}\par
00010 {\cf20 //}\par
00011 {\cf20 //  Group:          C2000}\par
00012 {\cf20 //  Target Device:  C28x+FPU32/FPU64}\par
00013 {\cf20 //}\par
00014 {\cf20 //#############################################################################}\par
00015 {\cf20 //}\par
00016 {\cf20 //}\par
00017 {\cf20 // $Copyright: Copyright (C) 2024 Texas Instruments Incorporated -}\par
00018 {\cf20 //             http://www.ti.com/ ALL RIGHTS RESERVED $}\par
00019 {\cf20 //#############################################################################}\par
00020 \par
00021 {\cf21 #ifndef _RTS_IN_USE_}\par
00022 {\cf21 #define _RTS_IN_USE_}\par
00023 {\cf20 //This conditional prevents the following data types from conflicting with the}\par
00024 {\cf20 //FPUfastRTS library}\par
00025 \par
00026 {\cf20 //*****************************************************************************}\par
00027 {\cf20 // the includes}\par
00028 {\cf20 //*****************************************************************************}\par
00029 {\cf21 #include <stdint.h>}\par
00030 \par
00035 {\cf20 // @\{}\par
00036 \par
00037 {\cf21 #ifdef __cplusplus}\par
00038 {\cf17 extern} {\cf22 "C"} \{\par
00039 {\cf21 #endif}\par
00040 \par
00041 {\cf20 //*****************************************************************************}\par
00042 {\cf20 //defines}\par
00043 {\cf20 //*****************************************************************************}\par
00045 {\cf21 #define LIBRARY_VERSION     "2.05.00.00"}\par
00046 \par
00047 \par
00048 {\cf20 //*****************************************************************************}\par
00049 {\cf20 // typedefs}\par
00050 {\cf20 //*****************************************************************************}\par
00051 {\cf20 // c2000 types for IEEE754 (same as defined in <device>/inc/hw_types.h)}\par
00052 {\cf21 #ifndef C2000_IEEE754_TYPES}\par
00053 {\cf21 #define C2000_IEEE754_TYPES}\par
00054 {\cf21 #ifdef __TI_EABI__}\par
00055 {\cf17 typedef} {\cf18 float}         float32_t;\par
00056 {\cf17 typedef} {\cf18 double}        float64_t;\par
00057 {\cf21 #else }{\cf20 // TI COFF}\par
00058 {\cf17 typedef} {\cf18 float}         float32_t;\par
00059 {\cf17 typedef} {\cf18 long} {\cf18 double}   float64_t;\par
00060 {\cf21 #endif }{\cf20 // __TI_EABI__}\par
00061 {\cf21 #endif }{\cf20 // C2000_IEEE754_TYPES}\par
00062 \par
00063 {\cf21 #if defined(__TMS320C28XX_FPU64__)}\par
00072 {\cf17 typedef} {\cf17 union}\par
00073 \{\par
00074     uint64_t    ui64; \par
00075     int64_t     i64;  \par
00076     float64_t   f64;  \par
00077 \}float64u_t;\par
00078 {\cf21 #endif }{\cf20 //defined(__TMS320C28XX_FPU64__)}\par
00079 \par
00080 {\cf21 #if (defined(__TMS320C28XX_FPU32__) || defined(__TMS320C28XX_FPU64__))}\par
00089 {\cf17 typedef} {\cf17 union}\par
00090 \{\par
00091     uint32_t    ui32; \par
00092     int32_t     i32;  \par
00093     {\cf18 float}       f32;  \par
00094 \}float32u_t;\par
00095 {\cf21 #endif }{\cf20 //defined(__TMS320C28XX_FPU32__)}\par
00096 \par
00097 {\cf21 #if !(defined(__TMS320C28XX_FPU32__) || defined(__TMS320C28XX_FPU64__))}\par
00098 {\cf21 #error "--float_support=fpu64 option must be set to build the FPU64        \\}\par
00099 {\cf21     version of the library. --float_support=fpu32 must be set to build the \\}\par
00100 {\cf21     FPU32 version of the DSP library"}\par
00101 {\cf21 #endif }{\cf20 // (defined(__TMS320C28XX_FPU32__) || defined(__TMS320C28XX_FPU64__))}\par
00102 \par
00105 {\cf17 typedef} void (*v_pfn_v)({\cf18 void} *);\par
00106 \par
00107 {\cf21 #endif }{\cf20 // _RTS_IN_USE_}\par
00108 \par
00109 {\cf20 // @\} //addtogroup}\par
00110 \par
00111 {\cf21 #ifdef __cplusplus}\par
00112 \}\par
00113 {\cf21 #endif }{\cf20 // extern "C"}\par
00114 \par
00115 {\cf21 #endif  }{\cf20 // end of  _DSP_H_}\par
00116 \par
00117 {\cf20 // End of File}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F28379dSerial.c File Reference\par \pard\plain 
{\tc\tcl2 \v F28379dSerial.c}
{\xe \v F28379dSerial.c}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
{\f2 #include <buffer.h>}\par
{\f2 #include <f28379dSerial.h>}\par
{\f2 #include <F2837xD_sci.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b init_serial} ({\b serial_t} *s, uint32_t baud, void(*got_func)({\b serial_t} *s, char data))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uninit_serial} ({\b serial_t} *s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b serial_send} ({\b serial_t} *s, char *data, uint16_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b TXAINT_data_sent} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b TXCINT_data_sent} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b TXDINT_data_sent} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b RXAINT_recv_ready} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b RXCINT_recv_ready} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b RXDINT_recv_ready} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b serial_printf} ({\b serial_t} *s, char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UART_vprintfLine} (unsigned char line, char *format, va_list ap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UART_printfLine} (unsigned char line, char *format,...)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serial_t} {\b SerialA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serial_t} {\b SerialC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serial_t} {\b SerialD}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_serial\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:init_serial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t init_serial ({\b serial_t} * s, uint32_t baud, void(* got_func\~ )({\b serial_t} *s, char data))}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b F28379dSerial.c}.}\par
}
{\xe \v RXAINT_recv_ready\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:RXAINT_recv_ready}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void RXAINT_recv_ready (void )}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 311} of file {\b F28379dSerial.c}.}\par
}
{\xe \v RXCINT_recv_ready\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:RXCINT_recv_ready}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void RXCINT_recv_ready (void )}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 333} of file {\b F28379dSerial.c}.}\par
}
{\xe \v RXDINT_recv_ready\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:RXDINT_recv_ready}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void RXDINT_recv_ready (void )}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 345} of file {\b F28379dSerial.c}.}\par
}
{\xe \v serial_printf\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:serial_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t serial_printf ({\b serial_t} * s, char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 358} of file {\b F28379dSerial.c}.}\par
}
{\xe \v serial_send\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:serial_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t serial_send ({\b serial_t} * s, char * data, uint16_t len)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b F28379dSerial.c}.}\par
}
{\xe \v TXAINT_data_sent\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:TXAINT_data_sent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void TXAINT_data_sent (void )}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 209} of file {\b F28379dSerial.c}.}\par
}
{\xe \v TXCINT_data_sent\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:TXCINT_data_sent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void TXCINT_data_sent (void )}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 251} of file {\b F28379dSerial.c}.}\par
}
{\xe \v TXDINT_data_sent\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:TXDINT_data_sent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void TXDINT_data_sent (void )}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 271} of file {\b F28379dSerial.c}.}\par
}
{\xe \v UART_printfLine\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:UART_printfLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UART_printfLine (unsigned char line, char * format,  ...)}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 393} of file {\b F28379dSerial.c}.}\par
}
{\xe \v UART_vprintfLine\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:UART_vprintfLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UART_vprintfLine (unsigned char line, char * format, va_list ap)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 370} of file {\b F28379dSerial.c}.}\par
}
{\xe \v uninit_serial\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:uninit_serial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uninit_serial ({\b serial_t} * s)}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b F28379dSerial.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SerialA\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:SerialA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b serial_t} SerialA}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b F28379dSerial.c}.}\par
}
{\xe \v SerialC\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:SerialC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b serial_t} SerialC}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b F28379dSerial.c}.}\par
}
{\xe \v SerialD\:F28379dSerial.c}
{\xe \v F28379dSerial.c\:SerialD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b serial_t} SerialD}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b F28379dSerial.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F28379dSerial.c\par \pard\plain 
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /* SERIAL.C: This code is designed to act as a low-level serial driver for}\par
00002 {\cf20     higher-level programming.  Ideally, one could simply call init_serial()}\par
00003 {\cf20     to initialize the serial port, then use serial_send("data", 4) to send}\par
00004 {\cf20     an array of data (8-bit unsigned character strings).}\par
00005 {\cf20 }\par
00006 {\cf20     WRITTEN BY : Paul Miller <pamiller@uiuc.edu>}\par
00007 {\cf20     $Id: serial.c,v 1.4 2003/08/08 16:08:56 paul Exp $}\par
00008 {\cf20 */}\par
00009 {\cf21 #include <stdio.h>}\par
00010 {\cf21 #include <stdlib.h>}\par
00011 {\cf21 #include <stdarg.h>}\par
00012 {\cf21 #include <string.h>}\par
00013 {\cf21 #include <math.h>}\par
00014 {\cf21 #include <limits.h>}\par
00015 \par
00016 {\cf21 #include "F28x_Project.h"}     {\cf20 // Device Headerfile and Examples Include File}\par
00017 {\cf21 #include <buffer.h>}\par
00018 {\cf21 #include <f28379dSerial.h>}\par
00019 {\cf21 #include <F2837xD_sci.h>}\par
00020 \par
00021 \par
00022 serial_t SerialA;\par
00023 {\cf20 //serial_t SerialB;  // Currently not used by default}\par
00024 serial_t SerialC;\par
00025 serial_t SerialD;\par
00026 \par
00027 uint16_t init_serial(serial_t *s, uint32_t baud, {\cf18 void} (*got_func)(serial_t *s, {\cf18 char} data))\par
00028 \{\par
00029     {\cf17 volatile} {\cf17 struct }SCI_REGS *sci;\par
00030     uint32_t clk;\par
00031 \par
00032     {\cf19 if} (s == &SerialA) \{\par
00033         sci = &SciaRegs;\par
00034 \par
00035         GPIO_SetupPinMux(43, GPIO_MUX_CPU1, 15);\par
00036         GPIO_SetupPinOptions(43, GPIO_INPUT, GPIO_PULLUP);\par
00037         GPIO_SetupPinMux(42, GPIO_MUX_CPU1, 15);\par
00038         GPIO_SetupPinOptions(42, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00039 \par
00040 {\cf20 //    \} else if (s == &SerialB) \{}\par
00041 {\cf20 //        sci = &ScibRegs;}\par
00042 {\cf20 //}\par
00043 {\cf20 //        GPIO_SetupPinMux(87, GPIO_MUX_CPU1, 5);}\par
00044 {\cf20 //        GPIO_SetupPinOptions(87, GPIO_INPUT, GPIO_PULLUP);}\par
00045 {\cf20 //        GPIO_SetupPinMux(86, GPIO_MUX_CPU1, 5);}\par
00046 {\cf20 //        GPIO_SetupPinOptions(86, GPIO_OUTPUT, GPIO_PUSHPULL);}\par
00047 \par
00048 \par
00049     \} {\cf19 else} {\cf19 if} (s == &SerialC) \{\par
00050         sci = &ScicRegs;\par
00051 \par
00052         GPIO_SetupPinMux(139, GPIO_MUX_CPU1, 6);\par
00053         GPIO_SetupPinOptions(139, GPIO_INPUT, GPIO_PULLUP);\par
00054         GPIO_SetupPinMux(56, GPIO_MUX_CPU1, 6);\par
00055         GPIO_SetupPinOptions(56, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00056 \par
00057     \} {\cf19 else} {\cf19 if} (s == &SerialD) \{\par
00058         sci = &ScidRegs;\par
00059 \par
00060         GPIO_SetupPinMux(105, GPIO_MUX_CPU1, 6);\par
00061         GPIO_SetupPinOptions(105, GPIO_INPUT, GPIO_PULLUP);\par
00062         GPIO_SetupPinMux(104, GPIO_MUX_CPU1, 6);\par
00063         GPIO_SetupPinOptions(104, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00064     \}\par
00065     {\cf19 else} \{\par
00066         {\cf19 return} 1;\par
00067     \}\par
00068 \par
00069     s->sci = sci;\par
00070     s->got_data = got_func;\par
00071 \par
00072     init_buffer(&s->TX);\par
00073 \par
00074     {\cf20 /* init for standard baud,8N1 comm */}\par
00075     sci->SCICTL1.bit.SWRESET = 0;       {\cf20 // init SCI state machines and opt flags}\par
00076     sci->SCICCR.all = 0x0;\par
00077     sci->SCICTL1.all = 0x0;\par
00078     sci->SCICTL2.all = 0x0;\par
00079     sci->SCIPRI.all = 0x0;\par
00080     clk = LSPCLK_HZ;                    {\cf20 // set baud rate}\par
00081     clk /= baud*8;\par
00082     clk--;\par
00083     sci->SCILBAUD.all = clk & 0xFF;\par
00084     sci->SCIHBAUD.all = (clk >> 8) & 0xFF;\par
00085 \par
00086     sci->SCICCR.bit.SCICHAR = 0x7;      {\cf20 // (8) 8 bits per character}\par
00087     sci->SCICCR.bit.PARITYENA = 0;      {\cf20 // (N) disable party calculation}\par
00088     sci->SCICCR.bit.STOPBITS = 0;       {\cf20 // (1) transmit 1 stop bit}\par
00089     sci->SCICCR.bit.LOOPBKENA = 0;      {\cf20 // disable loopback test}\par
00090     sci->SCICCR.bit.ADDRIDLE_MODE = 0;  {\cf20 // idle-line mode (non-multiprocessor SCI comm)}\par
00091 \par
00092     sci->SCIFFCT.bit.FFTXDLY = 0;       {\cf20 // TX: zero-delay}\par
00093 \par
00094     sci->SCIFFTX.bit.SCIFFENA = 1;      {\cf20 // enable SCI fifo enhancements}\par
00095     sci->SCIFFTX.bit.TXFIFORESET = 0;\par
00096     sci->SCIFFTX.bit.TXFFIL = 0x0;{\cf20 // TX: fifo interrupt at all levels   ???? is this correct}\par
00097     sci->SCIFFTX.bit.TXFFINTCLR = 1;  {\cf20 // TX: clear interrupt flag}\par
00098     sci->SCIFFTX.bit.TXFFIENA = 0;      {\cf20 // TX: disable fifo interrupt}\par
00099     sci->SCIFFTX.bit.TXFIFORESET = 1;\par
00100 \par
00101     sci->SCIFFRX.bit.RXFIFORESET = 0;   {\cf20 // RX: fifo reset}\par
00102     sci->SCIFFRX.bit.RXFFINTCLR = 1;    {\cf20 // RX: clear interrupt flag}\par
00103     sci->SCIFFRX.bit.RXFFIENA = 1;      {\cf20 // RX: enable fifo interrupt}\par
00104     sci->SCIFFRX.bit.RXFFIL = 0x1;      {\cf20 // RX: fifo interrupt}\par
00105     sci->SCIFFRX.bit.RXFIFORESET = 1;   {\cf20 // RX: re-enable fifo}\par
00106 \par
00107     sci->SCICTL2.bit.RXBKINTENA = 0;    {\cf20 // disable receiver/error interrupt}\par
00108     sci->SCICTL2.bit.TXINTENA = 0;      {\cf20 // disable transmitter interrupt}\par
00109 \par
00110     sci->SCICTL1.bit.TXWAKE = 0;\par
00111     sci->SCICTL1.bit.SLEEP = 0;         {\cf20 // disable sleep mode}\par
00112     sci->SCICTL1.bit.RXENA = 1;         {\cf20 // enable SCI receiver}\par
00113     sci->SCICTL1.bit.RXERRINTENA = 0;   {\cf20 // disable receive error interrupt}\par
00114     sci->SCICTL1.bit.TXENA = 1;         {\cf20 // enable SCI transmitter}\par
00115     sci->SCICTL1.bit.SWRESET = 1;       {\cf20 // re-enable SCI}\par
00116 \par
00117     {\cf20 /* enable PIE interrupts */}\par
00118     {\cf19 if} (s == &SerialA) \{\par
00119         PieCtrlRegs.PIEIER9.bit.INTx1 = 1;\par
00120         PieCtrlRegs.PIEIER9.bit.INTx2 = 1;\par
00121         IER |= (M_INT9);\par
00122         PieCtrlRegs.PIEACK.all = (PIEACK_GROUP9);\par
00123 \par
00124 {\cf20 //    \} else if (s == &SerialB) \{}\par
00125 {\cf20 //        PieCtrlRegs.PIEIER9.bit.INTx3 = 1;}\par
00126 {\cf20 //        PieCtrlRegs.PIEIER9.bit.INTx4 = 1;}\par
00127 {\cf20 //        IER |= (M_INT9);}\par
00128 \par
00129     \} {\cf19 else} {\cf19 if} (s == &SerialC) \{\par
00130         PieCtrlRegs.PIEIER8.bit.INTx5 = 1;\par
00131         PieCtrlRegs.PIEIER8.bit.INTx6 = 1;\par
00132         PieCtrlRegs.PIEACK.all = (PIEACK_GROUP8);\par
00133         IER |= (M_INT8);\par
00134 \par
00135     \} {\cf19 else} {\cf19 if} (s == &SerialD) \{\par
00136         PieCtrlRegs.PIEIER8.bit.INTx7 = 1;\par
00137         PieCtrlRegs.PIEIER8.bit.INTx8 = 1;\par
00138         PieCtrlRegs.PIEACK.all = (PIEACK_GROUP8);\par
00139         IER |= (M_INT8);\par
00140     \}\par
00141 \par
00142     {\cf19 return} 0;\par
00143 \}\par
00144 \par
00145 {\cf20 //#pragma CODE_SECTION(uninit_serial, "initfuncs");}\par
00146 {\cf18 void} uninit_serial(serial_t *s)\par
00147 \{\par
00148     {\cf17 volatile} {\cf17 struct }SCI_REGS *sci = s->sci;\par
00149 \par
00150     {\cf20 /* disable PIE interrupts */}\par
00151     {\cf19 if} (s == &SerialA) \{\par
00152         PieCtrlRegs.PIEIER9.bit.INTx1 = 0;\par
00153         PieCtrlRegs.PIEIER9.bit.INTx2 = 0;\par
00154         IER &= ~M_INT9;\par
00155 {\cf20 //    \} else if (s == &SerialB) \{}\par
00156 {\cf20 //        PieCtrlRegs.PIEIER9.bit.INTx3 = 0;}\par
00157 {\cf20 //        PieCtrlRegs.PIEIER9.bit.INTx4 = 0;}\par
00158 {\cf20 //        IER &= ~M_INT9;}\par
00159     \} {\cf19 else} {\cf19 if} (s == &SerialC) \{\par
00160         PieCtrlRegs.PIEIER8.bit.INTx5 = 0;\par
00161         PieCtrlRegs.PIEIER8.bit.INTx6 = 0;\par
00162         IER &= ~M_INT8;\par
00163     \} {\cf19 else} {\cf19 if} (s == &SerialD) \{\par
00164         PieCtrlRegs.PIEIER8.bit.INTx7 = 0;\par
00165         PieCtrlRegs.PIEIER8.bit.INTx8 = 0;\par
00166         IER &= ~M_INT8;\par
00167     \}\par
00168 \par
00169     sci->SCICTL1.bit.RXERRINTENA = 0;   {\cf20 // disable receive error interrupt}\par
00170     sci->SCICTL2.bit.RXBKINTENA = 0;    {\cf20 // disable receiver/error interrupt}\par
00171     sci->SCICTL2.bit.TXINTENA = 0;      {\cf20 // disable transmitter interrupt}\par
00172 \par
00173     sci->SCICTL1.bit.RXENA = 0;         {\cf20 // disable SCI receiver}\par
00174     sci->SCICTL1.bit.TXENA = 0;         {\cf20 // disable SCI transmitter}\par
00175 \}\par
00176 \par
00177 \par
00178 \par
00179 {\cf20 /***************************************************************************}\par
00180 {\cf20  * SERIAL_SEND()}\par
00181 {\cf20  *}\par
00182 {\cf20  * "User level" function to send data via serial.  Return value is the}\par
00183 {\cf20  * length of data successfully copied to the TX buffer.}\par
00184 {\cf20  ***************************************************************************/}\par
00185 \par
00186 uint16_t serial_send(serial_t *s, {\cf18 char} *data, uint16_t len)\par
00187 \{\par
00188     uint16_t i = 0;\par
00189     {\cf19 if} (len && s->TX.size < BUF_SIZE) \{\par
00190         {\cf19 for} (i = 0; i < len; i++) \{\par
00191             {\cf19 if} (buf_write_1(&s->TX, data[i] & 0x00FF) != 0) {\cf19 break};\par
00192         \}\par
00193         s->sci->SCIFFTX.bit.TXFFINTCLR = 1;  {\cf20 // TX: clear interrupt flag}\par
00194         s->sci->SCIFFTX.bit.TXFFIENA = 1;       {\cf20 // TX: enable fifo interrupt}\par
00195     \}\par
00196     {\cf19 return} i;\par
00197 \}\par
00198 \par
00199 \par
00200 {\cf20 /***************************************************************************}\par
00201 {\cf20  * TXxINT_DATA_SENT()}\par
00202 {\cf20  *}\par
00203 {\cf20  * Executed when transmission is ready for additional data.  These functions}\par
00204 {\cf20  * read the next char of data and put it in the TXBUF register for transfer.}\par
00205 {\cf20  ***************************************************************************/}\par
00206 {\cf21 #ifdef _FLASH}\par
00207 {\cf21 #pragma CODE_SECTION(TXAINT_data_sent, ".TI.ramfunc");}\par
00208 {\cf21 #endif}\par
00209 __interrupt {\cf18 void} TXAINT_data_sent({\cf18 void})\par
00210 \{\par
00211     {\cf18 char} data;\par
00212     {\cf19 if} (buf_read_1(&SerialA.TX,0,&data) == 0) \{\par
00213         {\cf19 while} ( (buf_read_1(&SerialA.TX,0,&data) == 0)\par
00214                 && (SerialA.sci->SCIFFTX.bit.TXFFST != 0x10) ) \{\par
00215             buf_remove(&SerialA.TX, 1);\par
00216             SerialA.sci->SCITXBUF.all = data;\par
00217         \}\par
00218     \} {\cf19 else} \{\par
00219         SerialA.sci->SCIFFTX.bit.TXFFIENA = 0;      {\cf20 // TX: disable fifo interrupt}\par
00220     \}\par
00221     SerialA.sci->SCIFFTX.bit.TXFFINTCLR = 1;  {\cf20 // TX: clear interrupt flag}\par
00222     PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\par
00223 \}\par
00224 \par
00225 \par
00226 {\cf20 //for serialB}\par
00227 {\cf20 //#ifdef _FLASH}\par
00228 {\cf20 //#pragma CODE_SECTION(TXBINT_data_sent, ".TI.ramfunc");}\par
00229 {\cf20 //#endif}\par
00230 {\cf20 //__interrupt void TXBINT_data_sent(void)}\par
00231 {\cf20 //\{}\par
00232 {\cf20 //    char data;}\par
00233 {\cf20 //    if (buf_read_1(&SerialB.TX,0,&data) == NO_ERROR) \{}\par
00234 {\cf20 //        while ( (buf_read_1(&SerialB.TX,0,&data) == NO_ERROR)}\par
00235 {\cf20 //                && (SerialB.sci->SCIFFTX.bit.TXFFST != 0x10) ) \{}\par
00236 {\cf20 //            buf_remove(&SerialB.TX, 1);}\par
00237 {\cf20 //            SerialB.sci->SCITXBUF.all = data;}\par
00238 {\cf20 //        \}}\par
00239 {\cf20 //    \} else \{}\par
00240 {\cf20 //        SerialB.sci->SCIFFTX.bit.TXFFIENA = 0;      // TX: disable fifo interrupt}\par
00241 {\cf20 //    \}}\par
00242 {\cf20 //    SerialB.sci->SCIFFTX.bit.TXFFINTCLR = 1;  // TX: clear interrupt flag}\par
00243 {\cf20 //    PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
00244 {\cf20 //\}}\par
00245 \par
00246 \par
00247 {\cf20 //for serialC}\par
00248 {\cf21 #ifdef _FLASH}\par
00249 {\cf21 #pragma CODE_SECTION(TXCINT_data_sent, ".TI.ramfunc");}\par
00250 {\cf21 #endif}\par
00251 __interrupt {\cf18 void} TXCINT_data_sent({\cf18 void})\par
00252 \{\par
00253     {\cf18 char} data;\par
00254     {\cf19 if} (buf_read_1(&SerialC.TX,0,&data) == 0) \{\par
00255         {\cf19 while} ( (buf_read_1(&SerialC.TX,0,&data) == 0)\par
00256                 && (SerialC.sci->SCIFFTX.bit.TXFFST != 0x10) ) \{\par
00257             buf_remove(&SerialC.TX, 1);\par
00258             SerialC.sci->SCITXBUF.all = data;\par
00259         \}\par
00260     \} {\cf19 else} \{\par
00261         SerialC.sci->SCIFFTX.bit.TXFFIENA = 0;      {\cf20 // TX: disable fifo interrupt}\par
00262     \}\par
00263     SerialC.sci->SCIFFTX.bit.TXFFINTCLR = 1;  {\cf20 // TX: clear interrupt flag}\par
00264     PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\par
00265 \}\par
00266 \par
00267 {\cf20 //for serialD}\par
00268 {\cf21 #ifdef _FLASH}\par
00269 {\cf21 #pragma CODE_SECTION(TXDINT_data_sent, ".TI.ramfunc");}\par
00270 {\cf21 #endif}\par
00271 __interrupt {\cf18 void} TXDINT_data_sent({\cf18 void})\par
00272 \{\par
00273     {\cf18 char} data;\par
00274     {\cf19 if} (buf_read_1(&SerialD.TX,0,&data) == 0) \{\par
00275         {\cf19 while} ( (buf_read_1(&SerialD.TX,0,&data) == 0)\par
00276                 && (SerialD.sci->SCIFFTX.bit.TXFFST != 0x10) ) \{\par
00277             buf_remove(&SerialD.TX, 1);\par
00278             SerialD.sci->SCITXBUF.all = data;\par
00279         \}\par
00280     \} {\cf19 else} \{\par
00281         SerialD.sci->SCIFFTX.bit.TXFFIENA = 0;      {\cf20 // TX: disable fifo interrupt}\par
00282     \}\par
00283     SerialD.sci->SCIFFTX.bit.TXFFINTCLR = 1;  {\cf20 // TX: clear interrupt flag}\par
00284     PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\par
00285 \}\par
00286 \par
00287 {\cf20 /***************************************************************************}\par
00288 {\cf20  * RXxINT_RECV_READY()}\par
00289 {\cf20  *}\par
00290 {\cf20  * Executed when data is received.}\par
00291 {\cf20  ***************************************************************************/}\par
00292 \par
00293 {\cf17 static} {\cf17 inline} {\cf18 void} serial_recv_ready(serial_t *s)\par
00294 \{\par
00295     {\cf18 char} data = s->sci->SCIRXBUF.all;\par
00296 \par
00297     {\cf20 /* SCI PE or FE error */}\par
00298     {\cf19 if} (data & 0xC000) \{\par
00299         s->sci->SCICTL1.bit.SWRESET = 0;\par
00300         s->sci->SCICTL1.bit.SWRESET = 1;\par
00301         s->sci->SCIFFRX.bit.RXFIFORESET = 0;\par
00302         s->sci->SCIFFRX.bit.RXFIFORESET = 1;\par
00303     \} {\cf19 else} {\cf19 if} (s->got_data) \{\par
00304         s->got_data(s, data & 0x00FF);\par
00305     \}\par
00306 \}\par
00307 \par
00308 {\cf21 #ifdef _FLASH}\par
00309 {\cf21 #pragma CODE_SECTION(RXAINT_recv_ready, ".TI.ramfunc");}\par
00310 {\cf21 #endif}\par
00311 __interrupt {\cf18 void} RXAINT_recv_ready({\cf18 void})\par
00312 \{\par
00313     serial_recv_ready(&SerialA);\par
00314     SciaRegs.SCIFFRX.bit.RXFFINTCLR = 1;\par
00315     PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\par
00316 \}\par
00317 \par
00318 {\cf20 //for SerialB}\par
00319 {\cf20 //#ifdef _FLASH}\par
00320 {\cf20 //#pragma CODE_SECTION(RXBINT_recv_ready, ".TI.ramfunc");}\par
00321 {\cf20 //#endif}\par
00322 {\cf20 //__interrupt void RXBINT_recv_ready(void)}\par
00323 {\cf20 //\{}\par
00324 {\cf20 //    serial_recv_ready(&SerialB);}\par
00325 {\cf20 //    ScibRegs.SCIFFRX.bit.RXFFINTCLR = 1;}\par
00326 {\cf20 //    PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
00327 {\cf20 //\}}\par
00328 \par
00329 {\cf20 //for SerialC}\par
00330 {\cf21 #ifdef _FLASH}\par
00331 {\cf21 #pragma CODE_SECTION(RXCINT_recv_ready, ".TI.ramfunc");}\par
00332 {\cf21 #endif}\par
00333 __interrupt {\cf18 void} RXCINT_recv_ready({\cf18 void})\par
00334 \{\par
00335     serial_recv_ready(&SerialC);\par
00336     {\cf20 //int_numcalls++;}\par
00337     ScicRegs.SCIFFRX.bit.RXFFINTCLR = 1;\par
00338     PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\par
00339 \}\par
00340 \par
00341 {\cf20 //for SerialD}\par
00342 {\cf21 #ifdef _FLASH}\par
00343 {\cf21 #pragma CODE_SECTION(RXDINT_recv_ready, ".TI.ramfunc");}\par
00344 {\cf21 #endif}\par
00345 __interrupt {\cf18 void} RXDINT_recv_ready({\cf18 void})\par
00346 \{\par
00347     serial_recv_ready(&SerialD);\par
00348     {\cf20 //int_numcalls++;}\par
00349     ScidRegs.SCIFFRX.bit.RXFFINTCLR = 1;\par
00350     PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\par
00351 \}\par
00352 \par
00353 {\cf20 /***************************************************************************}\par
00354 {\cf20  * SERIAL_PRINTF()}\par
00355 {\cf20  *}\par
00356 {\cf20  * Simple printf command to print out a serial port}\par
00357 {\cf20  ***************************************************************************/}\par
00358 uint16_t serial_printf(serial_t *s, {\cf18 char} *fmt, ...)\par
00359 \{\par
00360     va_list ap;\par
00361     {\cf18 char} buf[BUF_SIZE];\par
00362 \par
00363     va_start(ap,fmt);\par
00364     vsprintf(buf,fmt,ap);\par
00365     va_end(ap);\par
00366 \par
00367     {\cf19 return} serial_send(s,buf,strlen(buf));\par
00368 \}\par
00369 \par
00370 {\cf18 void} UART_vprintfLine({\cf18 unsigned} {\cf18 char} line, {\cf18 char} *format, va_list ap)\par
00371 \{\par
00372     {\cf18 char} sendmsg[24];\par
00373     {\cf18 char} buffer[120];\par
00374     {\cf18 int} i;\par
00375 \par
00376     vsprintf(buffer,format,ap);\par
00377 \par
00378     {\cf20 // Add header information and pad end of transfer with spaces to clear display}\par
00379     sendmsg[0] = 0xFE;\par
00380     sendmsg[1] = {\cf23 'G'};\par
00381     sendmsg[2] = 1;\par
00382     sendmsg[3] = line;\par
00383     {\cf19 for} (i=4;i<24;i++) \{\par
00384         {\cf19 if} (i >= strlen(buffer)+4) \{\par
00385             sendmsg[i] = {\cf23 ' '};\par
00386         \} {\cf19 else} \{\par
00387             sendmsg[i] = buffer[i-4];\par
00388         \}\par
00389     \}\par
00390     serial_send(&SerialC,sendmsg,24);\par
00391 \}\par
00392 \par
00393 {\cf18 void} UART_printfLine({\cf18 unsigned} {\cf18 char} line, {\cf18 char} *format, ...)\par
00394 \{\par
00395     va_list ap;\par
00396     va_start(ap, format);\par
00397     UART_vprintfLine(line,format,ap);\par
00398 \}\par
00399 \par
00400 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F28379dSerial.h File Reference\par \pard\plain 
{\tc\tcl2 \v F28379dSerial.h}
{\xe \v F28379dSerial.h}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <buffer.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b serial_s}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PLL_IMULT}\~ 0x28\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OSCCLK_KHZ}\~ 10000L\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSCLKOUT_KHZ}\~ ({\b OSCCLK_KHZ}*{\b PLL_IMULT}/((ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV == 0) ? 1 : (ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV*2)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LSPCLK_KHZ}\~ ({\b SYSCLKOUT_KHZ}/((ClkCfgRegs.LOSPCP.bit.LSPCLKDIV == 0) ? 1 : (ClkCfgRegs.LOSPCP.bit.LSPCLKDIV*2)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LSPCLK_HZ}\~ ({\b LSPCLK_KHZ}*1000L)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b serial_s} {\b serial_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b init_serial} ({\b serial_t} *s, Uint32 baud, void(*got_func)({\b serial_t} *s, char data))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b uninit_serial} ({\b serial_t} *s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b serial_send} ({\b serial_t} *s, char *data, Uint16 len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b serial_printf} ({\b serial_t} *s, char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UART_printfLine} (unsigned char line, char *format,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UART_vprintfLine} (unsigned char line, char *format, va_list ap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b TXAINT_data_sent} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b TXCINT_data_sent} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b TXDINT_data_sent} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b RXAINT_recv_ready} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b RXCINT_recv_ready} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b RXDINT_recv_ready} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serial_t} {\b SerialA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serial_t} {\b SerialC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serial_t} {\b SerialD}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LSPCLK_HZ\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:LSPCLK_HZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LSPCLK_HZ\~ ({\b LSPCLK_KHZ}*1000L)}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b F28379dSerial.h}.}\par
}
{\xe \v LSPCLK_KHZ\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:LSPCLK_KHZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LSPCLK_KHZ\~ ({\b SYSCLKOUT_KHZ}/((ClkCfgRegs.LOSPCP.bit.LSPCLKDIV == 0) ? 1 : (ClkCfgRegs.LOSPCP.bit.LSPCLKDIV*2)))}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b F28379dSerial.h}.}\par
}
{\xe \v OSCCLK_KHZ\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:OSCCLK_KHZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OSCCLK_KHZ\~ 10000L}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b F28379dSerial.h}.}\par
}
{\xe \v PLL_IMULT\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:PLL_IMULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PLL_IMULT\~ 0x28}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b F28379dSerial.h}.}\par
}
{\xe \v SYSCLKOUT_KHZ\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:SYSCLKOUT_KHZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSCLKOUT_KHZ\~ ({\b OSCCLK_KHZ}*{\b PLL_IMULT}/((ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV == 0) ? 1 : (ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV*2)))}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b F28379dSerial.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v serial_t\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:serial_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b serial_s} {\b serial_t}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_serial\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:init_serial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t init_serial ({\b serial_t} * s, Uint32 baud, void(* got_func\~ )({\b serial_t} *s, char data))}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RXAINT_recv_ready\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:RXAINT_recv_ready}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void RXAINT_recv_ready (void )}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 311} of file {\b F28379dSerial.c}.}\par
}
{\xe \v RXCINT_recv_ready\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:RXCINT_recv_ready}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void RXCINT_recv_ready (void )}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 333} of file {\b F28379dSerial.c}.}\par
}
{\xe \v RXDINT_recv_ready\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:RXDINT_recv_ready}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void RXDINT_recv_ready (void )}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 345} of file {\b F28379dSerial.c}.}\par
}
{\xe \v serial_printf\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:serial_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t serial_printf ({\b serial_t} * s, char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 358} of file {\b F28379dSerial.c}.}\par
}
{\xe \v serial_send\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:serial_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t serial_send ({\b serial_t} * s, char * data, Uint16 len)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TXAINT_data_sent\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:TXAINT_data_sent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void TXAINT_data_sent (void )}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 209} of file {\b F28379dSerial.c}.}\par
}
{\xe \v TXCINT_data_sent\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:TXCINT_data_sent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void TXCINT_data_sent (void )}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 251} of file {\b F28379dSerial.c}.}\par
}
{\xe \v TXDINT_data_sent\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:TXDINT_data_sent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void TXDINT_data_sent (void )}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 271} of file {\b F28379dSerial.c}.}\par
}
{\xe \v UART_printfLine\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:UART_printfLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UART_printfLine (unsigned char line, char * format,  ...)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 393} of file {\b F28379dSerial.c}.}\par
}
{\xe \v UART_vprintfLine\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:UART_vprintfLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UART_vprintfLine (unsigned char line, char * format, va_list ap)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 370} of file {\b F28379dSerial.c}.}\par
}
{\xe \v uninit_serial\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:uninit_serial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void uninit_serial ({\b serial_t} * s)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b F28379dSerial.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SerialA\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:SerialA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b serial_t} SerialA{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b F28379dSerial.c}.}\par
}
{\xe \v SerialC\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:SerialC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b serial_t} SerialC{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b F28379dSerial.c}.}\par
}
{\xe \v SerialD\:F28379dSerial.h}
{\xe \v F28379dSerial.h\:SerialD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b serial_t} SerialD{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b F28379dSerial.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F28379dSerial.h\par \pard\plain 
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef F28379DSERIAL_H_}\par
00002 {\cf21 #define F28379DSERIAL_H_}\par
00003 {\cf21 #include <buffer.h>}\par
00004 \par
00005 \par
00006 {\cf21 #define PLL_IMULT           0x28        }{\cf20 //40}\par
00007 {\cf21 #define OSCCLK_KHZ          10000L  }{\cf20 //10 MHz}\par
00008 {\cf21 #define SYSCLKOUT_KHZ   (OSCCLK_KHZ*PLL_IMULT/((ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV == 0) ? 1 : (ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV*2)))}\par
00009 {\cf20 //LSPCLKDIV shouldn't be changed, so then should still be default /4}\par
00010 {\cf20 //so 200Mhz/4 = 50Mhz}\par
00011 {\cf21 #define LSPCLK_KHZ (SYSCLKOUT_KHZ/((ClkCfgRegs.LOSPCP.bit.LSPCLKDIV == 0) ? 1 : (ClkCfgRegs.LOSPCP.bit.LSPCLKDIV*2)))}\par
00012 \par
00013 {\cf21 #define LSPCLK_HZ       (LSPCLK_KHZ*1000L)}\par
00014 \par
00015 {\cf17 typedef} {\cf17 struct }serial_s \{\par
00016     {\cf17 volatile} {\cf17 struct }buffer_s TX;\par
00017     {\cf20 //volatile buffer_t TX;}\par
00018     {\cf17 volatile} {\cf17 struct }SCI_REGS *sci;\par
00019     void (*got_data)({\cf17 struct }serial_s *s, {\cf18 char} data);\par
00020 \} serial_t;\par
00021 \par
00022 \par
00023 {\cf17 extern} serial_t SerialA;\par
00024 {\cf20 //extern serial_t SerialB;}\par
00025 {\cf17 extern} serial_t SerialC;\par
00026 {\cf17 extern} serial_t SerialD;\par
00027 \par
00028 uint16_t init_serial(serial_t *s, Uint32 baud, {\cf18 void} (*got_func)(serial_t *s, {\cf18 char} data));\par
00029 {\cf18 void} uninit_serial(serial_t *s);\par
00030 uint16_t serial_send(serial_t *s, {\cf18 char} *data, Uint16 len);\par
00031 uint16_t serial_printf(serial_t *s, {\cf18 char} *fmt, ...);\par
00032 {\cf18 void} UART_printfLine({\cf18 unsigned} {\cf18 char} line, {\cf18 char} *format, ...);\par
00033 {\cf18 void} UART_vprintfLine({\cf18 unsigned} {\cf18 char} line, {\cf18 char} *format, va_list ap);\par
00034 __interrupt {\cf18 void} TXAINT_data_sent({\cf18 void});\par
00035 {\cf20 //__interrupt void TXBINT_data_sent(void);}\par
00036 __interrupt {\cf18 void} TXCINT_data_sent({\cf18 void});\par
00037 __interrupt {\cf18 void} TXDINT_data_sent({\cf18 void});\par
00038 __interrupt {\cf18 void} RXAINT_recv_ready({\cf18 void});\par
00039 {\cf20 //__interrupt void RXBINT_recv_ready(void);}\par
00040 __interrupt {\cf18 void} RXCINT_recv_ready({\cf18 void});\par
00041 __interrupt {\cf18 void} RXDINT_recv_ready({\cf18 void});\par
00042 \par
00043 {\cf21 #endif }{\cf20 /* F28379DSERIAL_H_ */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_Adc.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_Adc.c}
{\xe \v F2837xD_Adc.c}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AdcSetMode} (Uint16 adc, Uint16 resolution, Uint16 signalmode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalAdcINL} (Uint16 adc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v AdcSetMode\:F2837xD_Adc.c}
{\xe \v F2837xD_Adc.c\:AdcSetMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AdcSetMode (Uint16 adc, Uint16 resolution, Uint16 signalmode)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b F2837xD_Adc.c}.}\par
}
{\xe \v CalAdcINL\:F2837xD_Adc.c}
{\xe \v F2837xD_Adc.c\:CalAdcINL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CalAdcINL (Uint16 adc)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b F2837xD_Adc.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_Adc.c\par \pard\plain 
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:   F2837xD_Adc.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:  F2837xD Adc Support Functions.}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}\par
00047 {\cf21 #include "F2837xD_Examples.h"}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // AdcSetMode - Set the resolution and signalmode for a given ADC. This will}\par
00051 {\cf20 //              ensure that the correct trim is loaded.}\par
00052 {\cf20 //}\par
00053 {\cf20 // NOTE!!! There is no EALLOW/EDIS in this function! You need to make sure you}\par
00054 {\cf20 // perform the EALLOW before calling this function or else the ADC registers}\par
00055 {\cf20 // will not be configured.}\par
00056 {\cf20 //}\par
00057 {\cf18 void} AdcSetMode(Uint16 adc, Uint16 resolution, Uint16 signalmode)\par
00058 \{\par
00059     Uint16 adcOffsetTrimOTPIndex; {\cf20 //index into OTP table of ADC offset trims}\par
00060     Uint16 adcOffsetTrim;         {\cf20 //temporary ADC offset trim}\par
00061 \par
00062     {\cf20 //}\par
00063     {\cf20 //re-populate INL trim}\par
00064     {\cf20 //}\par
00065     CalAdcINL(adc);\par
00066 \par
00067     {\cf19 if}(0xFFFF != *((Uint16*)GetAdcOffsetTrimOTP))\par
00068     \{\par
00069         {\cf20 //}\par
00070         {\cf20 //offset trim function is programmed into OTP, so call it}\par
00071         {\cf20 //}\par
00072 \par
00073         {\cf20 //}\par
00074         {\cf20 //calculate the index into OTP table of offset trims and call}\par
00075         {\cf20 //function to return the correct offset trim}\par
00076         {\cf20 //}\par
00077 {\cf21 #ifndef _DUAL_HEADERS}\par
00078         {\cf19 if}(ADC_RESOLUTION_12BIT == resolution)\par
00079 {\cf21 #else}\par
00080         {\cf19 if}(ADC_BITRESOLUTION_12BIT == resolution)\par
00081 {\cf21 #endif}\par
00082         \{\par
00083             adcOffsetTrimOTPIndex = 4*adc + 1*signalmode;\par
00084         \}\par
00085         {\cf19 else}\par
00086         \{\par
00087             adcOffsetTrimOTPIndex = 4*adc + 1*signalmode + 2;\par
00088         \}\par
00089 \par
00090         adcOffsetTrim = (*GetAdcOffsetTrimOTP)(adcOffsetTrimOTPIndex);\par
00091     \}\par
00092     {\cf19 else}\par
00093     \{\par
00094         {\cf20 //}\par
00095         {\cf20 //offset trim function is not populated, so set offset trim to 0}\par
00096         {\cf20 //}\par
00097         adcOffsetTrim = 0;\par
00098     \}\par
00099 \par
00100     {\cf20 //}\par
00101     {\cf20 // Apply the resolution and signalmode to the specified ADC.}\par
00102     {\cf20 // Also apply the offset trim and, if needed, linearity trim correction.}\par
00103     {\cf20 //}\par
00104     {\cf19 switch}(adc)\par
00105     \{\par
00106         {\cf19 case} ADC_ADCA:\par
00107         \{\par
00108             AdcaRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\par
00109             {\cf19 if}(adcOffsetTrim > 0x0)\par
00110             \{\par
00111                 AdcaRegs.ADCOFFTRIM.all = adcOffsetTrim;\par
00112             \}\par
00113 {\cf21 #ifndef _DUAL_HEADERS}\par
00114             {\cf19 if}(ADC_RESOLUTION_12BIT == resolution)\par
00115 {\cf21 #else}\par
00116             {\cf19 if}(ADC_BITRESOLUTION_12BIT == resolution)\par
00117 {\cf21 #endif}\par
00118             \{\par
00119                 AdcaRegs.ADCCTL2.bit.RESOLUTION = 0;\par
00120 \par
00121                 {\cf20 //}\par
00122                 {\cf20 //12-bit linearity trim workaround}\par
00123                 {\cf20 //}\par
00124                 AdcaRegs.ADCINLTRIM1 &= 0xFFFF0000;\par
00125                 AdcaRegs.ADCINLTRIM2 &= 0xFFFF0000;\par
00126                 AdcaRegs.ADCINLTRIM4 &= 0xFFFF0000;\par
00127                 AdcaRegs.ADCINLTRIM5 &= 0xFFFF0000;\par
00128             \}\par
00129             {\cf19 else}\par
00130             \{\par
00131                 AdcaRegs.ADCCTL2.bit.RESOLUTION = 1;\par
00132             \}\par
00133             {\cf19 break};\par
00134         \}\par
00135         {\cf19 case} ADC_ADCB:\par
00136         \{\par
00137             AdcbRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\par
00138             {\cf19 if}(adcOffsetTrim > 0x0)\par
00139             \{\par
00140                 AdcbRegs.ADCOFFTRIM.all = adcOffsetTrim;\par
00141             \}\par
00142 {\cf21 #ifndef _DUAL_HEADERS}\par
00143             {\cf19 if}(ADC_RESOLUTION_12BIT == resolution)\par
00144 {\cf21 #else}\par
00145             {\cf19 if}(ADC_BITRESOLUTION_12BIT == resolution)\par
00146 {\cf21 #endif}\par
00147             \{\par
00148                 AdcbRegs.ADCCTL2.bit.RESOLUTION = 0;\par
00149 \par
00150                 {\cf20 //}\par
00151                 {\cf20 //12-bit linearity trim workaround}\par
00152                 {\cf20 //}\par
00153                 AdcbRegs.ADCINLTRIM1 &= 0xFFFF0000;\par
00154                 AdcbRegs.ADCINLTRIM2 &= 0xFFFF0000;\par
00155                 AdcbRegs.ADCINLTRIM4 &= 0xFFFF0000;\par
00156                 AdcbRegs.ADCINLTRIM5 &= 0xFFFF0000;\par
00157             \}\par
00158             {\cf19 else}\par
00159             \{\par
00160                 AdcbRegs.ADCCTL2.bit.RESOLUTION = 1;\par
00161             \}\par
00162             {\cf19 break};\par
00163         \}\par
00164         {\cf19 case} ADC_ADCC:\par
00165         \{\par
00166             AdccRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\par
00167             {\cf19 if}(adcOffsetTrim > 0x0)\par
00168             \{\par
00169                 AdccRegs.ADCOFFTRIM.all = adcOffsetTrim;\par
00170             \}\par
00171 {\cf21 #ifndef _DUAL_HEADERS}\par
00172             {\cf19 if}(ADC_RESOLUTION_12BIT == resolution)\par
00173 {\cf21 #else}\par
00174             {\cf19 if}(ADC_BITRESOLUTION_12BIT == resolution)\par
00175 {\cf21 #endif}\par
00176             \{\par
00177                 AdccRegs.ADCCTL2.bit.RESOLUTION = 0;\par
00178                 {\cf20 //}\par
00179                 {\cf20 //12-bit linearity trim workaround}\par
00180                 {\cf20 //}\par
00181                 AdccRegs.ADCINLTRIM1 &= 0xFFFF0000;\par
00182                 AdccRegs.ADCINLTRIM2 &= 0xFFFF0000;\par
00183                 AdccRegs.ADCINLTRIM4 &= 0xFFFF0000;\par
00184                 AdccRegs.ADCINLTRIM5 &= 0xFFFF0000;\par
00185             \}\par
00186             {\cf19 else}\par
00187             \{\par
00188                 AdccRegs.ADCCTL2.bit.RESOLUTION = 1;\par
00189             \}\par
00190             {\cf19 break};\par
00191         \}\par
00192         {\cf19 case} ADC_ADCD:\par
00193         \{\par
00194             AdcdRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\par
00195             {\cf19 if}(adcOffsetTrim > 0x0)\par
00196             \{\par
00197                 AdcdRegs.ADCOFFTRIM.all = adcOffsetTrim;\par
00198             \}\par
00199 {\cf21 #ifndef _DUAL_HEADERS}\par
00200             {\cf19 if}(ADC_RESOLUTION_12BIT == resolution)\par
00201 {\cf21 #else}\par
00202             {\cf19 if}(ADC_BITRESOLUTION_12BIT == resolution)\par
00203 {\cf21 #endif}\par
00204             \{\par
00205                 AdcdRegs.ADCCTL2.bit.RESOLUTION = 0;\par
00206 \par
00207                 {\cf20 //}\par
00208                 {\cf20 //12-bit linearity trim workaround}\par
00209                 {\cf20 //}\par
00210                 AdcdRegs.ADCINLTRIM1 &= 0xFFFF0000;\par
00211                 AdcdRegs.ADCINLTRIM2 &= 0xFFFF0000;\par
00212                 AdcdRegs.ADCINLTRIM4 &= 0xFFFF0000;\par
00213                 AdcdRegs.ADCINLTRIM5 &= 0xFFFF0000;\par
00214             \}\par
00215             {\cf19 else}\par
00216             \{\par
00217                 AdcdRegs.ADCCTL2.bit.RESOLUTION = 1;\par
00218             \}\par
00219             {\cf19 break};\par
00220         \}\par
00221     \}\par
00222 \}\par
00223 \par
00224 {\cf20 //}\par
00225 {\cf20 // CalAdcINL - Loads INL trim values from OTP into the trim registers of the}\par
00226 {\cf20 //             specified ADC. Use only as part of AdcSetMode function, since}\par
00227 {\cf20 //             linearity trim correction is needed for some modes.}\par
00228 {\cf20 //}\par
00229 {\cf18 void} CalAdcINL(Uint16 adc)\par
00230 \{\par
00231     {\cf19 switch}(adc)\par
00232     \{\par
00233         {\cf19 case} ADC_ADCA:\par
00234             {\cf19 if}(0xFFFF != *((Uint16*)CalAdcaINL))\par
00235             \{\par
00236                 {\cf20 //}\par
00237                 {\cf20 //trim function is programmed into OTP, so call it}\par
00238                 {\cf20 //}\par
00239                 (*CalAdcaINL)();\par
00240             \}\par
00241             {\cf19 else}\par
00242             \{\par
00243                 {\cf20 //}\par
00244                 {\cf20 //do nothing, no INL trim function populated}\par
00245                 {\cf20 //}\par
00246             \}\par
00247             {\cf19 break};\par
00248         {\cf19 case} ADC_ADCB:\par
00249             {\cf19 if}(0xFFFF != *((Uint16*)CalAdcbINL))\par
00250             \{\par
00251                 {\cf20 //}\par
00252                 {\cf20 //trim function is programmed into OTP, so call it}\par
00253                 {\cf20 //}\par
00254                 (*CalAdcbINL)();\par
00255             \}\par
00256             {\cf19 else}\par
00257             \{\par
00258                 {\cf20 //}\par
00259                 {\cf20 //do nothing, no INL trim function populated}\par
00260                 {\cf20 //}\par
00261             \}\par
00262             {\cf19 break};\par
00263         {\cf19 case} ADC_ADCC:\par
00264             {\cf19 if}(0xFFFF != *((Uint16*)CalAdccINL))\par
00265             \{\par
00266                 {\cf20 //}\par
00267                 {\cf20 //trim function is programmed into OTP, so call it}\par
00268                 {\cf20 //}\par
00269                 (*CalAdccINL)();\par
00270             \}\par
00271             {\cf19 else}\par
00272             \{\par
00273                 {\cf20 //}\par
00274                 {\cf20 //do nothing, no INL trim function populated}\par
00275                 {\cf20 //}\par
00276             \}\par
00277             {\cf19 break};\par
00278         {\cf19 case} ADC_ADCD:\par
00279             {\cf19 if}(0xFFFF != *((Uint16*)CalAdcdINL))\par
00280             \{\par
00281                 {\cf20 //}\par
00282                 {\cf20 //trim function is programmed into OTP, so call it}\par
00283                 {\cf20 //}\par
00284                 (*CalAdcdINL)();\par
00285             \}\par
00286             {\cf19 else}\par
00287             \{\par
00288                 {\cf20 //}\par
00289                 {\cf20 //do nothing, no INL trim function populated}\par
00290                 {\cf20 //}\par
00291             \}\par
00292             {\cf19 break};\par
00293     \}\par
00294 \}\par
00295 \par
00296 {\cf20 //}\par
00297 {\cf20 // End of file}\par
00298 {\cf20 //}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_CpuTimers.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_CpuTimers.c}
{\xe \v F2837xD_CpuTimers.c}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitCpuTimers} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConfigCpuTimer} (struct CPUTIMER_VARS *Timer, float Freq, float Period)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct CPUTIMER_VARS {\b CpuTimer0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct CPUTIMER_VARS {\b CpuTimer1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct CPUTIMER_VARS {\b CpuTimer2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ConfigCpuTimer\:F2837xD_CpuTimers.c}
{\xe \v F2837xD_CpuTimers.c\:ConfigCpuTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConfigCpuTimer (struct CPUTIMER_VARS * Timer, float Freq, float Period)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b F2837xD_CpuTimers.c}.}\par
}
{\xe \v InitCpuTimers\:F2837xD_CpuTimers.c}
{\xe \v F2837xD_CpuTimers.c\:InitCpuTimers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitCpuTimers (void )}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b F2837xD_CpuTimers.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v CpuTimer0\:F2837xD_CpuTimers.c}
{\xe \v F2837xD_CpuTimers.c\:CpuTimer0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct CPUTIMER_VARS CpuTimer0}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b F2837xD_CpuTimers.c}.}\par
}
{\xe \v CpuTimer1\:F2837xD_CpuTimers.c}
{\xe \v F2837xD_CpuTimers.c\:CpuTimer1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct CPUTIMER_VARS CpuTimer1}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b F2837xD_CpuTimers.c}.}\par
}
{\xe \v CpuTimer2\:F2837xD_CpuTimers.c}
{\xe \v F2837xD_CpuTimers.c\:CpuTimer2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct CPUTIMER_VARS CpuTimer2}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b F2837xD_CpuTimers.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_CpuTimers.c\par \pard\plain 
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:    F2837xD_CpuTimers.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:   CPU 32-bit Timers Initialization & Support Functions.}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}\par
00047 {\cf21 #include "F2837xD_Examples.h"}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // Globals}\par
00051 {\cf20 //}\par
00052 {\cf17 struct }CPUTIMER_VARS CpuTimer0;\par
00053 {\cf17 struct }CPUTIMER_VARS CpuTimer1;\par
00054 {\cf17 struct }CPUTIMER_VARS CpuTimer2;\par
00055 \par
00056 {\cf20 //}\par
00057 {\cf20 // InitCpuTimers - This function initializes all three CPU timers to a known}\par
00058 {\cf20 //                 state.}\par
00059 {\cf20 //}\par
00060 {\cf18 void} InitCpuTimers({\cf18 void})\par
00061 \{\par
00062     {\cf20 //}\par
00063     {\cf20 // CPU Timer 0}\par
00064     {\cf20 // Initialize address pointers to respective timer registers:}\par
00065     {\cf20 //}\par
00066     CpuTimer0.RegsAddr = &CpuTimer0Regs;\par
00067 \par
00068     {\cf20 //}\par
00069     {\cf20 // Initialize timer period to maximum:}\par
00070     {\cf20 //}\par
00071     CpuTimer0Regs.PRD.all  = 0xFFFFFFFF;\par
00072 \par
00073     {\cf20 //}\par
00074     {\cf20 // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):}\par
00075     {\cf20 //}\par
00076     CpuTimer0Regs.TPR.all  = 0;\par
00077     CpuTimer0Regs.TPRH.all = 0;\par
00078 \par
00079     {\cf20 //}\par
00080     {\cf20 // Make sure timer is stopped:}\par
00081     {\cf20 //}\par
00082     CpuTimer0Regs.TCR.bit.TSS = 1;\par
00083 \par
00084     {\cf20 //}\par
00085     {\cf20 // Reload all counter register with period value:}\par
00086     {\cf20 //}\par
00087     CpuTimer0Regs.TCR.bit.TRB = 1;\par
00088 \par
00089     {\cf20 //}\par
00090     {\cf20 // Reset interrupt counters:}\par
00091     {\cf20 //}\par
00092     CpuTimer0.InterruptCount = 0;\par
00093 \par
00094     {\cf20 //}\par
00095     {\cf20 // Initialize address pointers to respective timer registers:}\par
00096     {\cf20 //}\par
00097     CpuTimer1.RegsAddr = &CpuTimer1Regs;\par
00098     CpuTimer2.RegsAddr = &CpuTimer2Regs;\par
00099 \par
00100     {\cf20 //}\par
00101     {\cf20 // Initialize timer period to maximum:}\par
00102     {\cf20 //}\par
00103     CpuTimer1Regs.PRD.all  = 0xFFFFFFFF;\par
00104     CpuTimer2Regs.PRD.all  = 0xFFFFFFFF;\par
00105 \par
00106     {\cf20 //}\par
00107     {\cf20 // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):}\par
00108     {\cf20 //}\par
00109     CpuTimer1Regs.TPR.all  = 0;\par
00110     CpuTimer1Regs.TPRH.all = 0;\par
00111     CpuTimer2Regs.TPR.all  = 0;\par
00112     CpuTimer2Regs.TPRH.all = 0;\par
00113 \par
00114     {\cf20 //}\par
00115     {\cf20 // Make sure timers are stopped:}\par
00116     {\cf20 //}\par
00117     CpuTimer1Regs.TCR.bit.TSS = 1;\par
00118     CpuTimer2Regs.TCR.bit.TSS = 1;\par
00119 \par
00120     {\cf20 //}\par
00121     {\cf20 // Reload all counter register with period value:}\par
00122     {\cf20 //}\par
00123     CpuTimer1Regs.TCR.bit.TRB = 1;\par
00124     CpuTimer2Regs.TCR.bit.TRB = 1;\par
00125 \par
00126     {\cf20 //}\par
00127     {\cf20 // Reset interrupt counters:}\par
00128     {\cf20 //}\par
00129     CpuTimer1.InterruptCount = 0;\par
00130     CpuTimer2.InterruptCount = 0;\par
00131 \}\par
00132 \par
00133 {\cf20 //}\par
00134 {\cf20 // ConfigCpuTimer - This function initializes the selected timer to the period}\par
00135 {\cf20 //                  specified by the "Freq" and "Period" parameters. The "Freq"}\par
00136 {\cf20 //                  is entered as "MHz" and the period in "uSeconds". The timer}\par
00137 {\cf20 //                  is held in the stopped state after configuration.}\par
00138 {\cf20 //}\par
00139 {\cf18 void} ConfigCpuTimer({\cf17 struct} CPUTIMER_VARS *Timer, {\cf18 float} Freq, {\cf18 float} Period)\par
00140 \{\par
00141     Uint32 temp;\par
00142 \par
00143     {\cf20 //}\par
00144     {\cf20 // Initialize timer period:}\par
00145     {\cf20 //}\par
00146     Timer->CPUFreqInMHz = Freq;\par
00147     Timer->PeriodInUSec = Period;\par
00148     temp = (long) (Freq * Period);\par
00149 \par
00150     {\cf20 //}\par
00151     {\cf20 // Counter decrements PRD+1 times each period}\par
00152     {\cf20 //}\par
00153     Timer->RegsAddr->PRD.all = temp - 1;\par
00154 \par
00155     {\cf20 //}\par
00156     {\cf20 // Set pre-scale counter to divide by 1 (SYSCLKOUT):}\par
00157     {\cf20 //}\par
00158     Timer->RegsAddr->TPR.all  = 0;\par
00159     Timer->RegsAddr->TPRH.all  = 0;\par
00160 \par
00161     {\cf20 //}\par
00162     {\cf20 // Initialize timer control register:}\par
00163     {\cf20 //}\par
00164     Timer->RegsAddr->TCR.bit.TSS = 1;     {\cf20 // 1 = Stop timer, 0 = Start/Restart}\par
00165                                           {\cf20 // Timer}\par
00166     Timer->RegsAddr->TCR.bit.TRB = 1;     {\cf20 // 1 = reload timer}\par
00167     Timer->RegsAddr->TCR.bit.SOFT = 0;\par
00168     Timer->RegsAddr->TCR.bit.FREE = 0;    {\cf20 // Timer Free Run Disabled}\par
00169     Timer->RegsAddr->TCR.bit.TIE = 1;     {\cf20 // 0 = Disable/ 1 = Enable Timer}\par
00170                                           {\cf20 // Interrupt}\par
00171 \par
00172     {\cf20 //}\par
00173     {\cf20 // Reset interrupt counter:}\par
00174     {\cf20 //}\par
00175     Timer->InterruptCount = 0;\par
00176 \}\par
00177 \par
00178 \par
00179 {\cf20 //}\par
00180 {\cf20 // End of file}\par
00181 {\cf20 //}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_DefaultISR.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b TIMER1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b TIMER2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b DATALOG_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b RTOS_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EMU_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b NMI_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ILLEGAL_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER5_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER6_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER7_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER8_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER9_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER10_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER11_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USER12_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCA1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCB1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCC1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b XINT1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b XINT2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCD1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b TIMER0_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b WAKE_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM1_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM2_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM3_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM4_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM5_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM6_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM7_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM8_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM5_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM6_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM7_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM8_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ECAP1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ECAP2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ECAP3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ECAP4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ECAP5_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ECAP6_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EQEP1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EQEP2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EQEP3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SPIA_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SPIA_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SPIB_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SPIB_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b MCBSPA_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b MCBSPA_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b MCBSPB_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b MCBSPB_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b DMA_CH1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b DMA_CH2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b DMA_CH3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b DMA_CH4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b DMA_CH5_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b DMA_CH6_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b I2CA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b I2CA_FIFO_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b I2CB_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b I2CB_FIFO_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCIC_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCIC_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCID_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCID_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCIA_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCIA_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCIB_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SCIB_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CANA0_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CANA1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CANB0_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CANB1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCA_EVT_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCA2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCA3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCA4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCB_EVT_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCB2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCB3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCB4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_5_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_6_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_7_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA1_8_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b XINT3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b XINT4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b XINT5_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b VCU_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b FPU_OVERFLOW_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b FPU_UNDERFLOW_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b IPC0_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b IPC1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b IPC2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b IPC3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM9_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM10_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM11_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM12_TZ_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM9_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM10_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM11_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EPWM12_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SD1_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SD2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SPIC_RX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SPIC_TX_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b UPPA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b USBA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCC_EVT_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCC2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCC3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCC4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCD_EVT_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCD2_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCD3_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b ADCD4_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EMIF_ERROR_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b RAM_CORRECTABLE_ERROR_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b FLASH_CORRECTABLE_ERROR_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b RAM_ACCESS_VIOLATION_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b SYS_PLL_SLIP_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b AUX_PLL_SLIP_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA_OVERFLOW_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b CLA_UNDERFLOW_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b PIE_RESERVED_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b EMPTY_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
interrupt void {\b NOTUSED_ISR} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ADCA1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCA1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCA1_ISR (void )}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 375} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCA2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCA2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCA2_ISR (void )}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1847} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCA3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCA3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCA3_ISR (void )}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1870} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCA4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCA4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCA4_ISR (void )}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1893} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCA_EVT_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCA_EVT_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCA_EVT_ISR (void )}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1824} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCB1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCB1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCB1_ISR (void )}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCB2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCB2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCB2_ISR (void )}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1939} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCB3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCB3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCB3_ISR (void )}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1962} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCB4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCB4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCB4_ISR (void )}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1985} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCB_EVT_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCB_EVT_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCB_EVT_ISR (void )}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1916} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCC1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCC1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCC1_ISR (void )}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 421} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCC2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCC2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCC2_ISR (void )}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2767} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCC3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCC3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCC3_ISR (void )}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2790} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCC4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCC4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCC4_ISR (void )}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2813} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCC_EVT_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCC_EVT_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCC_EVT_ISR (void )}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2744} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCD1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCD1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCD1_ISR (void )}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 490} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCD2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCD2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCD2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2859} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCD3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCD3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCD3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2882} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCD4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCD4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCD4_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2905} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ADCD_EVT_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ADCD_EVT_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ADCD_EVT_ISR (void )}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2836} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v AUX_PLL_SLIP_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:AUX_PLL_SLIP_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void AUX_PLL_SLIP_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3043} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CANA0_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CANA0_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CANA0_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1732} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CANA1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CANA1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CANA1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1755} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CANB0_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CANB0_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CANB0_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1778} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CANB1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CANB1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CANB1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1801} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2008} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2031} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2054} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_4_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2077} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_5_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_5_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_5_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2100} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_6_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_6_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_6_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2123} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_7_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_7_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_7_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2146} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA1_8_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA1_8_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA1_8_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2169} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA_OVERFLOW_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA_OVERFLOW_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA_OVERFLOW_ISR (void )}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3066} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v CLA_UNDERFLOW_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:CLA_UNDERFLOW_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void CLA_UNDERFLOW_ISR (void )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3089} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v DATALOG_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:DATALOG_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void DATALOG_ISR (void )}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v DMA_CH1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:DMA_CH1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void DMA_CH1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1318} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v DMA_CH2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:DMA_CH2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void DMA_CH2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1341} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v DMA_CH3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:DMA_CH3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void DMA_CH3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1364} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v DMA_CH4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:DMA_CH4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void DMA_CH4_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1387} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v DMA_CH5_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:DMA_CH5_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void DMA_CH5_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1410} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v DMA_CH6_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:DMA_CH6_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void DMA_CH6_ISR (void )}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1433} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ECAP1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ECAP1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ECAP1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 927} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ECAP2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ECAP2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ECAP2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 950} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ECAP3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ECAP3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ECAP3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 973} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ECAP4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ECAP4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ECAP4_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 996} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ECAP5_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ECAP5_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ECAP5_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1019} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ECAP6_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ECAP6_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ECAP6_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1042} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EMIF_ERROR_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EMIF_ERROR_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EMIF_ERROR_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2928} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EMPTY_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EMPTY_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EMPTY_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3125} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EMU_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EMU_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EMU_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM10_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM10_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM10_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2537} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM10_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM10_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM10_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2445} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM11_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM11_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM11_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2560} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM11_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM11_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM11_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2468} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM12_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM12_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM12_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2583} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM12_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM12_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM12_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2491} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 743} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM1_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM1_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM1_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 559} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 766} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM2_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM2_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM2_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 582} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 789} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM3_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM3_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM3_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 605} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM4_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 812} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM4_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM4_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM4_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 628} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM5_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM5_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM5_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 835} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM5_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM5_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM5_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 651} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM6_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM6_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM6_ISR (void )}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 858} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM6_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM6_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM6_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 674} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM7_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM7_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM7_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 881} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM7_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM7_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM7_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 697} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM8_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM8_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM8_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 904} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM8_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM8_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM8_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 720} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM9_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM9_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM9_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2514} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EPWM9_TZ_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EPWM9_TZ_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EPWM9_TZ_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2422} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EQEP1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EQEP1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EQEP1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1065} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EQEP2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EQEP2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EQEP2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1088} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v EQEP3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:EQEP3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void EQEP3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1111} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v FLASH_CORRECTABLE_ERROR_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:FLASH_CORRECTABLE_ERROR_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void FLASH_CORRECTABLE_ERROR_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2974} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v FPU_OVERFLOW_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:FPU_OVERFLOW_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void FPU_OVERFLOW_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2284} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v FPU_UNDERFLOW_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:FPU_UNDERFLOW_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void FPU_UNDERFLOW_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2307} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v I2CA_FIFO_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:I2CA_FIFO_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void I2CA_FIFO_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1479} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v I2CA_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:I2CA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void I2CA_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1456} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v I2CB_FIFO_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:I2CB_FIFO_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void I2CB_FIFO_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1525} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v I2CB_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:I2CB_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void I2CB_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1502} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v ILLEGAL_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:ILLEGAL_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void ILLEGAL_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v IPC0_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:IPC0_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void IPC0_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2330} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v IPC1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:IPC1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void IPC1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2353} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v IPC2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:IPC2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void IPC2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2376} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v IPC3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:IPC3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void IPC3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2399} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v MCBSPA_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:MCBSPA_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void MCBSPA_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1226} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v MCBSPA_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:MCBSPA_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void MCBSPA_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1249} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v MCBSPB_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:MCBSPB_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void MCBSPB_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1272} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v MCBSPB_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:MCBSPB_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void MCBSPB_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1295} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v NMI_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:NMI_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void NMI_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v NOTUSED_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:NOTUSED_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void NOTUSED_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3133} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v PIE_RESERVED_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:PIE_RESERVED_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void PIE_RESERVED_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3116} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v RAM_ACCESS_VIOLATION_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:RAM_ACCESS_VIOLATION_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void RAM_ACCESS_VIOLATION_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2997} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v RAM_CORRECTABLE_ERROR_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:RAM_CORRECTABLE_ERROR_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void RAM_CORRECTABLE_ERROR_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2951} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v RTOS_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:RTOS_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void RTOS_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCIA_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCIA_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCIA_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1640} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCIA_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCIA_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCIA_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1663} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCIB_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCIB_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCIB_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1686} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCIB_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCIB_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCIB_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1709} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCIC_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCIC_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCIC_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1548} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCIC_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCIC_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCIC_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1571} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCID_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCID_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCID_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1594} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SCID_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SCID_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SCID_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1617} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SD1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SD1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SD1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2606} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SD2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SD2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SD2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2629} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SPIA_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SPIA_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SPIA_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1134} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SPIA_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SPIA_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SPIA_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1157} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SPIB_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SPIB_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SPIB_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1180} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SPIB_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SPIB_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SPIB_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1203} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SPIC_RX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SPIC_RX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SPIC_RX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2652} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SPIC_TX_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SPIC_TX_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SPIC_TX_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2675} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v SYS_PLL_SLIP_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:SYS_PLL_SLIP_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void SYS_PLL_SLIP_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3020} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v TIMER0_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:TIMER0_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void TIMER0_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v TIMER1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:TIMER1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void TIMER1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v TIMER2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:TIMER2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void TIMER2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v UPPA_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:UPPA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void UPPA_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2698} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USBA_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USBA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USBA_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2721} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER10_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER10_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER10_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 324} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER11_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER11_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER11_ISR (void )}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 341} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER12_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER12_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER12_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 358} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER4_ISR (void )}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 222} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER5_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER5_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER5_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER6_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER6_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER6_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 256} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER7_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER7_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER7_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 273} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER8_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER8_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER8_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 290} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v USER9_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:USER9_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void USER9_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v VCU_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:VCU_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void VCU_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2261} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v WAKE_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:WAKE_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void WAKE_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 536} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v XINT1_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:XINT1_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void XINT1_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 444} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v XINT2_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:XINT2_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void XINT2_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 467} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v XINT3_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:XINT3_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void XINT3_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2192} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v XINT4_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:XINT4_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void XINT4_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2215} of file {\b F2837xD_DefaultISR.c}.}\par
}
{\xe \v XINT5_ISR\:F2837xD_DefaultISR.c}
{\xe \v F2837xD_DefaultISR.c\:XINT5_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
interrupt void XINT5_ISR (void )}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2238} of file {\b F2837xD_DefaultISR.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_DefaultISR.c\par \pard\plain 
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:   F2837xD_DefaultISR.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:  F2837xD Device Default Interrupt Service Routines}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}\par
00047 {\cf21 #include "F2837xD_Examples.h"}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // CPU Timer 1 Interrupt}\par
00051 {\cf20 //}\par
00052 interrupt {\cf18 void} TIMER1_ISR({\cf18 void})\par
00053 \{\par
00054     {\cf20 //}\par
00055     {\cf20 // Insert ISR Code here}\par
00056     {\cf20 //}\par
00057 \par
00058     {\cf20 //}\par
00059     {\cf20 // Next two lines for debug only to halt the processor here}\par
00060     {\cf20 // Remove after inserting ISR Code}\par
00061     {\cf20 //}\par
00062     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00063     {\cf19 for}(;;);\par
00064 \}\par
00065 \par
00066 {\cf20 //}\par
00067 {\cf20 // CPU Timer 2 Interrupt}\par
00068 {\cf20 //}\par
00069 interrupt {\cf18 void} TIMER2_ISR({\cf18 void})\par
00070 \{\par
00071     {\cf20 //}\par
00072     {\cf20 // Insert ISR Code here}\par
00073     {\cf20 //}\par
00074 \par
00075     {\cf20 //}\par
00076     {\cf20 // Next two lines for debug only to halt the processor here}\par
00077     {\cf20 // Remove after inserting ISR Code}\par
00078     {\cf20 //}\par
00079     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00080     {\cf19 for}(;;);\par
00081 \}\par
00082 \par
00083 {\cf20 //}\par
00084 {\cf20 // Datalogging Interrupt}\par
00085 {\cf20 //}\par
00086 interrupt {\cf18 void} DATALOG_ISR({\cf18 void})\par
00087 \{\par
00088     {\cf20 //}\par
00089     {\cf20 // Insert ISR Code here}\par
00090     {\cf20 //}\par
00091 \par
00092     {\cf20 //}\par
00093     {\cf20 // Next two lines for debug only to halt the processor here}\par
00094     {\cf20 // Remove after inserting ISR Code}\par
00095     {\cf20 //}\par
00096     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00097     {\cf19 for}(;;);\par
00098 \}\par
00099 \par
00100 {\cf20 //}\par
00101 {\cf20 // RTOS Interrupt}\par
00102 {\cf20 //}\par
00103 interrupt {\cf18 void} RTOS_ISR({\cf18 void})\par
00104 \{\par
00105     {\cf20 //}\par
00106     {\cf20 // Insert ISR Code here}\par
00107     {\cf20 //}\par
00108 \par
00109     {\cf20 //}\par
00110     {\cf20 // Next two lines for debug only to halt the processor here}\par
00111     {\cf20 // Remove after inserting ISR Code}\par
00112     {\cf20 //}\par
00113     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00114     {\cf19 for}(;;);\par
00115 \}\par
00116 \par
00117 {\cf20 //}\par
00118 {\cf20 // Emulation Interrupt}\par
00119 {\cf20 //}\par
00120 interrupt {\cf18 void} EMU_ISR({\cf18 void})\par
00121 \{\par
00122     {\cf20 //}\par
00123     {\cf20 // Insert ISR Code here}\par
00124     {\cf20 //}\par
00125 \par
00126     {\cf20 //}\par
00127     {\cf20 // Next two lines for debug only to halt the processor here}\par
00128     {\cf20 // Remove after inserting ISR Code}\par
00129     {\cf20 //}\par
00130     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00131     {\cf19 for}(;;);\par
00132 \}\par
00133 \par
00134 {\cf20 //}\par
00135 {\cf20 // Non-Maskable Interrupt}\par
00136 {\cf20 //}\par
00137 interrupt {\cf18 void} NMI_ISR({\cf18 void})\par
00138 \{\par
00139     {\cf20 //}\par
00140     {\cf20 // Insert ISR Code here}\par
00141     {\cf20 //}\par
00142 \par
00143     {\cf20 //}\par
00144     {\cf20 // Next two lines for debug only to halt the processor here}\par
00145     {\cf20 // Remove after inserting ISR Code}\par
00146     {\cf20 //}\par
00147     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00148     {\cf19 for}(;;);\par
00149 \}\par
00150 \par
00151 {\cf20 //}\par
00152 {\cf20 // Illegal Operation Trap}\par
00153 {\cf20 //}\par
00154 interrupt {\cf18 void} ILLEGAL_ISR({\cf18 void})\par
00155 \{\par
00156     {\cf20 //}\par
00157     {\cf20 // Insert ISR Code here}\par
00158     {\cf20 //}\par
00159 \par
00160     {\cf20 //}\par
00161     {\cf20 // Next two lines for debug only to halt the processor here}\par
00162     {\cf20 // Remove after inserting ISR Code}\par
00163     {\cf20 //}\par
00164     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00165     {\cf19 for}(;;);\par
00166 \}\par
00167 \par
00168 {\cf20 //}\par
00169 {\cf20 // User Defined Trap 1}\par
00170 {\cf20 //}\par
00171 interrupt {\cf18 void} USER1_ISR({\cf18 void})\par
00172 \{\par
00173     {\cf20 //}\par
00174     {\cf20 // Insert ISR Code here}\par
00175     {\cf20 //}\par
00176 \par
00177     {\cf20 //}\par
00178     {\cf20 // Next two lines for debug only to halt the processor here}\par
00179     {\cf20 // Remove after inserting ISR Code}\par
00180     {\cf20 //}\par
00181     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00182     {\cf19 for}(;;);\par
00183 \}\par
00184 \par
00185 {\cf20 //}\par
00186 {\cf20 // User Defined Trap 2}\par
00187 {\cf20 //}\par
00188 interrupt {\cf18 void} USER2_ISR({\cf18 void})\par
00189 \{\par
00190     {\cf20 //}\par
00191     {\cf20 // Insert ISR Code here}\par
00192     {\cf20 //}\par
00193 \par
00194     {\cf20 //}\par
00195     {\cf20 // Next two lines for debug only to halt the processor here}\par
00196     {\cf20 // Remove after inserting ISR Code}\par
00197     {\cf20 //}\par
00198     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00199     {\cf19 for}(;;);\par
00200 \}\par
00201 \par
00202 {\cf20 //}\par
00203 {\cf20 // User Defined Trap 3}\par
00204 {\cf20 //}\par
00205 interrupt {\cf18 void} USER3_ISR({\cf18 void})\par
00206 \{\par
00207     {\cf20 //}\par
00208     {\cf20 // Insert ISR Code here}\par
00209     {\cf20 //}\par
00210 \par
00211     {\cf20 //}\par
00212     {\cf20 // Next two lines for debug only to halt the processor here}\par
00213     {\cf20 // Remove after inserting ISR Code}\par
00214     {\cf20 //}\par
00215     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00216     {\cf19 for}(;;);\par
00217 \}\par
00218 \par
00219 {\cf20 //}\par
00220 {\cf20 // User Defined Trap 4}\par
00221 {\cf20 //}\par
00222 interrupt {\cf18 void} USER4_ISR({\cf18 void})\par
00223 \{\par
00224     {\cf20 //}\par
00225     {\cf20 // Insert ISR Code here}\par
00226     {\cf20 //}\par
00227 \par
00228     {\cf20 //}\par
00229     {\cf20 // Next two lines for debug only to halt the processor here}\par
00230     {\cf20 // Remove after inserting ISR Code}\par
00231     {\cf20 //}\par
00232     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00233     {\cf19 for}(;;);\par
00234 \}\par
00235 \par
00236 {\cf20 //}\par
00237 {\cf20 // User Defined Trap 5}\par
00238 {\cf20 //}\par
00239 interrupt {\cf18 void} USER5_ISR({\cf18 void})\par
00240 \{\par
00241     {\cf20 //}\par
00242     {\cf20 // Insert ISR Code here}\par
00243     {\cf20 //}\par
00244 \par
00245     {\cf20 //}\par
00246     {\cf20 // Next two lines for debug only to halt the processor here}\par
00247     {\cf20 // Remove after inserting ISR Code}\par
00248     {\cf20 //}\par
00249     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00250     {\cf19 for}(;;);\par
00251 \}\par
00252 \par
00253 {\cf20 //}\par
00254 {\cf20 // User Defined Trap 6}\par
00255 {\cf20 //}\par
00256 interrupt {\cf18 void} USER6_ISR({\cf18 void})\par
00257 \{\par
00258     {\cf20 //}\par
00259     {\cf20 // Insert ISR Code here}\par
00260     {\cf20 //}\par
00261 \par
00262     {\cf20 //}\par
00263     {\cf20 // Next two lines for debug only to halt the processor here}\par
00264     {\cf20 // Remove after inserting ISR Code}\par
00265     {\cf20 //}\par
00266     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00267     {\cf19 for}(;;);\par
00268 \}\par
00269 \par
00270 {\cf20 //}\par
00271 {\cf20 // User Defined Trap 7}\par
00272 {\cf20 //}\par
00273 interrupt {\cf18 void} USER7_ISR({\cf18 void})\par
00274 \{\par
00275     {\cf20 //}\par
00276     {\cf20 // Insert ISR Code here}\par
00277     {\cf20 //}\par
00278 \par
00279     {\cf20 //}\par
00280     {\cf20 // Next two lines for debug only to halt the processor here}\par
00281     {\cf20 // Remove after inserting ISR Code}\par
00282     {\cf20 //}\par
00283     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00284     {\cf19 for}(;;);\par
00285 \}\par
00286 \par
00287 {\cf20 //}\par
00288 {\cf20 // User Defined Trap 8}\par
00289 {\cf20 //}\par
00290 interrupt {\cf18 void} USER8_ISR({\cf18 void})\par
00291 \{\par
00292     {\cf20 //}\par
00293     {\cf20 // Insert ISR Code here}\par
00294     {\cf20 //}\par
00295 \par
00296     {\cf20 //}\par
00297     {\cf20 // Next two lines for debug only to halt the processor here}\par
00298     {\cf20 // Remove after inserting ISR Code}\par
00299     {\cf20 //}\par
00300     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00301     {\cf19 for}(;;);\par
00302 \}\par
00303 \par
00304 {\cf20 //}\par
00305 {\cf20 // User Defined Trap 9}\par
00306 {\cf20 //}\par
00307 interrupt {\cf18 void} USER9_ISR({\cf18 void})\par
00308 \{\par
00309     {\cf20 //}\par
00310     {\cf20 // Insert ISR Code here}\par
00311     {\cf20 //}\par
00312 \par
00313     {\cf20 //}\par
00314     {\cf20 // Next two lines for debug only to halt the processor here}\par
00315     {\cf20 // Remove after inserting ISR Code}\par
00316     {\cf20 //}\par
00317     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00318     {\cf19 for}(;;);\par
00319 \}\par
00320 \par
00321 {\cf20 //}\par
00322 {\cf20 // User Defined Trap 10}\par
00323 {\cf20 //}\par
00324 interrupt {\cf18 void} USER10_ISR({\cf18 void})\par
00325 \{\par
00326     {\cf20 //}\par
00327     {\cf20 // Insert ISR Code here}\par
00328     {\cf20 //}\par
00329 \par
00330     {\cf20 //}\par
00331     {\cf20 // Next two lines for debug only to halt the processor here}\par
00332     {\cf20 // Remove after inserting ISR Code}\par
00333     {\cf20 //}\par
00334     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00335     {\cf19 for}(;;);\par
00336 \}\par
00337 \par
00338 {\cf20 //}\par
00339 {\cf20 // User Defined Trap 11}\par
00340 {\cf20 //}\par
00341 interrupt {\cf18 void} USER11_ISR({\cf18 void})\par
00342 \{\par
00343     {\cf20 //}\par
00344     {\cf20 // Insert ISR Code here}\par
00345     {\cf20 //}\par
00346 \par
00347     {\cf20 //}\par
00348     {\cf20 // Next two lines for debug only to halt the processor here}\par
00349     {\cf20 // Remove after inserting ISR Code}\par
00350     {\cf20 //}\par
00351     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00352     {\cf19 for}(;;);\par
00353 \}\par
00354 \par
00355 {\cf20 //}\par
00356 {\cf20 // User Defined Trap 12}\par
00357 {\cf20 //}\par
00358 interrupt {\cf18 void} USER12_ISR({\cf18 void})\par
00359 \{\par
00360     {\cf20 //}\par
00361     {\cf20 // Insert ISR Code here}\par
00362     {\cf20 //}\par
00363 \par
00364     {\cf20 //}\par
00365     {\cf20 // Next two lines for debug only to halt the processor here}\par
00366     {\cf20 // Remove after inserting ISR Code}\par
00367     {\cf20 //}\par
00368     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00369     {\cf19 for}(;;);\par
00370 \}\par
00371 \par
00372 {\cf20 //}\par
00373 {\cf20 // 1.1 - ADCA Interrupt 1}\par
00374 {\cf20 //}\par
00375 interrupt {\cf18 void} ADCA1_ISR({\cf18 void})\par
00376 \{\par
00377     {\cf20 //}\par
00378     {\cf20 // Insert ISR Code here}\par
00379     {\cf20 //}\par
00380 \par
00381     {\cf20 //}\par
00382     {\cf20 // To receive more interrupts from this PIE group,}\par
00383     {\cf20 // acknowledge this interrupt.}\par
00384     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00385     {\cf20 //}\par
00386 \par
00387     {\cf20 //}\par
00388     {\cf20 // Next two lines for debug only to halt the processor here}\par
00389     {\cf20 // Remove after inserting ISR Code}\par
00390     {\cf20 //}\par
00391     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00392     {\cf19 for}(;;);\par
00393 \}\par
00394 \par
00395 {\cf20 //}\par
00396 {\cf20 // 1.2 - ADCB Interrupt 1}\par
00397 {\cf20 //}\par
00398 interrupt {\cf18 void} ADCB1_ISR({\cf18 void})\par
00399 \{\par
00400     {\cf20 //}\par
00401     {\cf20 // Insert ISR Code here}\par
00402     {\cf20 //}\par
00403 \par
00404     {\cf20 //}\par
00405     {\cf20 // To receive more interrupts from this PIE group,}\par
00406     {\cf20 // acknowledge this interrupt.}\par
00407     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00408     {\cf20 //}\par
00409 \par
00410     {\cf20 //}\par
00411     {\cf20 // Next two lines for debug only to halt the processor here}\par
00412     {\cf20 // Remove after inserting ISR Code}\par
00413     {\cf20 //}\par
00414     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00415     {\cf19 for}(;;);\par
00416 \}\par
00417 \par
00418 {\cf20 //}\par
00419 {\cf20 // 1.3 - ADCC Interrupt 1}\par
00420 {\cf20 //}\par
00421 interrupt {\cf18 void} ADCC1_ISR({\cf18 void})\par
00422 \{\par
00423     {\cf20 //}\par
00424     {\cf20 // Insert ISR Code here}\par
00425     {\cf20 //}\par
00426 \par
00427     {\cf20 //}\par
00428     {\cf20 // To receive more interrupts from this PIE group,}\par
00429     {\cf20 // acknowledge this interrupt.}\par
00430     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00431     {\cf20 //}\par
00432 \par
00433     {\cf20 //}\par
00434     {\cf20 // Next two lines for debug only to halt the processor here}\par
00435     {\cf20 // Remove after inserting ISR Code}\par
00436     {\cf20 //}\par
00437     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00438     {\cf19 for}(;;);\par
00439 \}\par
00440 \par
00441 {\cf20 //}\par
00442 {\cf20 // 1.4 - XINT1 Interrupt}\par
00443 {\cf20 //}\par
00444 interrupt {\cf18 void} XINT1_ISR({\cf18 void})\par
00445 \{\par
00446     {\cf20 //}\par
00447     {\cf20 // Insert ISR Code here}\par
00448     {\cf20 //}\par
00449 \par
00450     {\cf20 //}\par
00451     {\cf20 // To receive more interrupts from this PIE group,}\par
00452     {\cf20 // acknowledge this interrupt.}\par
00453     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00454     {\cf20 //}\par
00455 \par
00456     {\cf20 //}\par
00457     {\cf20 // Next two lines for debug only to halt the processor here}\par
00458     {\cf20 // Remove after inserting ISR Code}\par
00459     {\cf20 //}\par
00460     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00461     {\cf19 for}(;;);\par
00462 \}\par
00463 \par
00464 {\cf20 //}\par
00465 {\cf20 // 1.5 - XINT2 Interrupt}\par
00466 {\cf20 //}\par
00467 interrupt {\cf18 void} XINT2_ISR({\cf18 void})\par
00468 \{\par
00469     {\cf20 //}\par
00470     {\cf20 // Insert ISR Code here}\par
00471     {\cf20 //}\par
00472 \par
00473     {\cf20 //}\par
00474     {\cf20 // To receive more interrupts from this PIE group,}\par
00475     {\cf20 // acknowledge this interrupt.}\par
00476     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00477     {\cf20 //}\par
00478 \par
00479     {\cf20 //}\par
00480     {\cf20 // Next two lines for debug only to halt the processor here}\par
00481     {\cf20 // Remove after inserting ISR Code}\par
00482     {\cf20 //}\par
00483     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00484     {\cf19 for}(;;);\par
00485 \}\par
00486 \par
00487 {\cf20 //}\par
00488 {\cf20 // 1.6 - ADCD Interrupt 1}\par
00489 {\cf20 //}\par
00490 interrupt {\cf18 void} ADCD1_ISR({\cf18 void})\par
00491 \{\par
00492     {\cf20 //}\par
00493     {\cf20 // Insert ISR Code here}\par
00494     {\cf20 //}\par
00495 \par
00496     {\cf20 //}\par
00497     {\cf20 // To receive more interrupts from this PIE group,}\par
00498     {\cf20 // acknowledge this interrupt.}\par
00499     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00500     {\cf20 //}\par
00501 \par
00502     {\cf20 //}\par
00503     {\cf20 // Next two lines for debug only to halt the processor here}\par
00504     {\cf20 // Remove after inserting ISR Code}\par
00505     {\cf20 //}\par
00506     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00507     {\cf19 for}(;;);\par
00508 \}\par
00509 \par
00510 {\cf20 //}\par
00511 {\cf20 // 1.7 - Timer 0 Interrupt}\par
00512 {\cf20 //}\par
00513 interrupt {\cf18 void} TIMER0_ISR({\cf18 void})\par
00514 \{\par
00515     {\cf20 //}\par
00516     {\cf20 // Insert ISR Code here}\par
00517     {\cf20 //}\par
00518 \par
00519     {\cf20 //}\par
00520     {\cf20 // To receive more interrupts from this PIE group,}\par
00521     {\cf20 // acknowledge this interrupt.}\par
00522     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00523     {\cf20 //}\par
00524 \par
00525     {\cf20 //}\par
00526     {\cf20 // Next two lines for debug only to halt the processor here}\par
00527     {\cf20 // Remove after inserting ISR Code}\par
00528     {\cf20 //}\par
00529     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00530     {\cf19 for}(;;);\par
00531 \}\par
00532 \par
00533 {\cf20 //}\par
00534 {\cf20 // 1.8 - Standby and Halt Wakeup Interrupt}\par
00535 {\cf20 //}\par
00536 interrupt {\cf18 void} WAKE_ISR({\cf18 void})\par
00537 \{\par
00538     {\cf20 //}\par
00539     {\cf20 // Insert ISR Code here}\par
00540     {\cf20 //}\par
00541 \par
00542     {\cf20 //}\par
00543     {\cf20 // To receive more interrupts from this PIE group,}\par
00544     {\cf20 // acknowledge this interrupt.}\par
00545     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
00546     {\cf20 //}\par
00547 \par
00548     {\cf20 //}\par
00549     {\cf20 // Next two lines for debug only to halt the processor here}\par
00550     {\cf20 // Remove after inserting ISR Code}\par
00551     {\cf20 //}\par
00552     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00553     {\cf19 for}(;;);\par
00554 \}\par
00555 \par
00556 {\cf20 //}\par
00557 {\cf20 // 2.1 - ePWM1 Trip Zone Interrupt}\par
00558 {\cf20 //}\par
00559 interrupt {\cf18 void} EPWM1_TZ_ISR({\cf18 void})\par
00560 \{\par
00561     {\cf20 //}\par
00562     {\cf20 // Insert ISR Code here}\par
00563     {\cf20 //}\par
00564 \par
00565     {\cf20 //}\par
00566     {\cf20 // To receive more interrupts from this PIE group,}\par
00567     {\cf20 // acknowledge this interrupt.}\par
00568     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00569     {\cf20 //}\par
00570 \par
00571     {\cf20 //}\par
00572     {\cf20 // Next two lines for debug only to halt the processor here}\par
00573     {\cf20 // Remove after inserting ISR Code}\par
00574     {\cf20 //}\par
00575     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00576     {\cf19 for}(;;);\par
00577 \}\par
00578 \par
00579 {\cf20 //}\par
00580 {\cf20 // 2.2 - ePWM2 Trip Zone Interrupt}\par
00581 {\cf20 //}\par
00582 interrupt {\cf18 void} EPWM2_TZ_ISR({\cf18 void})\par
00583 \{\par
00584     {\cf20 //}\par
00585     {\cf20 // Insert ISR Code here}\par
00586     {\cf20 //}\par
00587 \par
00588     {\cf20 //}\par
00589     {\cf20 // To receive more interrupts from this PIE group,}\par
00590     {\cf20 // acknowledge this interrupt.}\par
00591     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00592     {\cf20 //}\par
00593 \par
00594     {\cf20 //}\par
00595     {\cf20 // Next two lines for debug only to halt the processor here}\par
00596     {\cf20 // Remove after inserting ISR Code}\par
00597     {\cf20 //}\par
00598     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00599     {\cf19 for}(;;);\par
00600 \}\par
00601 \par
00602 {\cf20 //}\par
00603 {\cf20 // 2.3 - ePWM3 Trip Zone Interrupt}\par
00604 {\cf20 //}\par
00605 interrupt {\cf18 void} EPWM3_TZ_ISR({\cf18 void})\par
00606 \{\par
00607     {\cf20 //}\par
00608     {\cf20 // Insert ISR Code here}\par
00609     {\cf20 //}\par
00610 \par
00611     {\cf20 //}\par
00612     {\cf20 // To receive more interrupts from this PIE group,}\par
00613     {\cf20 // acknowledge this interrupt.}\par
00614     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00615     {\cf20 //}\par
00616 \par
00617     {\cf20 //}\par
00618     {\cf20 // Next two lines for debug only to halt the processor here}\par
00619     {\cf20 // Remove after inserting ISR Code}\par
00620     {\cf20 //}\par
00621     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00622     {\cf19 for}(;;);\par
00623 \}\par
00624 \par
00625 {\cf20 //}\par
00626 {\cf20 // 2.4 - ePWM4 Trip Zone Interrupt}\par
00627 {\cf20 //}\par
00628 interrupt {\cf18 void} EPWM4_TZ_ISR({\cf18 void})\par
00629 \{\par
00630     {\cf20 //}\par
00631     {\cf20 // Insert ISR Code here}\par
00632     {\cf20 //}\par
00633 \par
00634     {\cf20 //}\par
00635     {\cf20 // To receive more interrupts from this PIE group,}\par
00636     {\cf20 // acknowledge this interrupt.}\par
00637     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00638     {\cf20 //}\par
00639 \par
00640     {\cf20 //}\par
00641     {\cf20 // Next two lines for debug only to halt the processor here}\par
00642     {\cf20 // Remove after inserting ISR Code}\par
00643     {\cf20 //}\par
00644     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00645     {\cf19 for}(;;);\par
00646 \}\par
00647 \par
00648 {\cf20 //}\par
00649 {\cf20 // 2.5 - ePWM5 Trip Zone Interrupt}\par
00650 {\cf20 //}\par
00651 interrupt {\cf18 void} EPWM5_TZ_ISR({\cf18 void})\par
00652 \{\par
00653     {\cf20 //}\par
00654     {\cf20 // Insert ISR Code here}\par
00655     {\cf20 //}\par
00656 \par
00657     {\cf20 //}\par
00658     {\cf20 // To receive more interrupts from this PIE group,}\par
00659     {\cf20 // acknowledge this interrupt.}\par
00660     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00661     {\cf20 //}\par
00662 \par
00663     {\cf20 //}\par
00664     {\cf20 // Next two lines for debug only to halt the processor here}\par
00665     {\cf20 // Remove after inserting ISR Code}\par
00666     {\cf20 //}\par
00667     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00668     {\cf19 for}(;;);\par
00669 \}\par
00670 \par
00671 {\cf20 //}\par
00672 {\cf20 // 2.6 - ePWM6 Trip Zone Interrupt}\par
00673 {\cf20 //}\par
00674 interrupt {\cf18 void} EPWM6_TZ_ISR({\cf18 void})\par
00675 \{\par
00676     {\cf20 //}\par
00677     {\cf20 // Insert ISR Code here}\par
00678     {\cf20 //}\par
00679 \par
00680     {\cf20 //}\par
00681     {\cf20 // To receive more interrupts from this PIE group,}\par
00682     {\cf20 // acknowledge this interrupt.}\par
00683     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00684     {\cf20 //}\par
00685 \par
00686     {\cf20 //}\par
00687     {\cf20 // Next two lines for debug only to halt the processor here}\par
00688     {\cf20 // Remove after inserting ISR Code}\par
00689     {\cf20 //}\par
00690     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00691     {\cf19 for}(;;);\par
00692 \}\par
00693 \par
00694 {\cf20 //}\par
00695 {\cf20 // 2.7 - ePWM7 Trip Zone Interrupt}\par
00696 {\cf20 //}\par
00697 interrupt {\cf18 void} EPWM7_TZ_ISR({\cf18 void})\par
00698 \{\par
00699     {\cf20 //}\par
00700     {\cf20 // Insert ISR Code here}\par
00701     {\cf20 //}\par
00702 \par
00703     {\cf20 //}\par
00704     {\cf20 // To receive more interrupts from this PIE group,}\par
00705     {\cf20 // acknowledge this interrupt.}\par
00706     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00707     {\cf20 //}\par
00708 \par
00709     {\cf20 //}\par
00710     {\cf20 // Next two lines for debug only to halt the processor here}\par
00711     {\cf20 // Remove after inserting ISR Code}\par
00712     {\cf20 //}\par
00713     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00714     {\cf19 for}(;;);\par
00715 \}\par
00716 \par
00717 {\cf20 //}\par
00718 {\cf20 // 2.8 - ePWM8 Trip Zone Interrupt}\par
00719 {\cf20 //}\par
00720 interrupt {\cf18 void} EPWM8_TZ_ISR({\cf18 void})\par
00721 \{\par
00722     {\cf20 //}\par
00723     {\cf20 // Insert ISR Code here}\par
00724     {\cf20 //}\par
00725 \par
00726     {\cf20 //}\par
00727     {\cf20 // To receive more interrupts from this PIE group,}\par
00728     {\cf20 // acknowledge this interrupt.}\par
00729     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
00730     {\cf20 //}\par
00731 \par
00732     {\cf20 //}\par
00733     {\cf20 // Next two lines for debug only to halt the processor here}\par
00734     {\cf20 // Remove after inserting ISR Code}\par
00735     {\cf20 //}\par
00736     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00737     {\cf19 for}(;;);\par
00738 \}\par
00739 \par
00740 {\cf20 //}\par
00741 {\cf20 // 3.1 - ePWM1 Interrupt}\par
00742 {\cf20 //}\par
00743 interrupt {\cf18 void} EPWM1_ISR({\cf18 void})\par
00744 \{\par
00745     {\cf20 //}\par
00746     {\cf20 // Insert ISR Code here}\par
00747     {\cf20 //}\par
00748 \par
00749     {\cf20 //}\par
00750     {\cf20 // To receive more interrupts from this PIE group,}\par
00751     {\cf20 // acknowledge this interrupt.}\par
00752     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00753     {\cf20 //}\par
00754 \par
00755     {\cf20 //}\par
00756     {\cf20 // Next two lines for debug only to halt the processor here}\par
00757     {\cf20 // Remove after inserting ISR Code}\par
00758     {\cf20 //}\par
00759     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00760     {\cf19 for}(;;);\par
00761 \}\par
00762 \par
00763 {\cf20 //}\par
00764 {\cf20 // 3.2 - ePWM2 Interrupt}\par
00765 {\cf20 //}\par
00766 interrupt {\cf18 void} EPWM2_ISR({\cf18 void})\par
00767 \{\par
00768     {\cf20 //}\par
00769     {\cf20 // Insert ISR Code here}\par
00770     {\cf20 //}\par
00771 \par
00772     {\cf20 //}\par
00773     {\cf20 // To receive more interrupts from this PIE group,}\par
00774     {\cf20 // acknowledge this interrupt.}\par
00775     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00776     {\cf20 //}\par
00777 \par
00778     {\cf20 //}\par
00779     {\cf20 // Next two lines for debug only to halt the processor here}\par
00780     {\cf20 // Remove after inserting ISR Code}\par
00781     {\cf20 //}\par
00782     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00783     {\cf19 for}(;;);\par
00784 \}\par
00785 \par
00786 {\cf20 //}\par
00787 {\cf20 // 3.3 - ePWM3 Interrupt}\par
00788 {\cf20 //}\par
00789 interrupt {\cf18 void} EPWM3_ISR({\cf18 void})\par
00790 \{\par
00791     {\cf20 //}\par
00792     {\cf20 // Insert ISR Code here}\par
00793     {\cf20 //}\par
00794 \par
00795     {\cf20 //}\par
00796     {\cf20 // To receive more interrupts from this PIE group,}\par
00797     {\cf20 // acknowledge this interrupt.}\par
00798     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00799     {\cf20 //}\par
00800 \par
00801     {\cf20 //}\par
00802     {\cf20 // Next two lines for debug only to halt the processor here}\par
00803     {\cf20 // Remove after inserting ISR Code}\par
00804     {\cf20 //}\par
00805     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00806     {\cf19 for}(;;);\par
00807 \}\par
00808 \par
00809 {\cf20 //}\par
00810 {\cf20 // 3.4 - ePWM4 Interrupt}\par
00811 {\cf20 //}\par
00812 interrupt {\cf18 void} EPWM4_ISR({\cf18 void})\par
00813 \{\par
00814     {\cf20 //}\par
00815     {\cf20 // Insert ISR Code here}\par
00816     {\cf20 //}\par
00817 \par
00818     {\cf20 //}\par
00819     {\cf20 // To receive more interrupts from this PIE group,}\par
00820     {\cf20 // acknowledge this interrupt.}\par
00821     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00822     {\cf20 //}\par
00823 \par
00824     {\cf20 //}\par
00825     {\cf20 // Next two lines for debug only to halt the processor here}\par
00826     {\cf20 // Remove after inserting ISR Code}\par
00827     {\cf20 //}\par
00828     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00829     {\cf19 for}(;;);\par
00830 \}\par
00831 \par
00832 {\cf20 //}\par
00833 {\cf20 // 3.5 - ePWM5 Interrupt}\par
00834 {\cf20 //}\par
00835 interrupt {\cf18 void} EPWM5_ISR({\cf18 void})\par
00836 \{\par
00837     {\cf20 //}\par
00838     {\cf20 // Insert ISR Code here}\par
00839     {\cf20 //}\par
00840 \par
00841     {\cf20 //}\par
00842     {\cf20 // To receive more interrupts from this PIE group,}\par
00843     {\cf20 // acknowledge this interrupt.}\par
00844     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00845     {\cf20 //}\par
00846 \par
00847     {\cf20 //}\par
00848     {\cf20 // Next two lines for debug only to halt the processor here}\par
00849     {\cf20 // Remove after inserting ISR Code}\par
00850     {\cf20 //}\par
00851     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00852     {\cf19 for}(;;);\par
00853 \}\par
00854 \par
00855 {\cf20 //}\par
00856 {\cf20 // 3.6 - ePWM6 Interrupt}\par
00857 {\cf20 //}\par
00858 interrupt {\cf18 void} EPWM6_ISR({\cf18 void})\par
00859 \{\par
00860     {\cf20 //}\par
00861     {\cf20 // Insert ISR Code here}\par
00862     {\cf20 //}\par
00863 \par
00864     {\cf20 //}\par
00865     {\cf20 // To receive more interrupts from this PIE group,}\par
00866     {\cf20 // acknowledge this interrupt.}\par
00867     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00868     {\cf20 //}\par
00869 \par
00870     {\cf20 //}\par
00871     {\cf20 // Next two lines for debug only to halt the processor here}\par
00872     {\cf20 // Remove after inserting ISR Code}\par
00873     {\cf20 //}\par
00874     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00875     {\cf19 for}(;;);\par
00876 \}\par
00877 \par
00878 {\cf20 //}\par
00879 {\cf20 // 3.7 - ePWM7 Interrupt}\par
00880 {\cf20 //}\par
00881 interrupt {\cf18 void} EPWM7_ISR({\cf18 void})\par
00882 \{\par
00883     {\cf20 //}\par
00884     {\cf20 // Insert ISR Code here}\par
00885     {\cf20 //}\par
00886 \par
00887     {\cf20 //}\par
00888     {\cf20 // To receive more interrupts from this PIE group,}\par
00889     {\cf20 // acknowledge this interrupt.}\par
00890     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00891     {\cf20 //}\par
00892 \par
00893     {\cf20 //}\par
00894     {\cf20 // Next two lines for debug only to halt the processor here}\par
00895     {\cf20 // Remove after inserting ISR Code}\par
00896     {\cf20 //}\par
00897     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00898     {\cf19 for}(;;);\par
00899 \}\par
00900 \par
00901 {\cf20 //}\par
00902 {\cf20 // 3.8 - ePWM8 Interrupt}\par
00903 {\cf20 //}\par
00904 interrupt {\cf18 void} EPWM8_ISR({\cf18 void})\par
00905 \{\par
00906     {\cf20 //}\par
00907     {\cf20 // Insert ISR Code here}\par
00908     {\cf20 //}\par
00909 \par
00910     {\cf20 //}\par
00911     {\cf20 // To receive more interrupts from this PIE group,}\par
00912     {\cf20 // acknowledge this interrupt.}\par
00913     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
00914     {\cf20 //}\par
00915 \par
00916     {\cf20 //}\par
00917     {\cf20 // Next two lines for debug only to halt the processor here}\par
00918     {\cf20 // Remove after inserting ISR Code}\par
00919     {\cf20 //}\par
00920     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00921     {\cf19 for}(;;);\par
00922 \}\par
00923 \par
00924 {\cf20 //}\par
00925 {\cf20 // 4.1 - eCAP1 Interrupt}\par
00926 {\cf20 //}\par
00927 interrupt {\cf18 void} ECAP1_ISR({\cf18 void})\par
00928 \{\par
00929     {\cf20 //}\par
00930     {\cf20 // Insert ISR Code here}\par
00931     {\cf20 //}\par
00932 \par
00933     {\cf20 //}\par
00934     {\cf20 // To receive more interrupts from this PIE group,}\par
00935     {\cf20 // acknowledge this interrupt.}\par
00936     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;}\par
00937     {\cf20 //}\par
00938 \par
00939     {\cf20 //}\par
00940     {\cf20 // Next two lines for debug only to halt the processor here}\par
00941     {\cf20 // Remove after inserting ISR Code}\par
00942     {\cf20 //}\par
00943     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00944     {\cf19 for}(;;);\par
00945 \}\par
00946 \par
00947 {\cf20 //}\par
00948 {\cf20 // 4.2 - eCAP2 Interrupt}\par
00949 {\cf20 //}\par
00950 interrupt {\cf18 void} ECAP2_ISR({\cf18 void})\par
00951 \{\par
00952     {\cf20 //}\par
00953     {\cf20 // Insert ISR Code here}\par
00954     {\cf20 //}\par
00955 \par
00956     {\cf20 //}\par
00957     {\cf20 // To receive more interrupts from this PIE group,}\par
00958     {\cf20 // acknowledge this interrupt.}\par
00959     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;}\par
00960     {\cf20 //}\par
00961 \par
00962     {\cf20 //}\par
00963     {\cf20 // Next two lines for debug only to halt the processor here}\par
00964     {\cf20 // Remove after inserting ISR Code}\par
00965     {\cf20 //}\par
00966     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00967     {\cf19 for}(;;);\par
00968 \}\par
00969 \par
00970 {\cf20 //}\par
00971 {\cf20 // 4.3 - eCAP3 Interrupt}\par
00972 {\cf20 //}\par
00973 interrupt {\cf18 void} ECAP3_ISR({\cf18 void})\par
00974 \{\par
00975     {\cf20 //}\par
00976     {\cf20 // Insert ISR Code here}\par
00977     {\cf20 //}\par
00978 \par
00979     {\cf20 //}\par
00980     {\cf20 // To receive more interrupts from this PIE group,}\par
00981     {\cf20 // acknowledge this interrupt.}\par
00982     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;}\par
00983     {\cf20 //}\par
00984 \par
00985     {\cf20 //}\par
00986     {\cf20 // Next two lines for debug only to halt the processor here}\par
00987     {\cf20 // Remove after inserting ISR Code}\par
00988     {\cf20 //}\par
00989     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
00990     {\cf19 for}(;;);\par
00991 \}\par
00992 \par
00993 {\cf20 //}\par
00994 {\cf20 // 4.4 - eCAP4 Interrupt}\par
00995 {\cf20 //}\par
00996 interrupt {\cf18 void} ECAP4_ISR({\cf18 void})\par
00997 \{\par
00998     {\cf20 //}\par
00999     {\cf20 // Insert ISR Code here}\par
01000     {\cf20 //}\par
01001 \par
01002     {\cf20 //}\par
01003     {\cf20 // To receive more interrupts from this PIE group,}\par
01004     {\cf20 // acknowledge this interrupt.}\par
01005     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;}\par
01006     {\cf20 //}\par
01007 \par
01008     {\cf20 //}\par
01009     {\cf20 // Next two lines for debug only to halt the processor here}\par
01010     {\cf20 // Remove after inserting ISR Code}\par
01011     {\cf20 //}\par
01012     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01013     {\cf19 for}(;;);\par
01014 \}\par
01015 \par
01016 {\cf20 //}\par
01017 {\cf20 // 4.5 - eCAP5 Interrupt}\par
01018 {\cf20 //}\par
01019 interrupt {\cf18 void} ECAP5_ISR({\cf18 void})\par
01020 \{\par
01021     {\cf20 //}\par
01022     {\cf20 // Insert ISR Code here}\par
01023     {\cf20 //}\par
01024 \par
01025     {\cf20 //}\par
01026     {\cf20 // To receive more interrupts from this PIE group,}\par
01027     {\cf20 // acknowledge this interrupt.}\par
01028     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;}\par
01029     {\cf20 //}\par
01030 \par
01031     {\cf20 //}\par
01032     {\cf20 // Next two lines for debug only to halt the processor here}\par
01033     {\cf20 // Remove after inserting ISR Code}\par
01034     {\cf20 //}\par
01035     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01036     {\cf19 for}(;;);\par
01037 \}\par
01038 \par
01039 {\cf20 //}\par
01040 {\cf20 // 4.6 - eCAP6 Interrupt}\par
01041 {\cf20 //}\par
01042 interrupt {\cf18 void} ECAP6_ISR({\cf18 void})\par
01043 \{\par
01044     {\cf20 //}\par
01045     {\cf20 // Insert ISR Code here}\par
01046     {\cf20 //}\par
01047 \par
01048     {\cf20 //}\par
01049     {\cf20 // To receive more interrupts from this PIE group,}\par
01050     {\cf20 // acknowledge this interrupt.}\par
01051     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;}\par
01052     {\cf20 //}\par
01053 \par
01054     {\cf20 //}\par
01055     {\cf20 // Next two lines for debug only to halt the processor here}\par
01056     {\cf20 // Remove after inserting ISR Code}\par
01057     {\cf20 //}\par
01058     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01059     {\cf19 for}(;;);\par
01060 \}\par
01061 \par
01062 {\cf20 //}\par
01063 {\cf20 // 5.1 - eQEP1 Interrupt}\par
01064 {\cf20 //}\par
01065 interrupt {\cf18 void} EQEP1_ISR({\cf18 void})\par
01066 \{\par
01067     {\cf20 //}\par
01068     {\cf20 // Insert ISR Code here}\par
01069     {\cf20 //}\par
01070 \par
01071     {\cf20 //}\par
01072     {\cf20 // To receive more interrupts from this PIE group,}\par
01073     {\cf20 // acknowledge this interrupt.}\par
01074     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;}\par
01075     {\cf20 //}\par
01076 \par
01077     {\cf20 //}\par
01078     {\cf20 // Next two lines for debug only to halt the processor here}\par
01079     {\cf20 // Remove after inserting ISR Code}\par
01080     {\cf20 //}\par
01081     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01082     {\cf19 for}(;;);\par
01083 \}\par
01084 \par
01085 {\cf20 //}\par
01086 {\cf20 // 5.2 - eQEP2 Interrupt}\par
01087 {\cf20 //}\par
01088 interrupt {\cf18 void} EQEP2_ISR({\cf18 void})\par
01089 \{\par
01090     {\cf20 //}\par
01091     {\cf20 // Insert ISR Code here}\par
01092     {\cf20 //}\par
01093 \par
01094     {\cf20 //}\par
01095     {\cf20 // To receive more interrupts from this PIE group,}\par
01096     {\cf20 // acknowledge this interrupt.}\par
01097     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;}\par
01098     {\cf20 //}\par
01099 \par
01100     {\cf20 //}\par
01101     {\cf20 // Next two lines for debug only to halt the processor here}\par
01102     {\cf20 // Remove after inserting ISR Code}\par
01103     {\cf20 //}\par
01104     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01105     {\cf19 for}(;;);\par
01106 \}\par
01107 \par
01108 {\cf20 //}\par
01109 {\cf20 // 5.3 - eQEP3 Interrupt}\par
01110 {\cf20 //}\par
01111 interrupt {\cf18 void} EQEP3_ISR({\cf18 void})\par
01112 \{\par
01113     {\cf20 //}\par
01114     {\cf20 // Insert ISR Code here}\par
01115     {\cf20 //}\par
01116 \par
01117     {\cf20 //}\par
01118     {\cf20 // To receive more interrupts from this PIE group,}\par
01119     {\cf20 // acknowledge this interrupt.}\par
01120     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;}\par
01121     {\cf20 //}\par
01122 \par
01123     {\cf20 //}\par
01124     {\cf20 // Next two lines for debug only to halt the processor here}\par
01125     {\cf20 // Remove after inserting ISR Code}\par
01126     {\cf20 //}\par
01127     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01128     {\cf19 for}(;;);\par
01129 \}\par
01130 \par
01131 {\cf20 //}\par
01132 {\cf20 // 6.1 - SPIA Receive Interrupt}\par
01133 {\cf20 //}\par
01134 interrupt {\cf18 void} SPIA_RX_ISR({\cf18 void})\par
01135 \{\par
01136     {\cf20 //}\par
01137     {\cf20 // Insert ISR Code here}\par
01138     {\cf20 //}\par
01139 \par
01140     {\cf20 //}\par
01141     {\cf20 // To receive more interrupts from this PIE group,}\par
01142     {\cf20 // acknowledge this interrupt.}\par
01143     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01144     {\cf20 //}\par
01145 \par
01146     {\cf20 //}\par
01147     {\cf20 // Next two lines for debug only to halt the processor here}\par
01148     {\cf20 // Remove after inserting ISR Code}\par
01149     {\cf20 //}\par
01150     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01151     {\cf19 for}(;;);\par
01152 \}\par
01153 \par
01154 {\cf20 //}\par
01155 {\cf20 // 6.2 - SPIA Transmit Interrupt}\par
01156 {\cf20 //}\par
01157 interrupt {\cf18 void} SPIA_TX_ISR({\cf18 void})\par
01158 \{\par
01159     {\cf20 //}\par
01160     {\cf20 // Insert ISR Code here}\par
01161     {\cf20 //}\par
01162 \par
01163     {\cf20 //}\par
01164     {\cf20 // To receive more interrupts from this PIE group,}\par
01165     {\cf20 // acknowledge this interrupt.}\par
01166     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01167     {\cf20 //}\par
01168 \par
01169     {\cf20 //}\par
01170     {\cf20 // Next two lines for debug only to halt the processor here}\par
01171     {\cf20 // Remove after inserting ISR Code}\par
01172     {\cf20 //}\par
01173     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01174     {\cf19 for}(;;);\par
01175 \}\par
01176 \par
01177 {\cf20 //}\par
01178 {\cf20 // 6.3 - SPIB Receive Interrupt}\par
01179 {\cf20 //}\par
01180 interrupt {\cf18 void} SPIB_RX_ISR({\cf18 void})\par
01181 \{\par
01182     {\cf20 //}\par
01183     {\cf20 // Insert ISR Code here}\par
01184     {\cf20 //}\par
01185 \par
01186     {\cf20 //}\par
01187     {\cf20 // To receive more interrupts from this PIE group,}\par
01188     {\cf20 // acknowledge this interrupt.}\par
01189     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01190     {\cf20 //}\par
01191 \par
01192     {\cf20 //}\par
01193     {\cf20 // Next two lines for debug only to halt the processor here}\par
01194     {\cf20 // Remove after inserting ISR Code}\par
01195     {\cf20 //}\par
01196     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01197     {\cf19 for}(;;);\par
01198 \}\par
01199 \par
01200 {\cf20 //}\par
01201 {\cf20 // 6.4 - SPIB Transmit Interrupt}\par
01202 {\cf20 //}\par
01203 interrupt {\cf18 void} SPIB_TX_ISR({\cf18 void})\par
01204 \{\par
01205     {\cf20 //}\par
01206     {\cf20 // Insert ISR Code here}\par
01207     {\cf20 //}\par
01208 \par
01209     {\cf20 //}\par
01210     {\cf20 // To receive more interrupts from this PIE group,}\par
01211     {\cf20 // acknowledge this interrupt.}\par
01212     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01213     {\cf20 //}\par
01214 \par
01215     {\cf20 //}\par
01216     {\cf20 // Next two lines for debug only to halt the processor here}\par
01217     {\cf20 // Remove after inserting ISR Code}\par
01218     {\cf20 //}\par
01219     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01220     {\cf19 for}(;;);\par
01221 \}\par
01222 \par
01223 {\cf20 //}\par
01224 {\cf20 // 6.5 - McBSPA Receive Interrupt}\par
01225 {\cf20 //}\par
01226 interrupt {\cf18 void} MCBSPA_RX_ISR({\cf18 void})\par
01227 \{\par
01228     {\cf20 //}\par
01229     {\cf20 // Insert ISR Code here}\par
01230     {\cf20 //}\par
01231 \par
01232     {\cf20 //}\par
01233     {\cf20 // To receive more interrupts from this PIE group,}\par
01234     {\cf20 // acknowledge this interrupt.}\par
01235     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01236     {\cf20 //}\par
01237 \par
01238     {\cf20 //}\par
01239     {\cf20 // Next two lines for debug only to halt the processor here}\par
01240     {\cf20 // Remove after inserting ISR Code}\par
01241     {\cf20 //}\par
01242     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01243     {\cf19 for}(;;);\par
01244 \}\par
01245 \par
01246 {\cf20 //}\par
01247 {\cf20 // 6.6 - McBSPA Transmit Interrupt}\par
01248 {\cf20 //}\par
01249 interrupt {\cf18 void} MCBSPA_TX_ISR({\cf18 void})\par
01250 \{\par
01251     {\cf20 //}\par
01252     {\cf20 // Insert ISR Code here}\par
01253     {\cf20 //}\par
01254 \par
01255     {\cf20 //}\par
01256     {\cf20 // To receive more interrupts from this PIE group,}\par
01257     {\cf20 // acknowledge this interrupt.}\par
01258     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01259     {\cf20 //}\par
01260 \par
01261     {\cf20 //}\par
01262     {\cf20 // Next two lines for debug only to halt the processor here}\par
01263     {\cf20 // Remove after inserting ISR Code}\par
01264     {\cf20 //}\par
01265     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01266     {\cf19 for}(;;);\par
01267 \}\par
01268 \par
01269 {\cf20 //}\par
01270 {\cf20 // 6.7 - McBSPB Receive Interrupt}\par
01271 {\cf20 //}\par
01272 interrupt {\cf18 void} MCBSPB_RX_ISR({\cf18 void})\par
01273 \{\par
01274     {\cf20 //}\par
01275     {\cf20 // Insert ISR Code here}\par
01276     {\cf20 //}\par
01277 \par
01278     {\cf20 //}\par
01279     {\cf20 // To receive more interrupts from this PIE group,}\par
01280     {\cf20 // acknowledge this interrupt.}\par
01281     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01282     {\cf20 //}\par
01283 \par
01284     {\cf20 //}\par
01285     {\cf20 // Next two lines for debug only to halt the processor here}\par
01286     {\cf20 // Remove after inserting ISR Code}\par
01287     {\cf20 //}\par
01288     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01289     {\cf19 for}(;;);\par
01290 \}\par
01291 \par
01292 {\cf20 //}\par
01293 {\cf20 // 6.8 - McBSPB Transmit Interrupt}\par
01294 {\cf20 //}\par
01295 interrupt {\cf18 void} MCBSPB_TX_ISR({\cf18 void})\par
01296 \{\par
01297     {\cf20 //}\par
01298     {\cf20 // Insert ISR Code here}\par
01299     {\cf20 //}\par
01300 \par
01301     {\cf20 //}\par
01302     {\cf20 // To receive more interrupts from this PIE group,}\par
01303     {\cf20 // acknowledge this interrupt.}\par
01304     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
01305     {\cf20 //}\par
01306 \par
01307     {\cf20 //}\par
01308     {\cf20 // Next two lines for debug only to halt the processor here}\par
01309     {\cf20 // Remove after inserting ISR Code}\par
01310     {\cf20 //}\par
01311     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01312     {\cf19 for}(;;);\par
01313 \}\par
01314 \par
01315 {\cf20 //}\par
01316 {\cf20 // 7.1 - DMA Channel 1 Interrupt}\par
01317 {\cf20 //}\par
01318 interrupt {\cf18 void} DMA_CH1_ISR({\cf18 void})\par
01319 \{\par
01320     {\cf20 //}\par
01321     {\cf20 // Insert ISR Code here}\par
01322     {\cf20 //}\par
01323 \par
01324     {\cf20 //}\par
01325     {\cf20 // To receive more interrupts from this PIE group,}\par
01326     {\cf20 // acknowledge this interrupt.}\par
01327     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;}\par
01328     {\cf20 //}\par
01329 \par
01330     {\cf20 //}\par
01331     {\cf20 // Next two lines for debug only to halt the processor here}\par
01332     {\cf20 // Remove after inserting ISR Code}\par
01333     {\cf20 //}\par
01334     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01335     {\cf19 for}(;;);\par
01336 \}\par
01337 \par
01338 {\cf20 //}\par
01339 {\cf20 // 7.2 - DMA Channel 2 Interrupt}\par
01340 {\cf20 //}\par
01341 interrupt {\cf18 void} DMA_CH2_ISR({\cf18 void})\par
01342 \{\par
01343     {\cf20 //}\par
01344     {\cf20 // Insert ISR Code here}\par
01345     {\cf20 //}\par
01346 \par
01347     {\cf20 //}\par
01348     {\cf20 // To receive more interrupts from this PIE group,}\par
01349     {\cf20 // acknowledge this interrupt.}\par
01350     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;}\par
01351     {\cf20 //}\par
01352 \par
01353     {\cf20 //}\par
01354     {\cf20 // Next two lines for debug only to halt the processor here}\par
01355     {\cf20 // Remove after inserting ISR Code}\par
01356     {\cf20 //}\par
01357     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01358     {\cf19 for}(;;);\par
01359 \}\par
01360 \par
01361 {\cf20 //}\par
01362 {\cf20 // 7.3 - DMA Channel 3 Interrupt}\par
01363 {\cf20 //}\par
01364 interrupt {\cf18 void} DMA_CH3_ISR({\cf18 void})\par
01365 \{\par
01366     {\cf20 //}\par
01367     {\cf20 // Insert ISR Code here}\par
01368     {\cf20 //}\par
01369 \par
01370     {\cf20 //}\par
01371     {\cf20 // To receive more interrupts from this PIE group,}\par
01372     {\cf20 // acknowledge this interrupt.}\par
01373     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;}\par
01374     {\cf20 //}\par
01375 \par
01376     {\cf20 //}\par
01377     {\cf20 // Next two lines for debug only to halt the processor here}\par
01378     {\cf20 // Remove after inserting ISR Code}\par
01379     {\cf20 //}\par
01380     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01381     {\cf19 for}(;;);\par
01382 \}\par
01383 \par
01384 {\cf20 //}\par
01385 {\cf20 // 7.4 - DMA Channel 4 Interrupt}\par
01386 {\cf20 //}\par
01387 interrupt {\cf18 void} DMA_CH4_ISR({\cf18 void})\par
01388 \{\par
01389     {\cf20 //}\par
01390     {\cf20 // Insert ISR Code here}\par
01391     {\cf20 //}\par
01392 \par
01393     {\cf20 //}\par
01394     {\cf20 // To receive more interrupts from this PIE group,}\par
01395     {\cf20 // acknowledge this interrupt.}\par
01396     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;}\par
01397     {\cf20 //}\par
01398 \par
01399     {\cf20 //}\par
01400     {\cf20 // Next two lines for debug only to halt the processor here}\par
01401     {\cf20 // Remove after inserting ISR Code}\par
01402     {\cf20 //}\par
01403     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01404     {\cf19 for}(;;);\par
01405 \}\par
01406 \par
01407 {\cf20 //}\par
01408 {\cf20 // 7.5 - DMA Channel 5 Interrupt}\par
01409 {\cf20 //}\par
01410 interrupt {\cf18 void} DMA_CH5_ISR({\cf18 void})\par
01411 \{\par
01412     {\cf20 //}\par
01413     {\cf20 // Insert ISR Code here}\par
01414     {\cf20 //}\par
01415 \par
01416     {\cf20 //}\par
01417     {\cf20 // To receive more interrupts from this PIE group,}\par
01418     {\cf20 // acknowledge this interrupt.}\par
01419     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;}\par
01420     {\cf20 //}\par
01421 \par
01422     {\cf20 //}\par
01423     {\cf20 // Next two lines for debug only to halt the processor here}\par
01424     {\cf20 // Remove after inserting ISR Code}\par
01425     {\cf20 //}\par
01426     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01427     {\cf19 for}(;;);\par
01428 \}\par
01429 \par
01430 {\cf20 //}\par
01431 {\cf20 // 7.6 - DMA Channel 6 Interrupt}\par
01432 {\cf20 //}\par
01433 interrupt {\cf18 void} DMA_CH6_ISR({\cf18 void})\par
01434 \{\par
01435     {\cf20 //}\par
01436     {\cf20 // Insert ISR Code here}\par
01437     {\cf20 //}\par
01438 \par
01439     {\cf20 //}\par
01440     {\cf20 // To receive more interrupts from this PIE group,}\par
01441     {\cf20 // acknowledge this interrupt.}\par
01442     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;}\par
01443     {\cf20 //}\par
01444 \par
01445     {\cf20 //}\par
01446     {\cf20 // Next two lines for debug only to halt the processor here}\par
01447     {\cf20 // Remove after inserting ISR Code}\par
01448     {\cf20 //}\par
01449     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01450     {\cf19 for}(;;);\par
01451 \}\par
01452 \par
01453 {\cf20 //}\par
01454 {\cf20 // 8.1 - I2CA Interrupt 1}\par
01455 {\cf20 //}\par
01456 interrupt {\cf18 void} I2CA_ISR({\cf18 void})\par
01457 \{\par
01458     {\cf20 //}\par
01459     {\cf20 // Insert ISR Code here}\par
01460     {\cf20 //}\par
01461 \par
01462     {\cf20 //}\par
01463     {\cf20 // To receive more interrupts from this PIE group,}\par
01464     {\cf20 // acknowledge this interrupt.}\par
01465     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01466     {\cf20 //}\par
01467 \par
01468     {\cf20 //}\par
01469     {\cf20 // Next two lines for debug only to halt the processor here}\par
01470     {\cf20 // Remove after inserting ISR Code}\par
01471     {\cf20 //}\par
01472     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01473     {\cf19 for}(;;);\par
01474 \}\par
01475 \par
01476 {\cf20 //}\par
01477 {\cf20 // 8.2 - I2CA Interrupt 2}\par
01478 {\cf20 //}\par
01479 interrupt {\cf18 void} I2CA_FIFO_ISR({\cf18 void})\par
01480 \{\par
01481     {\cf20 //}\par
01482     {\cf20 // Insert ISR Code here}\par
01483     {\cf20 //}\par
01484 \par
01485     {\cf20 //}\par
01486     {\cf20 // To receive more interrupts from this PIE group,}\par
01487     {\cf20 // acknowledge this interrupt.}\par
01488     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01489     {\cf20 //}\par
01490 \par
01491     {\cf20 //}\par
01492     {\cf20 // Next two lines for debug only to halt the processor here}\par
01493     {\cf20 // Remove after inserting ISR Code}\par
01494     {\cf20 //}\par
01495     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01496     {\cf19 for}(;;);\par
01497 \}\par
01498 \par
01499 {\cf20 //}\par
01500 {\cf20 // 8.3 - I2CB Interrupt 1}\par
01501 {\cf20 //}\par
01502 interrupt {\cf18 void} I2CB_ISR({\cf18 void})\par
01503 \{\par
01504     {\cf20 //}\par
01505     {\cf20 // Insert ISR Code here}\par
01506     {\cf20 //}\par
01507 \par
01508     {\cf20 //}\par
01509     {\cf20 // To receive more interrupts from this PIE group,}\par
01510     {\cf20 // acknowledge this interrupt.}\par
01511     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01512     {\cf20 //}\par
01513 \par
01514     {\cf20 //}\par
01515     {\cf20 // Next two lines for debug only to halt the processor here}\par
01516     {\cf20 // Remove after inserting ISR Code}\par
01517     {\cf20 //}\par
01518     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01519     {\cf19 for}(;;);\par
01520 \}\par
01521 \par
01522 {\cf20 //}\par
01523 {\cf20 // 8.4 - I2CB Interrupt 2}\par
01524 {\cf20 //}\par
01525 interrupt {\cf18 void} I2CB_FIFO_ISR({\cf18 void})\par
01526 \{\par
01527     {\cf20 //}\par
01528     {\cf20 // Insert ISR Code here}\par
01529     {\cf20 //}\par
01530 \par
01531     {\cf20 //}\par
01532     {\cf20 // To receive more interrupts from this PIE group,}\par
01533     {\cf20 // acknowledge this interrupt.}\par
01534     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01535     {\cf20 //}\par
01536 \par
01537     {\cf20 //}\par
01538     {\cf20 // Next two lines for debug only to halt the processor here}\par
01539     {\cf20 // Remove after inserting ISR Code}\par
01540     {\cf20 //}\par
01541     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01542     {\cf19 for}(;;);\par
01543 \}\par
01544 \par
01545 {\cf20 //}\par
01546 {\cf20 // 8.5 - SCIC Receive Interrupt}\par
01547 {\cf20 //}\par
01548 interrupt {\cf18 void} SCIC_RX_ISR({\cf18 void})\par
01549 \{\par
01550     {\cf20 //}\par
01551     {\cf20 // Insert ISR Code here}\par
01552     {\cf20 //}\par
01553 \par
01554     {\cf20 //}\par
01555     {\cf20 // To receive more interrupts from this PIE group,}\par
01556     {\cf20 // acknowledge this interrupt.}\par
01557     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01558     {\cf20 //}\par
01559 \par
01560     {\cf20 //}\par
01561     {\cf20 // Next two lines for debug only to halt the processor here}\par
01562     {\cf20 // Remove after inserting ISR Code}\par
01563     {\cf20 //}\par
01564     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01565     {\cf19 for}(;;);\par
01566 \}\par
01567 \par
01568 {\cf20 //}\par
01569 {\cf20 // 8.6 - SCIC Transmit Interrupt}\par
01570 {\cf20 //}\par
01571 interrupt {\cf18 void} SCIC_TX_ISR({\cf18 void})\par
01572 \{\par
01573     {\cf20 //}\par
01574     {\cf20 // Insert ISR Code here}\par
01575     {\cf20 //}\par
01576 \par
01577     {\cf20 //}\par
01578     {\cf20 // To receive more interrupts from this PIE group,}\par
01579     {\cf20 // acknowledge this interrupt.}\par
01580     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01581     {\cf20 //}\par
01582 \par
01583     {\cf20 //}\par
01584     {\cf20 // Next two lines for debug only to halt the processor here}\par
01585     {\cf20 // Remove after inserting ISR Code}\par
01586     {\cf20 //}\par
01587     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01588     {\cf19 for}(;;);\par
01589 \}\par
01590 \par
01591 {\cf20 //}\par
01592 {\cf20 // 8.7 - SCID Receive Interrupt}\par
01593 {\cf20 //}\par
01594 interrupt {\cf18 void} SCID_RX_ISR({\cf18 void})\par
01595 \{\par
01596     {\cf20 //}\par
01597     {\cf20 // Insert ISR Code here}\par
01598     {\cf20 //}\par
01599 \par
01600     {\cf20 //}\par
01601     {\cf20 // To receive more interrupts from this PIE group,}\par
01602     {\cf20 // acknowledge this interrupt.}\par
01603     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01604     {\cf20 //}\par
01605 \par
01606     {\cf20 //}\par
01607     {\cf20 // Next two lines for debug only to halt the processor here}\par
01608     {\cf20 // Remove after inserting ISR Code}\par
01609     {\cf20 //}\par
01610     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01611     {\cf19 for}(;;);\par
01612 \}\par
01613 \par
01614 {\cf20 //}\par
01615 {\cf20 // 8.8 - SCID Transmit Interrupt}\par
01616 {\cf20 //}\par
01617 interrupt {\cf18 void} SCID_TX_ISR({\cf18 void})\par
01618 \{\par
01619     {\cf20 //}\par
01620     {\cf20 // Insert ISR Code here}\par
01621     {\cf20 //}\par
01622 \par
01623     {\cf20 //}\par
01624     {\cf20 // To receive more interrupts from this PIE group,}\par
01625     {\cf20 // acknowledge this interrupt.}\par
01626     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
01627     {\cf20 //}\par
01628 \par
01629     {\cf20 //}\par
01630     {\cf20 // Next two lines for debug only to halt the processor here}\par
01631     {\cf20 // Remove after inserting ISR Code}\par
01632     {\cf20 //}\par
01633     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01634     {\cf19 for}(;;);\par
01635 \}\par
01636 \par
01637 {\cf20 //}\par
01638 {\cf20 // 9.1 - SCIA Receive Interrupt}\par
01639 {\cf20 //}\par
01640 interrupt {\cf18 void} SCIA_RX_ISR({\cf18 void})\par
01641 \{\par
01642     {\cf20 //}\par
01643     {\cf20 // Insert ISR Code here}\par
01644     {\cf20 //}\par
01645 \par
01646     {\cf20 //}\par
01647     {\cf20 // To receive more interrupts from this PIE group,}\par
01648     {\cf20 // acknowledge this interrupt.}\par
01649     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01650     {\cf20 //}\par
01651 \par
01652     {\cf20 //}\par
01653     {\cf20 // Next two lines for debug only to halt the processor here}\par
01654     {\cf20 // Remove after inserting ISR Code}\par
01655     {\cf20 //}\par
01656     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01657     {\cf19 for}(;;);\par
01658 \}\par
01659 \par
01660 {\cf20 //}\par
01661 {\cf20 // 9.2 - SCIA Transmit Interrupt}\par
01662 {\cf20 //}\par
01663 interrupt {\cf18 void} SCIA_TX_ISR({\cf18 void})\par
01664 \{\par
01665     {\cf20 //}\par
01666     {\cf20 // Insert ISR Code here}\par
01667     {\cf20 //}\par
01668 \par
01669     {\cf20 //}\par
01670     {\cf20 // To receive more interrupts from this PIE group,}\par
01671     {\cf20 // acknowledge this interrupt.}\par
01672     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01673     {\cf20 //}\par
01674 \par
01675     {\cf20 //}\par
01676     {\cf20 // Next two lines for debug only to halt the processor here}\par
01677     {\cf20 // Remove after inserting ISR Code}\par
01678     {\cf20 //}\par
01679     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01680     {\cf19 for}(;;);\par
01681 \}\par
01682 \par
01683 {\cf20 //}\par
01684 {\cf20 // 9.3 - SCIB Receive Interrupt}\par
01685 {\cf20 //}\par
01686 interrupt {\cf18 void} SCIB_RX_ISR({\cf18 void})\par
01687 \{\par
01688     {\cf20 //}\par
01689     {\cf20 // Insert ISR Code here}\par
01690     {\cf20 //}\par
01691 \par
01692     {\cf20 //}\par
01693     {\cf20 // To receive more interrupts from this PIE group,}\par
01694     {\cf20 // acknowledge this interrupt.}\par
01695     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01696     {\cf20 //}\par
01697 \par
01698     {\cf20 //}\par
01699     {\cf20 // Next two lines for debug only to halt the processor here}\par
01700     {\cf20 // Remove after inserting ISR Code}\par
01701     {\cf20 //}\par
01702     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01703     {\cf19 for}(;;);\par
01704 \}\par
01705 \par
01706 {\cf20 //}\par
01707 {\cf20 // 9.4 - SCIB Transmit Interrupt}\par
01708 {\cf20 //}\par
01709 interrupt {\cf18 void} SCIB_TX_ISR({\cf18 void})\par
01710 \{\par
01711     {\cf20 //}\par
01712     {\cf20 // Insert ISR Code here}\par
01713     {\cf20 //}\par
01714 \par
01715     {\cf20 //}\par
01716     {\cf20 // To receive more interrupts from this PIE group,}\par
01717     {\cf20 // acknowledge this interrupt.}\par
01718     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01719     {\cf20 //}\par
01720 \par
01721     {\cf20 //}\par
01722     {\cf20 // Next two lines for debug only to halt the processor here}\par
01723     {\cf20 // Remove after inserting ISR Code}\par
01724     {\cf20 //}\par
01725     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01726     {\cf19 for}(;;);\par
01727 \}\par
01728 \par
01729 {\cf20 //}\par
01730 {\cf20 // 9.5 - CANA Interrupt 0}\par
01731 {\cf20 //}\par
01732 interrupt {\cf18 void} CANA0_ISR({\cf18 void})\par
01733 \{\par
01734     {\cf20 //}\par
01735     {\cf20 // Insert ISR Code here}\par
01736     {\cf20 //}\par
01737 \par
01738     {\cf20 //}\par
01739     {\cf20 // To receive more interrupts from this PIE group,}\par
01740     {\cf20 // acknowledge this interrupt.}\par
01741     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01742     {\cf20 //}\par
01743 \par
01744     {\cf20 //}\par
01745     {\cf20 // Next two lines for debug only to halt the processor here}\par
01746     {\cf20 // Remove after inserting ISR Code}\par
01747     {\cf20 //}\par
01748     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01749     {\cf19 for}(;;);\par
01750 \}\par
01751 \par
01752 {\cf20 //}\par
01753 {\cf20 // 9.6 - CANA Interrupt 1}\par
01754 {\cf20 //}\par
01755 interrupt {\cf18 void} CANA1_ISR({\cf18 void})\par
01756 \{\par
01757     {\cf20 //}\par
01758     {\cf20 // Insert ISR Code here}\par
01759     {\cf20 //}\par
01760 \par
01761     {\cf20 //}\par
01762     {\cf20 // To receive more interrupts from this PIE group,}\par
01763     {\cf20 // acknowledge this interrupt.}\par
01764     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01765     {\cf20 //}\par
01766 \par
01767     {\cf20 //}\par
01768     {\cf20 // Next two lines for debug only to halt the processor here}\par
01769     {\cf20 // Remove after inserting ISR Code}\par
01770     {\cf20 //}\par
01771     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01772     {\cf19 for}(;;);\par
01773 \}\par
01774 \par
01775 {\cf20 //}\par
01776 {\cf20 // 9.7 - CANB Interrupt 0}\par
01777 {\cf20 //}\par
01778 interrupt {\cf18 void} CANB0_ISR({\cf18 void})\par
01779 \{\par
01780     {\cf20 //}\par
01781     {\cf20 // Insert ISR Code here}\par
01782     {\cf20 //}\par
01783 \par
01784     {\cf20 //}\par
01785     {\cf20 // To receive more interrupts from this PIE group,}\par
01786     {\cf20 // acknowledge this interrupt.}\par
01787     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01788     {\cf20 //}\par
01789 \par
01790     {\cf20 //}\par
01791     {\cf20 // Next two lines for debug only to halt the processor here}\par
01792     {\cf20 // Remove after inserting ISR Code}\par
01793     {\cf20 //}\par
01794     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01795     {\cf19 for}(;;);\par
01796 \}\par
01797 \par
01798 {\cf20 //}\par
01799 {\cf20 // 9.8 - CANB Interrupt 1}\par
01800 {\cf20 //}\par
01801 interrupt {\cf18 void} CANB1_ISR({\cf18 void})\par
01802 \{\par
01803     {\cf20 //}\par
01804     {\cf20 // Insert ISR Code here}\par
01805     {\cf20 //}\par
01806 \par
01807     {\cf20 //}\par
01808     {\cf20 // To receive more interrupts from this PIE group,}\par
01809     {\cf20 // acknowledge this interrupt.}\par
01810     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
01811     {\cf20 //}\par
01812 \par
01813     {\cf20 //}\par
01814     {\cf20 // Next two lines for debug only to halt the processor here}\par
01815     {\cf20 // Remove after inserting ISR Code}\par
01816     {\cf20 //}\par
01817     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01818     {\cf19 for}(;;);\par
01819 \}\par
01820 \par
01821 {\cf20 //}\par
01822 {\cf20 // 10.1 - ADCA Event Interrupt}\par
01823 {\cf20 //}\par
01824 interrupt {\cf18 void} ADCA_EVT_ISR({\cf18 void})\par
01825 \{\par
01826     {\cf20 //}\par
01827     {\cf20 // Insert ISR Code here}\par
01828     {\cf20 //}\par
01829 \par
01830     {\cf20 //}\par
01831     {\cf20 // To receive more interrupts from this PIE group,}\par
01832     {\cf20 // acknowledge this interrupt.}\par
01833     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01834     {\cf20 //}\par
01835 \par
01836     {\cf20 //}\par
01837     {\cf20 // Next two lines for debug only to halt the processor here}\par
01838     {\cf20 // Remove after inserting ISR Code}\par
01839     {\cf20 //}\par
01840     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01841     {\cf19 for}(;;);\par
01842 \}\par
01843 \par
01844 {\cf20 //}\par
01845 {\cf20 // 10.2 - ADCA Interrupt 2}\par
01846 {\cf20 //}\par
01847 interrupt {\cf18 void} ADCA2_ISR({\cf18 void})\par
01848 \{\par
01849     {\cf20 //}\par
01850     {\cf20 // Insert ISR Code here}\par
01851     {\cf20 //}\par
01852 \par
01853     {\cf20 //}\par
01854     {\cf20 // To receive more interrupts from this PIE group,}\par
01855     {\cf20 // acknowledge this interrupt.}\par
01856     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01857     {\cf20 //}\par
01858 \par
01859     {\cf20 //}\par
01860     {\cf20 // Next two lines for debug only to halt the processor here}\par
01861     {\cf20 // Remove after inserting ISR Code}\par
01862     {\cf20 //}\par
01863     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01864     {\cf19 for}(;;);\par
01865 \}\par
01866 \par
01867 {\cf20 //}\par
01868 {\cf20 // 10.3 - ADCA Interrupt 3}\par
01869 {\cf20 //}\par
01870 interrupt {\cf18 void} ADCA3_ISR({\cf18 void})\par
01871 \{\par
01872     {\cf20 //}\par
01873     {\cf20 // Insert ISR Code here}\par
01874     {\cf20 //}\par
01875 \par
01876     {\cf20 //}\par
01877     {\cf20 // To receive more interrupts from this PIE group,}\par
01878     {\cf20 // acknowledge this interrupt.}\par
01879     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01880     {\cf20 //}\par
01881 \par
01882     {\cf20 //}\par
01883     {\cf20 // Next two lines for debug only to halt the processor here}\par
01884     {\cf20 // Remove after inserting ISR Code}\par
01885     {\cf20 //}\par
01886     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01887     {\cf19 for}(;;);\par
01888 \}\par
01889 \par
01890 {\cf20 //}\par
01891 {\cf20 // 10.4 - ADCA Interrupt 4}\par
01892 {\cf20 //}\par
01893 interrupt {\cf18 void} ADCA4_ISR({\cf18 void})\par
01894 \{\par
01895     {\cf20 //}\par
01896     {\cf20 // Insert ISR Code here}\par
01897     {\cf20 //}\par
01898 \par
01899     {\cf20 //}\par
01900     {\cf20 // To receive more interrupts from this PIE group,}\par
01901     {\cf20 // acknowledge this interrupt.}\par
01902     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01903     {\cf20 //}\par
01904 \par
01905     {\cf20 //}\par
01906     {\cf20 // Next two lines for debug only to halt the processor here}\par
01907     {\cf20 // Remove after inserting ISR Code}\par
01908     {\cf20 //}\par
01909     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01910     {\cf19 for}(;;);\par
01911 \}\par
01912 \par
01913 {\cf20 //}\par
01914 {\cf20 // 10.5 - ADCB Event Interrupt}\par
01915 {\cf20 //}\par
01916 interrupt {\cf18 void} ADCB_EVT_ISR({\cf18 void})\par
01917 \{\par
01918     {\cf20 //}\par
01919     {\cf20 // Insert ISR Code here}\par
01920     {\cf20 //}\par
01921 \par
01922     {\cf20 //}\par
01923     {\cf20 // To receive more interrupts from this PIE group,}\par
01924     {\cf20 // acknowledge this interrupt.}\par
01925     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01926     {\cf20 //}\par
01927 \par
01928     {\cf20 //}\par
01929     {\cf20 // Next two lines for debug only to halt the processor here}\par
01930     {\cf20 // Remove after inserting ISR Code}\par
01931     {\cf20 //}\par
01932     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01933     {\cf19 for}(;;);\par
01934 \}\par
01935 \par
01936 {\cf20 //}\par
01937 {\cf20 // 10.6 - ADCB Interrupt 2}\par
01938 {\cf20 //}\par
01939 interrupt {\cf18 void} ADCB2_ISR({\cf18 void})\par
01940 \{\par
01941     {\cf20 //}\par
01942     {\cf20 // Insert ISR Code here}\par
01943     {\cf20 //}\par
01944 \par
01945     {\cf20 //}\par
01946     {\cf20 // To receive more interrupts from this PIE group,}\par
01947     {\cf20 // acknowledge this interrupt.}\par
01948     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01949     {\cf20 //}\par
01950 \par
01951     {\cf20 //}\par
01952     {\cf20 // Next two lines for debug only to halt the processor here}\par
01953     {\cf20 // Remove after inserting ISR Code}\par
01954     {\cf20 //}\par
01955     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01956     {\cf19 for}(;;);\par
01957 \}\par
01958 \par
01959 {\cf20 //}\par
01960 {\cf20 // 10.7 - ADCB Interrupt 3}\par
01961 {\cf20 //}\par
01962 interrupt {\cf18 void} ADCB3_ISR({\cf18 void})\par
01963 \{\par
01964     {\cf20 //}\par
01965     {\cf20 // Insert ISR Code here}\par
01966     {\cf20 //}\par
01967 \par
01968     {\cf20 //}\par
01969     {\cf20 // To receive more interrupts from this PIE group,}\par
01970     {\cf20 // acknowledge this interrupt.}\par
01971     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01972     {\cf20 //}\par
01973 \par
01974     {\cf20 //}\par
01975     {\cf20 // Next two lines for debug only to halt the processor here}\par
01976     {\cf20 // Remove after inserting ISR Code}\par
01977     {\cf20 //}\par
01978     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
01979     {\cf19 for}(;;);\par
01980 \}\par
01981 \par
01982 {\cf20 //}\par
01983 {\cf20 // 10.8 - ADCB Interrupt 4}\par
01984 {\cf20 //}\par
01985 interrupt {\cf18 void} ADCB4_ISR({\cf18 void})\par
01986 \{\par
01987     {\cf20 //}\par
01988     {\cf20 // Insert ISR Code here}\par
01989     {\cf20 //}\par
01990 \par
01991     {\cf20 //}\par
01992     {\cf20 // To receive more interrupts from this PIE group,}\par
01993     {\cf20 // acknowledge this interrupt.}\par
01994     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
01995     {\cf20 //}\par
01996 \par
01997     {\cf20 //}\par
01998     {\cf20 // Next two lines for debug only to halt the processor here}\par
01999     {\cf20 // Remove after inserting ISR Code}\par
02000     {\cf20 //}\par
02001     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02002     {\cf19 for}(;;);\par
02003 \}\par
02004 \par
02005 {\cf20 //}\par
02006 {\cf20 // 11.1 - CLA1 Interrupt 1}\par
02007 {\cf20 //}\par
02008 interrupt {\cf18 void} CLA1_1_ISR({\cf18 void})\par
02009 \{\par
02010     {\cf20 //}\par
02011     {\cf20 // Insert ISR Code here}\par
02012     {\cf20 //}\par
02013 \par
02014     {\cf20 //}\par
02015     {\cf20 // To receive more interrupts from this PIE group,}\par
02016     {\cf20 // acknowledge this interrupt.}\par
02017     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02018     {\cf20 //}\par
02019 \par
02020     {\cf20 //}\par
02021     {\cf20 // Next two lines for debug only to halt the processor here}\par
02022     {\cf20 // Remove after inserting ISR Code}\par
02023     {\cf20 //}\par
02024     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02025     {\cf19 for}(;;);\par
02026 \}\par
02027 \par
02028 {\cf20 //}\par
02029 {\cf20 // 11.2 - CLA1 Interrupt 2}\par
02030 {\cf20 //}\par
02031 interrupt {\cf18 void} CLA1_2_ISR({\cf18 void})\par
02032 \{\par
02033     {\cf20 //}\par
02034     {\cf20 // Insert ISR Code here}\par
02035     {\cf20 //}\par
02036 \par
02037     {\cf20 //}\par
02038     {\cf20 // To receive more interrupts from this PIE group,}\par
02039     {\cf20 // acknowledge this interrupt.}\par
02040     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02041     {\cf20 //}\par
02042 \par
02043     {\cf20 //}\par
02044     {\cf20 // Next two lines for debug only to halt the processor here}\par
02045     {\cf20 // Remove after inserting ISR Code}\par
02046     {\cf20 //}\par
02047     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02048     {\cf19 for}(;;);\par
02049 \}\par
02050 \par
02051 {\cf20 //}\par
02052 {\cf20 // 11.3 - CLA1 Interrupt 3}\par
02053 {\cf20 //}\par
02054 interrupt {\cf18 void} CLA1_3_ISR({\cf18 void})\par
02055 \{\par
02056     {\cf20 //}\par
02057     {\cf20 // Insert ISR Code here}\par
02058     {\cf20 //}\par
02059 \par
02060     {\cf20 //}\par
02061     {\cf20 // To receive more interrupts from this PIE group,}\par
02062     {\cf20 // acknowledge this interrupt.}\par
02063     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02064     {\cf20 //}\par
02065 \par
02066     {\cf20 //}\par
02067     {\cf20 // Next two lines for debug only to halt the processor here}\par
02068     {\cf20 // Remove after inserting ISR Code}\par
02069     {\cf20 //}\par
02070     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02071     {\cf19 for}(;;);\par
02072 \}\par
02073 \par
02074 {\cf20 //}\par
02075 {\cf20 // 11.4 - CLA1 Interrupt 4}\par
02076 {\cf20 //}\par
02077 interrupt {\cf18 void} CLA1_4_ISR({\cf18 void})\par
02078 \{\par
02079     {\cf20 //}\par
02080     {\cf20 // Insert ISR Code here}\par
02081     {\cf20 //}\par
02082 \par
02083     {\cf20 //}\par
02084     {\cf20 // To receive more interrupts from this PIE group,}\par
02085     {\cf20 // acknowledge this interrupt.}\par
02086     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02087     {\cf20 //}\par
02088 \par
02089     {\cf20 //}\par
02090     {\cf20 // Next two lines for debug only to halt the processor here}\par
02091     {\cf20 // Remove after inserting ISR Code}\par
02092     {\cf20 //}\par
02093     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02094     {\cf19 for}(;;);\par
02095 \}\par
02096 \par
02097 {\cf20 //}\par
02098 {\cf20 // 11.5 - CLA1 Interrupt 5}\par
02099 {\cf20 //}\par
02100 interrupt {\cf18 void} CLA1_5_ISR({\cf18 void})\par
02101 \{\par
02102     {\cf20 //}\par
02103     {\cf20 // Insert ISR Code here}\par
02104     {\cf20 //}\par
02105 \par
02106     {\cf20 //}\par
02107     {\cf20 // To receive more interrupts from this PIE group,}\par
02108     {\cf20 // acknowledge this interrupt.}\par
02109     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02110     {\cf20 //}\par
02111 \par
02112     {\cf20 //}\par
02113     {\cf20 // Next two lines for debug only to halt the processor here}\par
02114     {\cf20 // Remove after inserting ISR Code}\par
02115     {\cf20 //}\par
02116     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02117     {\cf19 for}(;;);\par
02118 \}\par
02119 \par
02120 {\cf20 //}\par
02121 {\cf20 // 11.6 - CLA1 Interrupt 6}\par
02122 {\cf20 //}\par
02123 interrupt {\cf18 void} CLA1_6_ISR({\cf18 void})\par
02124 \{\par
02125     {\cf20 //}\par
02126     {\cf20 // Insert ISR Code here}\par
02127     {\cf20 //}\par
02128 \par
02129     {\cf20 //}\par
02130     {\cf20 // To receive more interrupts from this PIE group,}\par
02131     {\cf20 // acknowledge this interrupt.}\par
02132     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02133     {\cf20 //}\par
02134 \par
02135     {\cf20 //}\par
02136     {\cf20 // Next two lines for debug only to halt the processor here}\par
02137     {\cf20 // Remove after inserting ISR Code}\par
02138     {\cf20 //}\par
02139     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02140     {\cf19 for}(;;);\par
02141 \}\par
02142 \par
02143 {\cf20 //}\par
02144 {\cf20 // 11.7 - CLA1 Interrupt 7}\par
02145 {\cf20 //}\par
02146 interrupt {\cf18 void} CLA1_7_ISR({\cf18 void})\par
02147 \{\par
02148     {\cf20 //}\par
02149     {\cf20 // Insert ISR Code here}\par
02150     {\cf20 //}\par
02151 \par
02152     {\cf20 //}\par
02153     {\cf20 // To receive more interrupts from this PIE group,}\par
02154     {\cf20 // acknowledge this interrupt.}\par
02155     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02156     {\cf20 //}\par
02157 \par
02158     {\cf20 //}\par
02159     {\cf20 // Next two lines for debug only to halt the processor here}\par
02160     {\cf20 // Remove after inserting ISR Code}\par
02161     {\cf20 //}\par
02162     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02163     {\cf19 for}(;;);\par
02164 \}\par
02165 \par
02166 {\cf20 //}\par
02167 {\cf20 // 11.8 - CLA1 Interrupt 8}\par
02168 {\cf20 //}\par
02169 interrupt {\cf18 void} CLA1_8_ISR({\cf18 void})\par
02170 \{\par
02171     {\cf20 //}\par
02172     {\cf20 // Insert ISR Code here}\par
02173     {\cf20 //}\par
02174 \par
02175     {\cf20 //}\par
02176     {\cf20 // To receive more interrupts from this PIE group,}\par
02177     {\cf20 // acknowledge this interrupt.}\par
02178     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;}\par
02179     {\cf20 //}\par
02180 \par
02181     {\cf20 //}\par
02182     {\cf20 // Next two lines for debug only to halt the processor here}\par
02183     {\cf20 // Remove after inserting ISR Code}\par
02184     {\cf20 //}\par
02185     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02186     {\cf19 for}(;;);\par
02187 \}\par
02188 \par
02189 {\cf20 //}\par
02190 {\cf20 // 12.1 - XINT3 Interrupt}\par
02191 {\cf20 //}\par
02192 interrupt {\cf18 void} XINT3_ISR({\cf18 void})\par
02193 \{\par
02194     {\cf20 //}\par
02195     {\cf20 // Insert ISR Code here}\par
02196     {\cf20 //}\par
02197 \par
02198     {\cf20 //}\par
02199     {\cf20 // To receive more interrupts from this PIE group,}\par
02200     {\cf20 // acknowledge this interrupt.}\par
02201     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02202     {\cf20 //}\par
02203 \par
02204     {\cf20 //}\par
02205     {\cf20 // Next two lines for debug only to halt the processor here}\par
02206     {\cf20 // Remove after inserting ISR Code}\par
02207     {\cf20 //}\par
02208     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02209     {\cf19 for}(;;);\par
02210 \}\par
02211 \par
02212 {\cf20 //}\par
02213 {\cf20 // 12.2 - XINT4 Interrupt}\par
02214 {\cf20 //}\par
02215 interrupt {\cf18 void} XINT4_ISR({\cf18 void})\par
02216 \{\par
02217     {\cf20 //}\par
02218     {\cf20 // Insert ISR Code here}\par
02219     {\cf20 //}\par
02220 \par
02221     {\cf20 //}\par
02222     {\cf20 // To receive more interrupts from this PIE group,}\par
02223     {\cf20 // acknowledge this interrupt.}\par
02224     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02225     {\cf20 //}\par
02226 \par
02227     {\cf20 //}\par
02228     {\cf20 // Next two lines for debug only to halt the processor here}\par
02229     {\cf20 // Remove after inserting ISR Code}\par
02230     {\cf20 //}\par
02231     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02232     {\cf19 for}(;;);\par
02233 \}\par
02234 \par
02235 {\cf20 //}\par
02236 {\cf20 // 12.3 - XINT5 Interrupt}\par
02237 {\cf20 //}\par
02238 interrupt {\cf18 void} XINT5_ISR({\cf18 void})\par
02239 \{\par
02240     {\cf20 //}\par
02241     {\cf20 // Insert ISR Code here}\par
02242     {\cf20 //}\par
02243 \par
02244     {\cf20 //}\par
02245     {\cf20 // To receive more interrupts from this PIE group,}\par
02246     {\cf20 // acknowledge this interrupt.}\par
02247     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02248     {\cf20 //}\par
02249 \par
02250     {\cf20 //}\par
02251     {\cf20 // Next two lines for debug only to halt the processor here}\par
02252     {\cf20 // Remove after inserting ISR Code}\par
02253     {\cf20 //}\par
02254     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02255     {\cf19 for}(;;);\par
02256 \}\par
02257 \par
02258 {\cf20 //}\par
02259 {\cf20 // 12.6 - VCU Interrupt}\par
02260 {\cf20 //}\par
02261 interrupt {\cf18 void} VCU_ISR({\cf18 void})\par
02262 \{\par
02263     {\cf20 //}\par
02264     {\cf20 // Insert ISR Code here}\par
02265     {\cf20 //}\par
02266 \par
02267     {\cf20 //}\par
02268     {\cf20 // To receive more interrupts from this PIE group,}\par
02269     {\cf20 // acknowledge this interrupt.}\par
02270     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02271     {\cf20 //}\par
02272 \par
02273     {\cf20 //}\par
02274     {\cf20 // Next two lines for debug only to halt the processor here}\par
02275     {\cf20 // Remove after inserting ISR Code}\par
02276     {\cf20 //}\par
02277     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02278     {\cf19 for}(;;);\par
02279 \}\par
02280 \par
02281 {\cf20 //}\par
02282 {\cf20 // 12.7 - FPU Overflow Interrupt}\par
02283 {\cf20 //}\par
02284 interrupt {\cf18 void} FPU_OVERFLOW_ISR({\cf18 void})\par
02285 \{\par
02286     {\cf20 //}\par
02287     {\cf20 // Insert ISR Code here}\par
02288     {\cf20 //}\par
02289 \par
02290     {\cf20 //}\par
02291     {\cf20 // To receive more interrupts from this PIE group,}\par
02292     {\cf20 // acknowledge this interrupt.}\par
02293     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02294     {\cf20 //}\par
02295 \par
02296     {\cf20 //}\par
02297     {\cf20 // Next two lines for debug only to halt the processor here}\par
02298     {\cf20 // Remove after inserting ISR Code}\par
02299     {\cf20 //}\par
02300     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02301     {\cf19 for}(;;);\par
02302 \}\par
02303 \par
02304 {\cf20 //}\par
02305 {\cf20 // 12.8 - FPU Underflow Interrupt}\par
02306 {\cf20 //}\par
02307 interrupt {\cf18 void} FPU_UNDERFLOW_ISR({\cf18 void})\par
02308 \{\par
02309     {\cf20 //}\par
02310     {\cf20 // Insert ISR Code here}\par
02311     {\cf20 //}\par
02312 \par
02313     {\cf20 //}\par
02314     {\cf20 // To receive more interrupts from this PIE group,}\par
02315     {\cf20 // acknowledge this interrupt.}\par
02316     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02317     {\cf20 //}\par
02318 \par
02319     {\cf20 //}\par
02320     {\cf20 // Next two lines for debug only to halt the processor here}\par
02321     {\cf20 // Remove after inserting ISR Code}\par
02322     {\cf20 //}\par
02323     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02324     {\cf19 for}(;;);\par
02325 \}\par
02326 \par
02327 {\cf20 //}\par
02328 {\cf20 // 1.13 - IPC Interrupt 0}\par
02329 {\cf20 //}\par
02330 interrupt {\cf18 void} IPC0_ISR({\cf18 void})\par
02331 \{\par
02332     {\cf20 //}\par
02333     {\cf20 // Insert ISR Code here}\par
02334     {\cf20 //}\par
02335 \par
02336     {\cf20 //}\par
02337     {\cf20 // To receive more interrupts from this PIE group,}\par
02338     {\cf20 // acknowledge this interrupt.}\par
02339     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
02340     {\cf20 //}\par
02341 \par
02342     {\cf20 //}\par
02343     {\cf20 // Next two lines for debug only to halt the processor here}\par
02344     {\cf20 // Remove after inserting ISR Code}\par
02345     {\cf20 //}\par
02346     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02347     {\cf19 for}(;;);\par
02348 \}\par
02349 \par
02350 {\cf20 //}\par
02351 {\cf20 // 1.14 - IPC Interrupt 1}\par
02352 {\cf20 //}\par
02353 interrupt {\cf18 void} IPC1_ISR({\cf18 void})\par
02354 \{\par
02355     {\cf20 //}\par
02356     {\cf20 // Insert ISR Code here}\par
02357     {\cf20 //}\par
02358 \par
02359     {\cf20 //}\par
02360     {\cf20 // To receive more interrupts from this PIE group,}\par
02361     {\cf20 // acknowledge this interrupt.}\par
02362     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
02363     {\cf20 //}\par
02364 \par
02365     {\cf20 //}\par
02366     {\cf20 // Next two lines for debug only to halt the processor here}\par
02367     {\cf20 // Remove after inserting ISR Code}\par
02368     {\cf20 //}\par
02369     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02370     {\cf19 for}(;;);\par
02371 \}\par
02372 \par
02373 {\cf20 //}\par
02374 {\cf20 // 1.15 - IPC Interrupt 2}\par
02375 {\cf20 //}\par
02376 interrupt {\cf18 void} IPC2_ISR({\cf18 void})\par
02377 \{\par
02378     {\cf20 //}\par
02379     {\cf20 // Insert ISR Code here}\par
02380     {\cf20 //}\par
02381 \par
02382     {\cf20 //}\par
02383     {\cf20 // To receive more interrupts from this PIE group,}\par
02384     {\cf20 // acknowledge this interrupt.}\par
02385     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
02386     {\cf20 //}\par
02387 \par
02388     {\cf20 //}\par
02389     {\cf20 // Next two lines for debug only to halt the processor here}\par
02390     {\cf20 // Remove after inserting ISR Code}\par
02391     {\cf20 //}\par
02392     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02393     {\cf19 for}(;;);\par
02394 \}\par
02395 \par
02396 {\cf20 //}\par
02397 {\cf20 // 1.16 - IPC Interrupt 3}\par
02398 {\cf20 //}\par
02399 interrupt {\cf18 void} IPC3_ISR({\cf18 void})\par
02400 \{\par
02401     {\cf20 //}\par
02402     {\cf20 // Insert ISR Code here}\par
02403     {\cf20 //}\par
02404 \par
02405     {\cf20 //}\par
02406     {\cf20 // To receive more interrupts from this PIE group,}\par
02407     {\cf20 // acknowledge this interrupt.}\par
02408     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;}\par
02409     {\cf20 //}\par
02410 \par
02411     {\cf20 //}\par
02412     {\cf20 // Next two lines for debug only to halt the processor here}\par
02413     {\cf20 // Remove after inserting ISR Code}\par
02414     {\cf20 //}\par
02415     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02416     {\cf19 for}(;;);\par
02417 \}\par
02418 \par
02419 {\cf20 //}\par
02420 {\cf20 // 2.9 - ePWM9 Trip Zone Interrupt}\par
02421 {\cf20 //}\par
02422 interrupt {\cf18 void} EPWM9_TZ_ISR({\cf18 void})\par
02423 \{\par
02424     {\cf20 //}\par
02425     {\cf20 // Insert ISR Code here}\par
02426     {\cf20 //}\par
02427 \par
02428     {\cf20 //}\par
02429     {\cf20 // To receive more interrupts from this PIE group,}\par
02430     {\cf20 // acknowledge this interrupt.}\par
02431     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
02432     {\cf20 //}\par
02433 \par
02434     {\cf20 //}\par
02435     {\cf20 // Next two lines for debug only to halt the processor here}\par
02436     {\cf20 // Remove after inserting ISR Code}\par
02437     {\cf20 //}\par
02438     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02439     {\cf19 for}(;;);\par
02440 \}\par
02441 \par
02442 {\cf20 //}\par
02443 {\cf20 // 2.10 - ePWM10 Trip Zone Interrupt}\par
02444 {\cf20 //}\par
02445 interrupt {\cf18 void} EPWM10_TZ_ISR({\cf18 void})\par
02446 \{\par
02447     {\cf20 //}\par
02448     {\cf20 // Insert ISR Code here}\par
02449     {\cf20 //}\par
02450 \par
02451     {\cf20 //}\par
02452     {\cf20 // To receive more interrupts from this PIE group,}\par
02453     {\cf20 // acknowledge this interrupt.}\par
02454     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
02455     {\cf20 //}\par
02456 \par
02457     {\cf20 //}\par
02458     {\cf20 // Next two lines for debug only to halt the processor here}\par
02459     {\cf20 // Remove after inserting ISR Code}\par
02460     {\cf20 //}\par
02461     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02462     {\cf19 for}(;;);\par
02463 \}\par
02464 \par
02465 {\cf20 //}\par
02466 {\cf20 // 2.11 - ePWM11 Trip Zone Interrupt}\par
02467 {\cf20 //}\par
02468 interrupt {\cf18 void} EPWM11_TZ_ISR({\cf18 void})\par
02469 \{\par
02470     {\cf20 //}\par
02471     {\cf20 // Insert ISR Code here}\par
02472     {\cf20 //}\par
02473 \par
02474     {\cf20 //}\par
02475     {\cf20 // To receive more interrupts from this PIE group,}\par
02476     {\cf20 // acknowledge this interrupt.}\par
02477     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
02478     {\cf20 //}\par
02479 \par
02480     {\cf20 //}\par
02481     {\cf20 // Next two lines for debug only to halt the processor here}\par
02482     {\cf20 // Remove after inserting ISR Code}\par
02483     {\cf20 //}\par
02484     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02485     {\cf19 for}(;;);\par
02486 \}\par
02487 \par
02488 {\cf20 //}\par
02489 {\cf20 // 2.12 - ePWM12 Trip Zone Interrupt}\par
02490 {\cf20 //}\par
02491 interrupt {\cf18 void} EPWM12_TZ_ISR({\cf18 void})\par
02492 \{\par
02493     {\cf20 //}\par
02494     {\cf20 // Insert ISR Code here}\par
02495     {\cf20 //}\par
02496 \par
02497     {\cf20 //}\par
02498     {\cf20 // To receive more interrupts from this PIE group,}\par
02499     {\cf20 // acknowledge this interrupt.}\par
02500     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;}\par
02501     {\cf20 //}\par
02502 \par
02503     {\cf20 //}\par
02504     {\cf20 // Next two lines for debug only to halt the processor here}\par
02505     {\cf20 // Remove after inserting ISR Code}\par
02506     {\cf20 //}\par
02507     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02508     {\cf19 for}(;;);\par
02509 \}\par
02510 \par
02511 {\cf20 //}\par
02512 {\cf20 // 3.9 - ePWM9 Interrupt}\par
02513 {\cf20 //}\par
02514 interrupt {\cf18 void} EPWM9_ISR({\cf18 void})\par
02515 \{\par
02516     {\cf20 //}\par
02517     {\cf20 // Insert ISR Code here}\par
02518     {\cf20 //}\par
02519 \par
02520     {\cf20 //}\par
02521     {\cf20 // To receive more interrupts from this PIE group,}\par
02522     {\cf20 // acknowledge this interrupt.}\par
02523     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
02524     {\cf20 //}\par
02525 \par
02526     {\cf20 //}\par
02527     {\cf20 // Next two lines for debug only to halt the processor here}\par
02528     {\cf20 // Remove after inserting ISR Code}\par
02529     {\cf20 //}\par
02530     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02531     {\cf19 for}(;;);\par
02532 \}\par
02533 \par
02534 {\cf20 //}\par
02535 {\cf20 // 3.10 - ePWM10 Interrupt}\par
02536 {\cf20 //}\par
02537 interrupt {\cf18 void} EPWM10_ISR({\cf18 void})\par
02538 \{\par
02539     {\cf20 //}\par
02540     {\cf20 // Insert ISR Code here}\par
02541     {\cf20 //}\par
02542 \par
02543     {\cf20 //}\par
02544     {\cf20 // To receive more interrupts from this PIE group,}\par
02545     {\cf20 // acknowledge this interrupt.}\par
02546     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
02547     {\cf20 //}\par
02548 \par
02549     {\cf20 //}\par
02550     {\cf20 // Next two lines for debug only to halt the processor here}\par
02551     {\cf20 // Remove after inserting ISR Code}\par
02552     {\cf20 //}\par
02553     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02554     {\cf19 for}(;;);\par
02555 \}\par
02556 \par
02557 {\cf20 //}\par
02558 {\cf20 // 3.11 - ePWM11 Interrupt}\par
02559 {\cf20 //}\par
02560 interrupt {\cf18 void} EPWM11_ISR({\cf18 void})\par
02561 \{\par
02562     {\cf20 //}\par
02563     {\cf20 // Insert ISR Code here}\par
02564     {\cf20 //}\par
02565 \par
02566     {\cf20 //}\par
02567     {\cf20 // To receive more interrupts from this PIE group,}\par
02568     {\cf20 // acknowledge this interrupt.}\par
02569     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
02570     {\cf20 //}\par
02571 \par
02572     {\cf20 //}\par
02573     {\cf20 // Next two lines for debug only to halt the processor here}\par
02574     {\cf20 // Remove after inserting ISR Code}\par
02575     {\cf20 //}\par
02576     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02577     {\cf19 for}(;;);\par
02578 \}\par
02579 \par
02580 {\cf20 //}\par
02581 {\cf20 // 3.12 - ePWM12 Interrupt}\par
02582 {\cf20 //}\par
02583 interrupt {\cf18 void} EPWM12_ISR({\cf18 void})\par
02584 \{\par
02585     {\cf20 //}\par
02586     {\cf20 // Insert ISR Code here}\par
02587     {\cf20 //}\par
02588 \par
02589     {\cf20 //}\par
02590     {\cf20 // To receive more interrupts from this PIE group,}\par
02591     {\cf20 // acknowledge this interrupt.}\par
02592     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;}\par
02593     {\cf20 //}\par
02594 \par
02595     {\cf20 //}\par
02596     {\cf20 // Next two lines for debug only to halt the processor here}\par
02597     {\cf20 // Remove after inserting ISR Code}\par
02598     {\cf20 //}\par
02599     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02600     {\cf19 for}(;;);\par
02601 \}\par
02602 \par
02603 {\cf20 //}\par
02604 {\cf20 // 5.9 - SD1 Interrupt}\par
02605 {\cf20 //}\par
02606 interrupt {\cf18 void} SD1_ISR({\cf18 void})\par
02607 \{\par
02608     {\cf20 //}\par
02609     {\cf20 // Insert ISR Code here}\par
02610     {\cf20 //}\par
02611 \par
02612     {\cf20 //}\par
02613     {\cf20 // To receive more interrupts from this PIE group,}\par
02614     {\cf20 // acknowledge this interrupt.}\par
02615     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;}\par
02616     {\cf20 //}\par
02617 \par
02618     {\cf20 //}\par
02619     {\cf20 // Next two lines for debug only to halt the processor here}\par
02620     {\cf20 // Remove after inserting ISR Code}\par
02621     {\cf20 //}\par
02622     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02623     {\cf19 for}(;;);\par
02624 \}\par
02625 \par
02626 {\cf20 //}\par
02627 {\cf20 // 5.10 - SD2 Interrupt}\par
02628 {\cf20 //}\par
02629 interrupt {\cf18 void} SD2_ISR({\cf18 void})\par
02630 \{\par
02631     {\cf20 //}\par
02632     {\cf20 // Insert ISR Code here}\par
02633     {\cf20 //}\par
02634 \par
02635     {\cf20 //}\par
02636     {\cf20 // To receive more interrupts from this PIE group,}\par
02637     {\cf20 // acknowledge this interrupt.}\par
02638     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;}\par
02639     {\cf20 //}\par
02640 \par
02641     {\cf20 //}\par
02642     {\cf20 // Next two lines for debug only to halt the processor here}\par
02643     {\cf20 // Remove after inserting ISR Code}\par
02644     {\cf20 //}\par
02645     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02646     {\cf19 for}(;;);\par
02647 \}\par
02648 \par
02649 {\cf20 //}\par
02650 {\cf20 // 6.9 - SPIC Receive Interrupt}\par
02651 {\cf20 //}\par
02652 interrupt {\cf18 void} SPIC_RX_ISR({\cf18 void})\par
02653 \{\par
02654     {\cf20 //}\par
02655     {\cf20 // Insert ISR Code here}\par
02656     {\cf20 //}\par
02657 \par
02658     {\cf20 //}\par
02659     {\cf20 // To receive more interrupts from this PIE group,}\par
02660     {\cf20 // acknowledge this interrupt.}\par
02661     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
02662     {\cf20 //}\par
02663 \par
02664     {\cf20 //}\par
02665     {\cf20 // Next two lines for debug only to halt the processor here}\par
02666     {\cf20 // Remove after inserting ISR Code}\par
02667     {\cf20 //}\par
02668     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02669     {\cf19 for}(;;);\par
02670 \}\par
02671 \par
02672 {\cf20 //}\par
02673 {\cf20 // 6.10 - SPIC Transmit Interrupt}\par
02674 {\cf20 //}\par
02675 interrupt {\cf18 void} SPIC_TX_ISR({\cf18 void})\par
02676 \{\par
02677     {\cf20 //}\par
02678     {\cf20 // Insert ISR Code here}\par
02679     {\cf20 //}\par
02680 \par
02681     {\cf20 //}\par
02682     {\cf20 // To receive more interrupts from this PIE group,}\par
02683     {\cf20 // acknowledge this interrupt.}\par
02684     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;}\par
02685     {\cf20 //}\par
02686 \par
02687     {\cf20 //}\par
02688     {\cf20 // Next two lines for debug only to halt the processor here}\par
02689     {\cf20 // Remove after inserting ISR Code}\par
02690     {\cf20 //}\par
02691     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02692     {\cf19 for}(;;);\par
02693 \}\par
02694 \par
02695 {\cf20 //}\par
02696 {\cf20 // 8.15 - uPPA Interrupt}\par
02697 {\cf20 //}\par
02698 interrupt {\cf18 void} UPPA_ISR({\cf18 void})\par
02699 \{\par
02700     {\cf20 //}\par
02701     {\cf20 // Insert ISR Code here}\par
02702     {\cf20 //}\par
02703 \par
02704     {\cf20 //}\par
02705     {\cf20 // To receive more interrupts from this PIE group,}\par
02706     {\cf20 // acknowledge this interrupt.}\par
02707     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;}\par
02708     {\cf20 //}\par
02709 \par
02710     {\cf20 //}\par
02711     {\cf20 // Next two lines for debug only to halt the processor here}\par
02712     {\cf20 // Remove after inserting ISR Code}\par
02713     {\cf20 //}\par
02714     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02715     {\cf19 for}(;;);\par
02716 \}\par
02717 \par
02718 {\cf20 //}\par
02719 {\cf20 // 9.15 - USBA Interrupt}\par
02720 {\cf20 //}\par
02721 interrupt {\cf18 void} USBA_ISR({\cf18 void})\par
02722 \{\par
02723     {\cf20 //}\par
02724     {\cf20 // Insert ISR Code here}\par
02725     {\cf20 //}\par
02726 \par
02727     {\cf20 //}\par
02728     {\cf20 // To receive more interrupts from this PIE group,}\par
02729     {\cf20 // acknowledge this interrupt.}\par
02730     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;}\par
02731     {\cf20 //}\par
02732 \par
02733     {\cf20 //}\par
02734     {\cf20 // Next two lines for debug only to halt the processor here}\par
02735     {\cf20 // Remove after inserting ISR Code}\par
02736     {\cf20 //}\par
02737     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02738     {\cf19 for}(;;);\par
02739 \}\par
02740 \par
02741 {\cf20 //}\par
02742 {\cf20 // 10.9 - ADCC Event Interrupt}\par
02743 {\cf20 //}\par
02744 interrupt {\cf18 void} ADCC_EVT_ISR({\cf18 void})\par
02745 \{\par
02746     {\cf20 //}\par
02747     {\cf20 // Insert ISR Code here}\par
02748     {\cf20 //}\par
02749 \par
02750     {\cf20 //}\par
02751     {\cf20 // To receive more interrupts from this PIE group,}\par
02752     {\cf20 // acknowledge this interrupt.}\par
02753     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02754     {\cf20 //}\par
02755 \par
02756     {\cf20 //}\par
02757     {\cf20 // Next two lines for debug only to halt the processor here}\par
02758     {\cf20 // Remove after inserting ISR Code}\par
02759     {\cf20 //}\par
02760     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02761     {\cf19 for}(;;);\par
02762 \}\par
02763 \par
02764 {\cf20 //}\par
02765 {\cf20 // 10.10 - ADCC Interrupt 2}\par
02766 {\cf20 //}\par
02767 interrupt {\cf18 void} ADCC2_ISR({\cf18 void})\par
02768 \{\par
02769     {\cf20 //}\par
02770     {\cf20 // Insert ISR Code here}\par
02771     {\cf20 //}\par
02772 \par
02773     {\cf20 //}\par
02774     {\cf20 // To receive more interrupts from this PIE group,}\par
02775     {\cf20 // acknowledge this interrupt.}\par
02776     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02777     {\cf20 //}\par
02778 \par
02779     {\cf20 //}\par
02780     {\cf20 // Next two lines for debug only to halt the processor here}\par
02781     {\cf20 // Remove after inserting ISR Code}\par
02782     {\cf20 //}\par
02783     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02784     {\cf19 for}(;;);\par
02785 \}\par
02786 \par
02787 {\cf20 //}\par
02788 {\cf20 // 10.11 - ADCC Interrupt 3}\par
02789 {\cf20 //}\par
02790 interrupt {\cf18 void} ADCC3_ISR({\cf18 void})\par
02791 \{\par
02792     {\cf20 //}\par
02793     {\cf20 // Insert ISR Code here}\par
02794     {\cf20 //}\par
02795 \par
02796     {\cf20 //}\par
02797     {\cf20 // To receive more interrupts from this PIE group,}\par
02798     {\cf20 // acknowledge this interrupt.}\par
02799     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02800     {\cf20 //}\par
02801 \par
02802     {\cf20 //}\par
02803     {\cf20 // Next two lines for debug only to halt the processor here}\par
02804     {\cf20 // Remove after inserting ISR Code}\par
02805     {\cf20 //}\par
02806     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02807     {\cf19 for}(;;);\par
02808 \}\par
02809 \par
02810 {\cf20 //}\par
02811 {\cf20 // 10.12 - ADCC Interrupt 4}\par
02812 {\cf20 //}\par
02813 interrupt {\cf18 void} ADCC4_ISR({\cf18 void})\par
02814 \{\par
02815     {\cf20 //}\par
02816     {\cf20 // Insert ISR Code here}\par
02817     {\cf20 //}\par
02818 \par
02819     {\cf20 //}\par
02820     {\cf20 // To receive more interrupts from this PIE group,}\par
02821     {\cf20 // acknowledge this interrupt.}\par
02822     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02823     {\cf20 //}\par
02824 \par
02825     {\cf20 //}\par
02826     {\cf20 // Next two lines for debug only to halt the processor here}\par
02827     {\cf20 // Remove after inserting ISR Code}\par
02828     {\cf20 //}\par
02829     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02830     {\cf19 for}(;;);\par
02831 \}\par
02832 \par
02833 {\cf20 //}\par
02834 {\cf20 // 10.13 - ADCD Event Interrupt}\par
02835 {\cf20 //}\par
02836 interrupt {\cf18 void} ADCD_EVT_ISR({\cf18 void})\par
02837 \{\par
02838     {\cf20 //}\par
02839     {\cf20 // Insert ISR Code here}\par
02840     {\cf20 //}\par
02841 \par
02842     {\cf20 //}\par
02843     {\cf20 // To receive more interrupts from this PIE group,}\par
02844     {\cf20 // acknowledge this interrupt.}\par
02845     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02846     {\cf20 //}\par
02847 \par
02848     {\cf20 //}\par
02849     {\cf20 // Next two lines for debug only to halt the processor here}\par
02850     {\cf20 // Remove after inserting ISR Code}\par
02851     {\cf20 //}\par
02852     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02853     {\cf19 for}(;;);\par
02854 \}\par
02855 \par
02856 {\cf20 //}\par
02857 {\cf20 // 10.14 - ADCD Interrupt 2}\par
02858 {\cf20 //}\par
02859 interrupt {\cf18 void} ADCD2_ISR({\cf18 void})\par
02860 \{\par
02861     {\cf20 //}\par
02862     {\cf20 // Insert ISR Code here}\par
02863     {\cf20 //}\par
02864 \par
02865     {\cf20 //}\par
02866     {\cf20 // To receive more interrupts from this PIE group,}\par
02867     {\cf20 // acknowledge this interrupt.}\par
02868     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02869     {\cf20 //}\par
02870 \par
02871     {\cf20 //}\par
02872     {\cf20 // Next two lines for debug only to halt the processor here}\par
02873     {\cf20 // Remove after inserting ISR Code}\par
02874     {\cf20 //}\par
02875     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02876     {\cf19 for}(;;);\par
02877 \}\par
02878 \par
02879 {\cf20 //}\par
02880 {\cf20 // 10.15 - ADCD Interrupt 3}\par
02881 {\cf20 //}\par
02882 interrupt {\cf18 void} ADCD3_ISR({\cf18 void})\par
02883 \{\par
02884     {\cf20 //}\par
02885     {\cf20 // Insert ISR Code here}\par
02886     {\cf20 //}\par
02887 \par
02888     {\cf20 //}\par
02889     {\cf20 // To receive more interrupts from this PIE group,}\par
02890     {\cf20 // acknowledge this interrupt.}\par
02891     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02892     {\cf20 //}\par
02893 \par
02894     {\cf20 //}\par
02895     {\cf20 // Next two lines for debug only to halt the processor here}\par
02896     {\cf20 // Remove after inserting ISR Code}\par
02897     {\cf20 //}\par
02898     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02899     {\cf19 for}(;;);\par
02900 \}\par
02901 \par
02902 {\cf20 //}\par
02903 {\cf20 // 10.16 - ADCD Interrupt 4}\par
02904 {\cf20 //}\par
02905 interrupt {\cf18 void} ADCD4_ISR({\cf18 void})\par
02906 \{\par
02907     {\cf20 //}\par
02908     {\cf20 // Insert ISR Code here}\par
02909     {\cf20 //}\par
02910 \par
02911     {\cf20 //}\par
02912     {\cf20 // To receive more interrupts from this PIE group,}\par
02913     {\cf20 // acknowledge this interrupt.}\par
02914     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;}\par
02915     {\cf20 //}\par
02916 \par
02917     {\cf20 //}\par
02918     {\cf20 // Next two lines for debug only to halt the processor here}\par
02919     {\cf20 // Remove after inserting ISR Code}\par
02920     {\cf20 //}\par
02921     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02922     {\cf19 for}(;;);\par
02923 \}\par
02924 \par
02925 {\cf20 //}\par
02926 {\cf20 // 12.9 - EMIF Error Interrupt}\par
02927 {\cf20 //}\par
02928 interrupt {\cf18 void} EMIF_ERROR_ISR({\cf18 void})\par
02929 \{\par
02930     {\cf20 //}\par
02931     {\cf20 // Insert ISR Code here}\par
02932     {\cf20 //}\par
02933 \par
02934     {\cf20 //}\par
02935     {\cf20 // To receive more interrupts from this PIE group,}\par
02936     {\cf20 // acknowledge this interrupt.}\par
02937     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02938     {\cf20 //}\par
02939 \par
02940     {\cf20 //}\par
02941     {\cf20 // Next two lines for debug only to halt the processor here}\par
02942     {\cf20 // Remove after inserting ISR Code}\par
02943     {\cf20 //}\par
02944     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02945     {\cf19 for}(;;);\par
02946 \}\par
02947 \par
02948 {\cf20 //}\par
02949 {\cf20 // 12.10 - RAM Correctable Error Interrupt}\par
02950 {\cf20 //}\par
02951 interrupt {\cf18 void} RAM_CORRECTABLE_ERROR_ISR({\cf18 void})\par
02952 \{\par
02953     {\cf20 //}\par
02954     {\cf20 // Insert ISR Code here}\par
02955     {\cf20 //}\par
02956 \par
02957     {\cf20 //}\par
02958     {\cf20 // To receive more interrupts from this PIE group,}\par
02959     {\cf20 // acknowledge this interrupt.}\par
02960     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02961     {\cf20 //}\par
02962 \par
02963     {\cf20 //}\par
02964     {\cf20 // Next two lines for debug only to halt the processor here}\par
02965     {\cf20 // Remove after inserting ISR Code}\par
02966     {\cf20 //}\par
02967     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02968     {\cf19 for}(;;);\par
02969 \}\par
02970 \par
02971 {\cf20 //}\par
02972 {\cf20 // 12.11 - Flash Correctable Error Interrupt}\par
02973 {\cf20 //}\par
02974 interrupt {\cf18 void} FLASH_CORRECTABLE_ERROR_ISR({\cf18 void})\par
02975 \{\par
02976     {\cf20 //}\par
02977     {\cf20 // Insert ISR Code here}\par
02978     {\cf20 //}\par
02979 \par
02980     {\cf20 //}\par
02981     {\cf20 // To receive more interrupts from this PIE group,}\par
02982     {\cf20 // acknowledge this interrupt.}\par
02983     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
02984     {\cf20 //}\par
02985 \par
02986     {\cf20 //}\par
02987     {\cf20 // Next two lines for debug only to halt the processor here}\par
02988     {\cf20 // Remove after inserting ISR Code}\par
02989     {\cf20 //}\par
02990     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
02991     {\cf19 for}(;;);\par
02992 \}\par
02993 \par
02994 {\cf20 //}\par
02995 {\cf20 // 12.12 - RAM Access Violation Interrupt}\par
02996 {\cf20 //}\par
02997 interrupt {\cf18 void} RAM_ACCESS_VIOLATION_ISR({\cf18 void})\par
02998 \{\par
02999     {\cf20 //}\par
03000     {\cf20 // Insert ISR Code here}\par
03001     {\cf20 //}\par
03002 \par
03003     {\cf20 //}\par
03004     {\cf20 // To receive more interrupts from this PIE group,}\par
03005     {\cf20 // acknowledge this interrupt.}\par
03006     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
03007     {\cf20 //}\par
03008 \par
03009     {\cf20 //}\par
03010     {\cf20 // Next two lines for debug only to halt the processor here}\par
03011     {\cf20 // Remove after inserting ISR Code}\par
03012     {\cf20 //}\par
03013     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
03014     {\cf19 for}(;;);\par
03015 \}\par
03016 \par
03017 {\cf20 //}\par
03018 {\cf20 // 12.13 - System PLL Slip Interrupt}\par
03019 {\cf20 //}\par
03020 interrupt {\cf18 void} SYS_PLL_SLIP_ISR({\cf18 void})\par
03021 \{\par
03022     {\cf20 //}\par
03023     {\cf20 // Insert ISR Code here}\par
03024     {\cf20 //}\par
03025 \par
03026     {\cf20 //}\par
03027     {\cf20 // To receive more interrupts from this PIE group,}\par
03028     {\cf20 // acknowledge this interrupt.}\par
03029     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
03030     {\cf20 //}\par
03031 \par
03032     {\cf20 //}\par
03033     {\cf20 // Next two lines for debug only to halt the processor here}\par
03034     {\cf20 // Remove after inserting ISR Code}\par
03035     {\cf20 //}\par
03036     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
03037     {\cf19 for}(;;);\par
03038 \}\par
03039 \par
03040 {\cf20 //}\par
03041 {\cf20 // 12.14 - Auxiliary PLL Slip Interrupt}\par
03042 {\cf20 //}\par
03043 interrupt {\cf18 void} AUX_PLL_SLIP_ISR({\cf18 void})\par
03044 \{\par
03045     {\cf20 //}\par
03046     {\cf20 // Insert ISR Code here}\par
03047     {\cf20 //}\par
03048 \par
03049     {\cf20 //}\par
03050     {\cf20 // To receive more interrupts from this PIE group,}\par
03051     {\cf20 // acknowledge this interrupt.}\par
03052     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
03053     {\cf20 //}\par
03054 \par
03055     {\cf20 //}\par
03056     {\cf20 // Next two lines for debug only to halt the processor here}\par
03057     {\cf20 // Remove after inserting ISR Code}\par
03058     {\cf20 //}\par
03059     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
03060     {\cf19 for}(;;);\par
03061 \}\par
03062 \par
03063 {\cf20 //}\par
03064 {\cf20 // 12.15 - CLA Overflow Interrupt}\par
03065 {\cf20 //}\par
03066 interrupt {\cf18 void} CLA_OVERFLOW_ISR({\cf18 void})\par
03067 \{\par
03068     {\cf20 //}\par
03069     {\cf20 // Insert ISR Code here}\par
03070     {\cf20 //}\par
03071 \par
03072     {\cf20 //}\par
03073     {\cf20 // To receive more interrupts from this PIE group,}\par
03074     {\cf20 // acknowledge this interrupt.}\par
03075     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
03076     {\cf20 //}\par
03077 \par
03078     {\cf20 //}\par
03079     {\cf20 // Next two lines for debug only to halt the processor here}\par
03080     {\cf20 // Remove after inserting ISR Code}\par
03081     {\cf20 //}\par
03082     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
03083     {\cf19 for}(;;);\par
03084 \}\par
03085 \par
03086 {\cf20 //}\par
03087 {\cf20 // 12.16 - CLA Underflow Interrupt}\par
03088 {\cf20 //}\par
03089 interrupt {\cf18 void} CLA_UNDERFLOW_ISR({\cf18 void})\par
03090 \{\par
03091     {\cf20 //}\par
03092     {\cf20 // Insert ISR Code here}\par
03093     {\cf20 //}\par
03094 \par
03095     {\cf20 //}\par
03096     {\cf20 // To receive more interrupts from this PIE group,}\par
03097     {\cf20 // acknowledge this interrupt.}\par
03098     {\cf20 // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;}\par
03099     {\cf20 //}\par
03100 \par
03101     {\cf20 //}\par
03102     {\cf20 // Next two lines for debug only to halt the processor here}\par
03103     {\cf20 // Remove after inserting ISR Code}\par
03104     {\cf20 //}\par
03105     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
03106     {\cf19 for}(;;);\par
03107 \}\par
03108 \par
03109 {\cf20 //}\par
03110 {\cf20 // Catch-all Default ISRs:}\par
03111 {\cf20 //}\par
03112 \par
03113 {\cf20 //}\par
03114 {\cf20 // PIE_RESERVED_ISR - Reserved ISR}\par
03115 {\cf20 //}\par
03116 interrupt {\cf18 void} PIE_RESERVED_ISR({\cf18 void})\par
03117 \{\par
03118     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
03119     {\cf19 for}(;;);\par
03120 \}\par
03121 \par
03122 {\cf20 //}\par
03123 {\cf20 // EMPTY_ISR - Only does a return}\par
03124 {\cf20 //}\par
03125 interrupt {\cf18 void} EMPTY_ISR({\cf18 void})\par
03126 \{\par
03127 \par
03128 \}\par
03129 \par
03130 {\cf20 //}\par
03131 {\cf20 // NOTUSED_ISR - Unused ISR}\par
03132 {\cf20 //}\par
03133 interrupt {\cf18 void} NOTUSED_ISR({\cf18 void})\par
03134 \{\par
03135     {\cf17 asm} ({\cf22 "      ESTOP0"});\par
03136     {\cf19 for}(;;);\par
03137 \}\par
03138 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_EPwm.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c}
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwmGpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm1Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm2Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm3Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm4Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm5Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm6Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm7Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm8Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm9Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm10Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm11Gpio} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitEPwm12Gpio} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitEPwm10Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm10Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm10Gpio (void )}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm11Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm11Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm11Gpio (void )}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm12Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm12Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm12Gpio (void )}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 413} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm1Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm1Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm1Gpio (void )}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm2Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm2Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm2Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm3Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm3Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm3Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm4Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm4Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm4Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm5Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm5Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm5Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm6Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm6Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm6Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 232} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm7Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm7Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm7Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 264} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm8Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm8Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm8Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 297} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwm9Gpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwm9Gpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwm9Gpio (void )}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 329} of file {\b F2837xD_EPwm.c}.}\par
}
{\xe \v InitEPwmGpio\:F2837xD_EPwm.c}
{\xe \v F2837xD_EPwm.c\:InitEPwmGpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitEPwmGpio (void )}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b F2837xD_EPwm.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_EPwm.c\par \pard\plain 
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:   F2837xD_EPwm.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:  F2837xD EPwm Initialization & Support Functions.}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}\par
00047 {\cf21 #include "F2837xD_Examples.h"}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // InitEPwmGpio - Initialize all EPWM modules' GPIOs}\par
00051 {\cf20 //}\par
00052 {\cf18 void} InitEPwmGpio({\cf18 void})\par
00053 \{\par
00054     InitEPwm1Gpio();\par
00055     InitEPwm2Gpio();\par
00056     InitEPwm3Gpio();\par
00057     InitEPwm4Gpio();\par
00058     InitEPwm5Gpio();\par
00059     InitEPwm6Gpio();\par
00060     InitEPwm7Gpio();\par
00061     InitEPwm8Gpio();\par
00062     InitEPwm9Gpio();\par
00063     InitEPwm10Gpio();\par
00064     InitEPwm11Gpio();\par
00065     InitEPwm12Gpio();\par
00066 \}\par
00067 \par
00068 {\cf20 //}\par
00069 {\cf20 // InitEPwm1Gpio - Initialize EPWM1 GPIOs}\par
00070 {\cf20 //}\par
00071 {\cf18 void} InitEPwm1Gpio({\cf18 void})\par
00072 \{\par
00073     EALLOW;\par
00074 \par
00075     {\cf20 //}\par
00076     {\cf20 // Disable internal pull-up for the selected output pins}\par
00077     {\cf20 // for reduced power consumption}\par
00078     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00079     {\cf20 // Comment out other unwanted lines.}\par
00080     {\cf20 //}\par
00081     GpioCtrlRegs.GPAPUD.bit.GPIO0 = 1;    {\cf20 // Disable pull-up on GPIO0 (EPWM1A)}\par
00082     GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1;    {\cf20 // Disable pull-up on GPIO1 (EPWM1B)}\par
00083     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO145 = 1;    // Disable pull-up on GPIO145 (EPWM1A)}\par
00084     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO146 = 1;    // Disable pull-up on GPIO146 (EPWM1B)}\par
00085 \par
00086     {\cf20 //}\par
00087     {\cf20 // Configure EPWM-1 pins using GPIO regs}\par
00088     {\cf20 // This specifies which of the possible GPIO pins will be EPWM1 functional}\par
00089     {\cf20 // pins.}\par
00090     {\cf20 // Comment out other unwanted lines.}\par
00091     {\cf20 //}\par
00092     GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1;   {\cf20 // Configure GPIO0 as EPWM1A}\par
00093     GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1;   {\cf20 // Configure GPIO1 as EPWM1B}\par
00094     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO145 = 1;   // Configure GPIO145 as EPWM1A}\par
00095     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO146 = 1;   // Configure GPIO0146 as EPWM1B}\par
00096 \par
00097     EDIS;\par
00098 \}\par
00099 \par
00100 {\cf20 //}\par
00101 {\cf20 // InitEPwm2Gpio - Initialize EPWM2 GPIOs}\par
00102 {\cf20 //}\par
00103 {\cf18 void} InitEPwm2Gpio({\cf18 void})\par
00104 \{\par
00105     EALLOW;\par
00106 \par
00107     {\cf20 //}\par
00108     {\cf20 // Disable internal pull-up for the selected output pins}\par
00109     {\cf20 // for reduced power consumption}\par
00110     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00111     {\cf20 // This will enable the pullups for the specified pins.}\par
00112     {\cf20 // Comment out other unwanted lines.}\par
00113     {\cf20 //}\par
00114     GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1;    {\cf20 // Disable pull-up on GPIO2 (EPWM2A)}\par
00115     GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1;    {\cf20 // Disable pull-up on GPIO3 (EPWM2B)}\par
00116     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO147 = 1;    // Disable pull-up on GPIO147 (EPWM2A)}\par
00117     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO148 = 1;    // Disable pull-up on GPIO148 (EPWM2B)}\par
00118 \par
00119     {\cf20 //}\par
00120     {\cf20 // Configure EPwm-2 pins using GPIO regs}\par
00121     {\cf20 // This specifies which of the possible GPIO pins will be EPWM2 functional pins.}\par
00122     {\cf20 // Comment out other unwanted lines.}\par
00123     {\cf20 //}\par
00124     GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1;   {\cf20 // Configure GPIO2 as EPWM2A}\par
00125     GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1;   {\cf20 // Configure GPIO3 as EPWM2B}\par
00126    {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO147 = 1;   // Configure GPIO147 as EPWM2A}\par
00127    {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO148 = 1;   // Configure GPIO148 as EPWM2B}\par
00128 \par
00129     EDIS;\par
00130 \}\par
00131 \par
00132 {\cf20 //}\par
00133 {\cf20 // InitEPwm3Gpio - Initialize EPWM3 GPIOs}\par
00134 {\cf20 //}\par
00135 {\cf18 void} InitEPwm3Gpio({\cf18 void})\par
00136 \{\par
00137     EALLOW;\par
00138 \par
00139     {\cf20 //}\par
00140     {\cf20 // Disable internal pull-up for the selected output pins}\par
00141     {\cf20 //   for reduced power consumption}\par
00142     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00143     {\cf20 // This will enable the pullups for the specified pins.}\par
00144     {\cf20 // Comment out other unwanted lines.}\par
00145     {\cf20 //}\par
00146     GpioCtrlRegs.GPAPUD.bit.GPIO4 = 1;    {\cf20 // Disable pull-up on GPIO4 (EPWM3A)}\par
00147     GpioCtrlRegs.GPAPUD.bit.GPIO5 = 1;    {\cf20 // Disable pull-up on GPIO5 (EPWM3B)}\par
00148     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO149 = 1;    // Disable pull-up on GPIO149 (EPWM3A)}\par
00149     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO150 = 1;    // Disable pull-up on GPIO150 (EPWM3B)}\par
00150 \par
00151     {\cf20 //}\par
00152     {\cf20 // Configure EPwm-3 pins using GPIO regs}\par
00153     {\cf20 // This specifies which of the possible GPIO pins will be EPWM3 functional pins.}\par
00154     {\cf20 // Comment out other unwanted lines.}\par
00155     {\cf20 //}\par
00156     GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 1;   {\cf20 // Configure GPIO4 as EPWM3A}\par
00157     GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 1;   {\cf20 // Configure GPIO5 as EPWM3B}\par
00158     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO149 = 1;   // Configure GPIO149 as EPWM3A}\par
00159     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO150 = 1;   // Configure GPIO150 as EPWM3B}\par
00160 \par
00161     EDIS;\par
00162 \}\par
00163 \par
00164 {\cf20 //}\par
00165 {\cf20 // InitEPwm4Gpio - Initialize EPWM4 GPIOs}\par
00166 {\cf20 //}\par
00167 {\cf18 void} InitEPwm4Gpio({\cf18 void})\par
00168 \{\par
00169     EALLOW;\par
00170 \par
00171     {\cf20 //}\par
00172     {\cf20 // Disable internal pull-up for the selected output pins}\par
00173     {\cf20 //   for reduced power consumption}\par
00174     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00175     {\cf20 // This will enable the pullups for the specified pins.}\par
00176     {\cf20 // Comment out other unwanted lines.}\par
00177     {\cf20 //}\par
00178     GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1;    {\cf20 // Disable pull-up on GPIO6 (EPWM4A)}\par
00179     GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1;    {\cf20 // Disable pull-up on GPIO7 (EPWM4B)}\par
00180     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO151 = 1;    // Disable pull-up on GPIO151 (EPWM4A)}\par
00181     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO152 = 1;    // Disable pull-up on GPIO152 (EPWM4B)}\par
00182 \par
00183      {\cf20 //}\par
00184      {\cf20 // Configure EPWM-4 pins using GPIO regs}\par
00185      {\cf20 // This specifies which of the possible GPIO pins will be EPWM4 functional}\par
00186      {\cf20 // pins.}\par
00187      {\cf20 // Comment out other unwanted lines.}\par
00188      {\cf20 //}\par
00189     GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1;   {\cf20 // Configure GPIO6 as EPWM4A}\par
00190     GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1;   {\cf20 // Configure GPIO7 as EPWM4B}\par
00191     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO151 = 1;   // Configure GPIO151 as EPWM4A}\par
00192     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO152 = 1;   // Configure GPIO152 as EPWM4B}\par
00193 \par
00194     EDIS;\par
00195 \}\par
00196 \par
00197 {\cf20 //}\par
00198 {\cf20 // InitEPwm5Gpio - Initialize EPWM5 GPIOs}\par
00199 {\cf20 //}\par
00200 {\cf18 void} InitEPwm5Gpio({\cf18 void})\par
00201 \{\par
00202     EALLOW;\par
00203     {\cf20 //}\par
00204     {\cf20 // Disable internal pull-up for the selected output pins}\par
00205     {\cf20 //   for reduced power consumption}\par
00206     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00207     {\cf20 // This will enable the pullups for the specified pins.}\par
00208     {\cf20 // Comment out other unwanted lines.}\par
00209     {\cf20 //}\par
00210     GpioCtrlRegs.GPAPUD.bit.GPIO8 = 1;    {\cf20 // Disable pull-up on GPIO8 (EPWM5A)}\par
00211     GpioCtrlRegs.GPAPUD.bit.GPIO9 = 1;    {\cf20 // Disable pull-up on GPIO9 (EPWM5B)}\par
00212     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO153 = 1;    // Disable pull-up on GPIO153 (EPWM5A)}\par
00213     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO154 = 1;    // Disable pull-up on GPIO154 (EPWM5B)}\par
00214 \par
00215     {\cf20 //}\par
00216     {\cf20 // Configure EPWM-5 pins using GPIO regs}\par
00217     {\cf20 // This specifies which of the possible GPIO pins will be EPWM5 functional}\par
00218     {\cf20 // pins.}\par
00219     {\cf20 // Comment out other unwanted lines.}\par
00220     {\cf20 //}\par
00221     GpioCtrlRegs.GPAMUX1.bit.GPIO8 = 1;   {\cf20 // Configure GPIO8 as EPWM5A}\par
00222     GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 1;   {\cf20 // Configure GPIO9 as EPWM5B}\par
00223     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO153 = 1;   // Configure GPIO153 as EPWM5A}\par
00224     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO154 = 1;   // Configure GPIO0154 as EPWM5B}\par
00225 \par
00226     EDIS;\par
00227 \}\par
00228 \par
00229 {\cf20 //}\par
00230 {\cf20 // InitEPwm6Gpio - Initialize EPWM6 GPIOs}\par
00231 {\cf20 //}\par
00232 {\cf18 void} InitEPwm6Gpio({\cf18 void})\par
00233 \{\par
00234     EALLOW;\par
00235     {\cf20 //}\par
00236     {\cf20 // Disable internal pull-up for the selected output pins}\par
00237     {\cf20 // for reduced power consumption}\par
00238     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00239     {\cf20 // This will enable the pullups for the specified pins.}\par
00240     {\cf20 // Comment out other unwanted lines.}\par
00241     {\cf20 //}\par
00242     GpioCtrlRegs.GPAPUD.bit.GPIO10 = 1;    {\cf20 // Disable pull-up on GPIO10 (EPWM6A)}\par
00243     GpioCtrlRegs.GPAPUD.bit.GPIO11 = 1;    {\cf20 // Disable pull-up on GPIO11 (EPWM6B)}\par
00244     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO155 = 1;    // Disable pull-up on GPIO155 (EPWM6A)}\par
00245     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO156 = 1;    // Disable pull-up on GPIO156 (EPWM6B)}\par
00246 \par
00247     {\cf20 //}\par
00248     {\cf20 // Configure EPWM-6 pins using GPIO regs}\par
00249     {\cf20 // This specifies which of the possible GPIO pins will be EPWM6 functional}\par
00250     {\cf20 // pins.}\par
00251     {\cf20 // Comment out other unwanted lines.}\par
00252     {\cf20 //}\par
00253     GpioCtrlRegs.GPAMUX1.bit.GPIO10 = 1;   {\cf20 // Configure GPIO10 as EPWM6A}\par
00254     GpioCtrlRegs.GPAMUX1.bit.GPIO11 = 1;   {\cf20 // Configure GPIO11 as EPWM6B}\par
00255     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO155 = 1;   // Configure GPIO155 as EPWM6A}\par
00256     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO156 = 1;   // Configure GPIO156 as EPWM6B}\par
00257 \par
00258     EDIS;\par
00259 \}\par
00260 \par
00261 {\cf20 //}\par
00262 {\cf20 // InitEPwm7Gpio - Initialize EPWM7 GPIOs}\par
00263 {\cf20 //}\par
00264 {\cf18 void} InitEPwm7Gpio({\cf18 void})\par
00265 \{\par
00266     EALLOW;\par
00267 \par
00268     {\cf20 //}\par
00269     {\cf20 // Disable internal pull-up for the selected output pins}\par
00270     {\cf20 // for reduced power consumption}\par
00271     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00272     {\cf20 // This will enable the pullups for the specified pins.}\par
00273     {\cf20 // Comment out other unwanted lines.}\par
00274     {\cf20 //}\par
00275     GpioCtrlRegs.GPAPUD.bit.GPIO12 = 1;    {\cf20 // Disable pull-up on GPIO12 (EPWM7A)}\par
00276     GpioCtrlRegs.GPAPUD.bit.GPIO13 = 1;    {\cf20 // Disable pull-up on GPIO13 (EPWM7B)}\par
00277     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO157 = 1;    // Disable pull-up on GPIO157 (EPWM7A)}\par
00278     {\cf20 // GpioCtrlRegs.GPEPUD.bit.GPIO158 = 1;    // Disable pull-up on GPIO158 (EPWM7B)}\par
00279 \par
00280     {\cf20 //}\par
00281     {\cf20 // Configure EPWM-6 pins using GPIO regs}\par
00282     {\cf20 // This specifies which of the possible GPIO pins will be EPWM6 functional}\par
00283     {\cf20 // pins.}\par
00284     {\cf20 // Comment out other unwanted lines.}\par
00285     {\cf20 //}\par
00286     GpioCtrlRegs.GPAMUX1.bit.GPIO12 = 1;   {\cf20 // Configure GPIO12 as EPWM7A}\par
00287     GpioCtrlRegs.GPAMUX1.bit.GPIO13 = 1;   {\cf20 // Configure GPIO13 as EPWM7B}\par
00288     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO157 = 1;   // Configure GPIO157 as EPWM7A}\par
00289     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO158 = 1;   // Configure GPIO158 as EPWM7B}\par
00290 \par
00291     EDIS;\par
00292 \}\par
00293 \par
00294 {\cf20 //}\par
00295 {\cf20 // InitEPwm8Gpio - Initialize EPWM8 GPIOs}\par
00296 {\cf20 //}\par
00297 {\cf18 void} InitEPwm8Gpio({\cf18 void})\par
00298 \{\par
00299     EALLOW;\par
00300     {\cf20 //}\par
00301     {\cf20 // Disable internal pull-up for the selected output pins}\par
00302     {\cf20 // for reduced power consumption}\par
00303     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00304     {\cf20 // This will enable the pullups for the specified pins.}\par
00305     {\cf20 // Comment out other unwanted lines.}\par
00306     {\cf20 //}\par
00307     GpioCtrlRegs.GPAPUD.bit.GPIO14 = 1;    {\cf20 // Disable pull-up on GPIO14 (EPWM8A)}\par
00308     GpioCtrlRegs.GPAPUD.bit.GPIO15 = 1;    {\cf20 // Disable pull-up on GPIO15 (EPWM8B)}\par
00309 {\cf20 //  GpioCtrlRegs.GPEPUD.bit.GPIO159 = 1;    // Disable pull-up on GPIO159 (EPWM8A)}\par
00310 {\cf20 //  GpioCtrlRegs.GPFPUD.bit.GPIO160 = 1;    // Disable pull-up on GPIO160 (EPWM8B)}\par
00311 \par
00312      {\cf20 //}\par
00313      {\cf20 // Configure EPWM-6 pins using GPIO regs}\par
00314      {\cf20 // This specifies which of the possible GPIO pins will be EPWM6 functional}\par
00315      {\cf20 // pins.}\par
00316      {\cf20 // Comment out other unwanted lines.}\par
00317      {\cf20 //}\par
00318     GpioCtrlRegs.GPAMUX1.bit.GPIO14 = 1;   {\cf20 // Configure GPIO14 as EPWM8A}\par
00319     GpioCtrlRegs.GPAMUX1.bit.GPIO15 = 1;   {\cf20 // Configure GPIO15 as EPWM8B}\par
00320     {\cf20 // GpioCtrlRegs.GPEMUX2.bit.GPIO159 = 1;   // Configure GPIO159 as EPWM8A}\par
00321     {\cf20 // GpioCtrlRegs.GPFMUX1.bit.GPIO160 = 1;   // Configure GPIO160 as EPWM8B}\par
00322 \par
00323     EDIS;\par
00324 \}\par
00325 \par
00326 {\cf20 //}\par
00327 {\cf20 // InitEPwm9Gpio - Initialize EPWM9 GPIOs}\par
00328 {\cf20 //}\par
00329 {\cf18 void} InitEPwm9Gpio({\cf18 void})\par
00330 \{\par
00331     EALLOW;\par
00332     {\cf20 //}\par
00333     {\cf20 // Disable internal pull-up for the selected output pins}\par
00334     {\cf20 // for reduced power consumption}\par
00335     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00336     {\cf20 // This will enable the pullups for the specified pins.}\par
00337     {\cf20 // Comment out other unwanted lines.}\par
00338     {\cf20 //}\par
00339     GpioCtrlRegs.GPFPUD.bit.GPIO161 = 1;    {\cf20 // Disable pull-up on GPIO161 (EPWM9A)}\par
00340     GpioCtrlRegs.GPFPUD.bit.GPIO162 = 1;    {\cf20 // Disable pull-up on GPIO162 (EPWM9B)}\par
00341 \par
00342     {\cf20 //}\par
00343     {\cf20 // Configure EPWM-6 pins using GPIO regs}\par
00344     {\cf20 // This specifies which of the possible GPIO pins will be EPWM6 functional}\par
00345     {\cf20 // pins.}\par
00346     {\cf20 // Comment out other unwanted lines.}\par
00347     {\cf20 //}\par
00348     GpioCtrlRegs.GPFMUX1.bit.GPIO161 = 1;   {\cf20 // Configure GPIO161 as EPWM9A}\par
00349     GpioCtrlRegs.GPFMUX1.bit.GPIO162 = 1;   {\cf20 // Configure GPIO162 as EPWM9B}\par
00350 \par
00351     EDIS;\par
00352 \}\par
00353 \par
00354 {\cf20 //}\par
00355 {\cf20 // InitEPwm10Gpio - Initialize EPWM10 GPIOs}\par
00356 {\cf20 //}\par
00357 {\cf18 void} InitEPwm10Gpio({\cf18 void})\par
00358 \{\par
00359     EALLOW;\par
00360     {\cf20 //}\par
00361     {\cf20 // Disable internal pull-up for the selected output pins}\par
00362     {\cf20 // for reduced power consumption}\par
00363     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00364     {\cf20 // This will enable the pullups for the specified pins.}\par
00365     {\cf20 // Comment out other unwanted lines.}\par
00366     {\cf20 //}\par
00367     GpioCtrlRegs.GPFPUD.bit.GPIO163 = 1;    {\cf20 // Disable pull-up on GPIO163 (EPWM10A)}\par
00368     GpioCtrlRegs.GPFPUD.bit.GPIO164 = 1;    {\cf20 // Disable pull-up on GPIO164 (EPWM10B)}\par
00369 \par
00370     {\cf20 //}\par
00371     {\cf20 // Configure EPWM-6 pins using GPIO regs}\par
00372     {\cf20 // This specifies which of the possible GPIO pins will be EPWM6 functional}\par
00373     {\cf20 // pins.}\par
00374     {\cf20 // Comment out other unwanted lines.}\par
00375     {\cf20 //}\par
00376     GpioCtrlRegs.GPFMUX1.bit.GPIO163 = 1;   {\cf20 // Configure GPIO163 as EPWM10A}\par
00377     GpioCtrlRegs.GPFMUX1.bit.GPIO164 = 1;   {\cf20 // Configure GPIO164 as EPWM10B}\par
00378 \par
00379     EDIS;\par
00380 \}\par
00381 \par
00382 {\cf20 //}\par
00383 {\cf20 // InitEPwm11Gpio - Initialize EPWM11 GPIOs}\par
00384 {\cf20 //}\par
00385 {\cf18 void} InitEPwm11Gpio({\cf18 void})\par
00386 \{\par
00387     EALLOW;\par
00388     {\cf20 //}\par
00389     {\cf20 // Disable internal pull-up for the selected output pins}\par
00390     {\cf20 // for reduced power consumption}\par
00391     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00392     {\cf20 // This will enable the pullups for the specified pins.}\par
00393     {\cf20 // Comment out other unwanted lines.}\par
00394     {\cf20 //}\par
00395     GpioCtrlRegs.GPFPUD.bit.GPIO165 = 1;    {\cf20 // Disable pull-up on GPIO165 (EPWM11A)}\par
00396     GpioCtrlRegs.GPFPUD.bit.GPIO166 = 1;    {\cf20 // Disable pull-up on GPIO166 (EPWM11B)}\par
00397 \par
00398     {\cf20 //}\par
00399     {\cf20 // Configure EPWM-6 pins using GPIO regs}\par
00400     {\cf20 // This specifies which of the possible GPIO pins will be EPWM6 functional}\par
00401     {\cf20 // pins.}\par
00402     {\cf20 // Comment out other unwanted lines.}\par
00403     {\cf20 //}\par
00404     GpioCtrlRegs.GPFMUX1.bit.GPIO165 = 1;   {\cf20 // Configure GPIO165 as EPWM11A}\par
00405     GpioCtrlRegs.GPFMUX1.bit.GPIO166 = 1;   {\cf20 // Configure GPIO166 as EPWM11B}\par
00406 \par
00407     EDIS;\par
00408 \}\par
00409 \par
00410 {\cf20 //}\par
00411 {\cf20 // InitEPwm12Gpio - Initialize EPWM12 GPIOs}\par
00412 {\cf20 //}\par
00413 {\cf18 void} InitEPwm12Gpio({\cf18 void})\par
00414 \{\par
00415     EALLOW;\par
00416     {\cf20 //}\par
00417     {\cf20 // Disable internal pull-up for the selected output pins}\par
00418     {\cf20 // for reduced power consumption}\par
00419     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00420     {\cf20 // This will enable the pullups for the specified pins.}\par
00421     {\cf20 // Comment out other unwanted lines.}\par
00422     {\cf20 //}\par
00423     GpioCtrlRegs.GPFPUD.bit.GPIO167 = 1;    {\cf20 // Disable pull-up on GPIO167 (EPWM12A)}\par
00424     GpioCtrlRegs.GPFPUD.bit.GPIO168 = 1;    {\cf20 // Disable pull-up on GPIO168 (EPWM12B)}\par
00425 \par
00426     {\cf20 //}\par
00427     {\cf20 // Configure EPWM-6 pins using GPIO regs}\par
00428     {\cf20 // This specifies which of the possible GPIO pins will be EPWM6 functional}\par
00429     {\cf20 // pins.}\par
00430     {\cf20 // Comment out other unwanted lines.}\par
00431     {\cf20 //}\par
00432     GpioCtrlRegs.GPFMUX1.bit.GPIO167 = 1;   {\cf20 // Configure GPIO167 as EPWM12A}\par
00433     GpioCtrlRegs.GPFMUX1.bit.GPIO168 = 1;   {\cf20 // Configure GPIO168 as EPWM12B}\par
00434 \par
00435     EDIS;\par
00436 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_GlobalVariableDefs.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c}
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_REGS {\b AdcaRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_REGS {\b AdcbRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_REGS {\b AdccRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_REGS {\b AdcdRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_RESULT_REGS {\b AdcaResultRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_RESULT_REGS {\b AdcbResultRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_RESULT_REGS {\b AdccResultRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ADC_RESULT_REGS {\b AdcdResultRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss3Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss4Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss5Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss6Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss7Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CMPSS_REGS {\b Cmpss8Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DAC_REGS {\b DacaRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DAC_REGS {\b DacbRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DAC_REGS {\b DaccRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CLA_REGS {\b Cla1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CLA_SOFTINT_REGS {\b Cla1SoftIntRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CLK_CFG_REGS {\b ClkCfgRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CPU_SYS_REGS {\b CpuSysRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CPUTIMER_REGS {\b CpuTimer0Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CPUTIMER_REGS {\b CpuTimer1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct CPUTIMER_REGS {\b CpuTimer2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DCSM_Z1_REGS {\b DcsmZ1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DCSM_Z2_REGS {\b DcsmZ2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DCSM_COMMON_REGS {\b DcsmCommonRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DMA_REGS {\b DmaRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct DMA_CLA_SRC_SEL_REGS {\b DmaClaSrcSelRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ECAP_REGS {\b ECap1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ECAP_REGS {\b ECap2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ECAP_REGS {\b ECap3Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ECAP_REGS {\b ECap4Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ECAP_REGS {\b ECap5Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ECAP_REGS {\b ECap6Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EMIF_REGS {\b Emif1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EMIF_REGS {\b Emif2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EQEP_REGS {\b EQep1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EQEP_REGS {\b EQep2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EQEP_REGS {\b EQep3Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm3Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm4Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm5Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm6Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm7Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm8Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm9Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm10Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm11Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EPWM_REGS {\b EPwm12Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct GPIO_DATA_REGS {\b GpioDataRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct I2C_REGS {\b I2caRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct I2C_REGS {\b I2cbRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct McBSP_REGS {\b McbspaRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct MEM_CFG_REGS {\b MemCfgRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct EMIF1_CONFIG_REGS {\b Emif1ConfigRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct ACCESS_PROTECTION_REGS {\b AccessProtectionRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct MEMORY_ERROR_REGS {\b MemoryErrorRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct McBSP_REGS {\b McbspbRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct NMI_INTRUPT_REGS {\b NmiIntruptRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct PIE_CTRL_REGS {\b PieCtrlRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct PIE_VECT_TABLE {\b PieVectTable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SCI_REGS {\b SciaRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SCI_REGS {\b ScibRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SCI_REGS {\b ScicRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SCI_REGS {\b ScidRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SPI_REGS {\b SpiaRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SPI_REGS {\b SpibRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SPI_REGS {\b SpicRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SDFM_REGS {\b Sdfm1Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct SDFM_REGS {\b Sdfm2Regs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct WD_REGS {\b WdRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct XINT_REGS {\b XintRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Uint16 {\b EmuBMode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct FLASH_ECC_REGS {\b Flash0EccRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile struct FLASH_CTRL_REGS {\b Flash0CtrlRegs}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v AccessProtectionRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AccessProtectionRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ACCESS_PROTECTION_REGS AccessProtectionRegs}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 687} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdcaRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdcaRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_REGS AdcaRegs}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdcaResultRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdcaResultRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_RESULT_REGS AdcaResultRegs}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdcbRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdcbRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_REGS AdcbRegs}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdcbResultRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdcbResultRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_RESULT_REGS AdcbResultRegs}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdccRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdccRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_REGS AdccRegs}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdccResultRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdccResultRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_RESULT_REGS AdccResultRegs}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdcdRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdcdRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_REGS AdcdRegs}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v AdcdResultRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:AdcdResultRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ADC_RESULT_REGS AdcdResultRegs}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cla1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cla1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CLA_REGS Cla1Regs}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 231} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cla1SoftIntRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cla1SoftIntRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CLA_SOFTINT_REGS Cla1SoftIntRegs}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 238} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ClkCfgRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ClkCfgRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CLK_CFG_REGS ClkCfgRegs}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 245} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss1Regs}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss2Regs}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss3Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss3Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss3Regs}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss4Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss4Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss4Regs}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss5Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss5Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss5Regs}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 175} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss6Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss6Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss6Regs}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss7Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss7Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss7Regs}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Cmpss8Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Cmpss8Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CMPSS_REGS Cmpss8Regs}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v CpuSysRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:CpuSysRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CPU_SYS_REGS CpuSysRegs}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 253} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v CpuTimer0Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:CpuTimer0Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CPUTIMER_REGS CpuTimer0Regs}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v CpuTimer1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:CpuTimer1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CPUTIMER_REGS CpuTimer1Regs}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v CpuTimer2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:CpuTimer2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct CPUTIMER_REGS CpuTimer2Regs}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 277} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DacaRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DacaRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DAC_REGS DacaRegs}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 207} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DacbRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DacbRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DAC_REGS DacbRegs}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DaccRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DaccRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DAC_REGS DaccRegs}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 223} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DcsmCommonRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DcsmCommonRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DCSM_COMMON_REGS DcsmCommonRegs}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 301} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DcsmZ1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DcsmZ1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DCSM_Z1_REGS DcsmZ1Regs}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 285} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DcsmZ2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DcsmZ2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DCSM_Z2_REGS DcsmZ2Regs}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 293} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DmaClaSrcSelRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DmaClaSrcSelRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DMA_CLA_SRC_SEL_REGS DmaClaSrcSelRegs}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 317} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v DmaRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:DmaRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct DMA_REGS DmaRegs}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 309} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ECap1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ECap1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ECAP_REGS ECap1Regs}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 335} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ECap2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ECap2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ECAP_REGS ECap2Regs}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 343} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ECap3Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ECap3Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ECAP_REGS ECap3Regs}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 351} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ECap4Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ECap4Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ECAP_REGS ECap4Regs}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 359} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ECap5Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ECap5Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ECAP_REGS ECap5Regs}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 367} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ECap6Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ECap6Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct ECAP_REGS ECap6Regs}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 375} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Emif1ConfigRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Emif1ConfigRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EMIF1_CONFIG_REGS Emif1ConfigRegs}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 659} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Emif1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Emif1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EMIF_REGS Emif1Regs}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 383} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Emif2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Emif2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EMIF_REGS Emif2Regs}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EmuBMode\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EmuBMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Uint16 EmuBMode}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 844} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm10Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm10Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm10Regs}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 495} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm11Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm11Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm11Regs}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 503} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm12Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm12Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm12Regs}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 511} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm1Regs}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 423} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm2Regs}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 431} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm3Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm3Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm3Regs}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 439} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm4Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm4Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm4Regs}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 447} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm5Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm5Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm5Regs}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 455} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm6Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm6Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm6Regs}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 463} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm7Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm7Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm7Regs}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 471} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm8Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm8Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm8Regs}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 479} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EPwm9Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EPwm9Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EPWM_REGS EPwm9Regs}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 487} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EQep1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EQep1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EQEP_REGS EQep1Regs}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 399} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EQep2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EQep2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EQEP_REGS EQep2Regs}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 407} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v EQep3Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:EQep3Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct EQEP_REGS EQep3Regs}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 415} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Flash0CtrlRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Flash0CtrlRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct FLASH_CTRL_REGS Flash0CtrlRegs}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 870} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Flash0EccRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Flash0EccRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct FLASH_ECC_REGS Flash0EccRegs}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 862} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v GpioDataRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:GpioDataRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct GPIO_DATA_REGS GpioDataRegs}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 539} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v I2caRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:I2caRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct I2C_REGS I2caRegs}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 577} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v I2cbRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:I2cbRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct I2C_REGS I2cbRegs}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 585} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v McbspaRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:McbspaRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct McBSP_REGS McbspaRegs}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 633} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v McbspbRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:McbspbRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct McBSP_REGS McbspbRegs}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 703} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v MemCfgRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:MemCfgRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct MEM_CFG_REGS MemCfgRegs}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 651} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v MemoryErrorRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:MemoryErrorRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct MEMORY_ERROR_REGS MemoryErrorRegs}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 695} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v NmiIntruptRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:NmiIntruptRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct NMI_INTRUPT_REGS NmiIntruptRegs}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 711} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v PieCtrlRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:PieCtrlRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct PIE_CTRL_REGS PieCtrlRegs}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 719} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v PieVectTable\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:PieVectTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct PIE_VECT_TABLE PieVectTable}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 727} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v SciaRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:SciaRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SCI_REGS SciaRegs}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 735} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ScibRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ScibRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SCI_REGS ScibRegs}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 743} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ScicRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ScicRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SCI_REGS ScicRegs}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 751} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v ScidRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:ScidRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SCI_REGS ScidRegs}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 759} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Sdfm1Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Sdfm1Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SDFM_REGS Sdfm1Regs}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 791} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v Sdfm2Regs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:Sdfm2Regs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SDFM_REGS Sdfm2Regs}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 799} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v SpiaRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:SpiaRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SPI_REGS SpiaRegs}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 767} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v SpibRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:SpibRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SPI_REGS SpibRegs}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 775} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v SpicRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:SpicRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct SPI_REGS SpicRegs}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 783} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v WdRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:WdRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct WD_REGS WdRegs}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 828} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
{\xe \v XintRegs\:F2837xD_GlobalVariableDefs.c}
{\xe \v F2837xD_GlobalVariableDefs.c\:XintRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile struct XINT_REGS XintRegs}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 836} of file {\b F2837xD_GlobalVariableDefs.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_GlobalVariableDefs.c\par \pard\plain 
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:    F2837xD_GlobalVariableDefs.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:   F2837xD Global Variables and Data Section Pragmas.}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf21 #include "F2837xD_device.h"}     {\cf20 // F2837xD Headerfile Include File}\par
00044 \par
00045 {\cf20 //---------------------------------------------------------------------------}\par
00046 {\cf20 // Define Global Peripheral Variables:}\par
00047 {\cf20 //}\par
00048 {\cf20 //----------------------------------------}\par
00049 {\cf21 #ifdef __cplusplus}\par
00050 {\cf21 #pragma DATA_SECTION("AdcaRegsFile")}\par
00051 {\cf21 #else}\par
00052 {\cf21 #pragma DATA_SECTION(AdcaRegs,"AdcaRegsFile");}\par
00053 {\cf21 #endif}\par
00054 {\cf17 volatile} {\cf17 struct }ADC_REGS AdcaRegs;\par
00055 \par
00056 {\cf21 #ifdef __cplusplus}\par
00057 {\cf21 #pragma DATA_SECTION("AdcbRegsFile")}\par
00058 {\cf21 #else}\par
00059 {\cf21 #pragma DATA_SECTION(AdcbRegs,"AdcbRegsFile");}\par
00060 {\cf21 #endif}\par
00061 {\cf17 volatile} {\cf17 struct }ADC_REGS AdcbRegs;\par
00062 \par
00063 {\cf21 #ifdef __cplusplus}\par
00064 {\cf21 #pragma DATA_SECTION("AdccRegsFile")}\par
00065 {\cf21 #else}\par
00066 {\cf21 #pragma DATA_SECTION(AdccRegs,"AdccRegsFile");}\par
00067 {\cf21 #endif}\par
00068 {\cf17 volatile} {\cf17 struct }ADC_REGS AdccRegs;\par
00069 \par
00070 {\cf21 #ifdef __cplusplus}\par
00071 {\cf21 #pragma DATA_SECTION("AdcdRegsFile")}\par
00072 {\cf21 #else}\par
00073 {\cf21 #pragma DATA_SECTION(AdcdRegs,"AdcdRegsFile");}\par
00074 {\cf21 #endif}\par
00075 {\cf17 volatile} {\cf17 struct }ADC_REGS AdcdRegs;\par
00076 \par
00077 {\cf20 //----------------------------------------}\par
00078 {\cf21 #ifdef __cplusplus}\par
00079 {\cf21 #pragma DATA_SECTION("AdcaResultFile")}\par
00080 {\cf21 #else}\par
00081 {\cf21 #pragma DATA_SECTION(AdcaResultRegs,"AdcaResultFile");}\par
00082 {\cf21 #endif}\par
00083 {\cf17 volatile} {\cf17 struct }ADC_RESULT_REGS AdcaResultRegs;\par
00084 \par
00085 {\cf20 //----------------------------------------}\par
00086 {\cf21 #ifdef __cplusplus}\par
00087 {\cf21 #pragma DATA_SECTION("AdcbResultFile")}\par
00088 {\cf21 #else}\par
00089 {\cf21 #pragma DATA_SECTION(AdcbResultRegs,"AdcbResultFile");}\par
00090 {\cf21 #endif}\par
00091 {\cf17 volatile} {\cf17 struct }ADC_RESULT_REGS AdcbResultRegs;\par
00092 \par
00093 {\cf20 //----------------------------------------}\par
00094 {\cf21 #ifdef __cplusplus}\par
00095 {\cf21 #pragma DATA_SECTION("AdccResultFile")}\par
00096 {\cf21 #else}\par
00097 {\cf21 #pragma DATA_SECTION(AdccResultRegs,"AdccResultFile");}\par
00098 {\cf21 #endif}\par
00099 {\cf17 volatile} {\cf17 struct }ADC_RESULT_REGS AdccResultRegs;\par
00100 \par
00101 {\cf20 //----------------------------------------}\par
00102 {\cf21 #ifdef __cplusplus}\par
00103 {\cf21 #pragma DATA_SECTION("AdcdResultFile")}\par
00104 {\cf21 #else}\par
00105 {\cf21 #pragma DATA_SECTION(AdcdResultRegs,"AdcdResultFile");}\par
00106 {\cf21 #endif}\par
00107 {\cf17 volatile} {\cf17 struct }ADC_RESULT_REGS AdcdResultRegs;\par
00108 \par
00109 {\cf20 //----------------------------------------}\par
00110 {\cf21 #ifdef CPU1}\par
00111 {\cf21 #ifdef __cplusplus}\par
00112 {\cf21 #pragma DATA_SECTION("AnalogSubsysRegsFile")}\par
00113 {\cf21 #else}\par
00114 {\cf21 #pragma DATA_SECTION(AnalogSubsysRegs,"AnalogSubsysRegsFile");}\par
00115 {\cf21 #endif}\par
00116 {\cf17 volatile} {\cf17 struct }ANALOG_SUBSYS_REGS AnalogSubsysRegs;\par
00117 {\cf21 #endif}\par
00118 \par
00119 {\cf21 #if __TI_COMPILER_VERSION__ >= 16006000}\par
00120 {\cf20 //----------------------------------------}\par
00121 {\cf21 #ifdef __cplusplus}\par
00122 {\cf21 #pragma DATA_SECTION("CanaRegsFile")}\par
00123 {\cf21 #else}\par
00124 {\cf21 #pragma DATA_SECTION(CanaRegs,"CanaRegsFile");}\par
00125 {\cf21 #endif}\par
00126 {\cf17 volatile} {\cf17 struct }CAN_REGS CanaRegs;\par
00127 \par
00128 {\cf20 //----------------------------------------}\par
00129 {\cf21 #ifdef __cplusplus}\par
00130 {\cf21 #pragma DATA_SECTION("CanbRegsFile")}\par
00131 {\cf21 #else}\par
00132 {\cf21 #pragma DATA_SECTION(CanbRegs,"CanbRegsFile");}\par
00133 {\cf21 #endif}\par
00134 {\cf17 volatile} {\cf17 struct }CAN_REGS CanbRegs;\par
00135 {\cf21 #endif}\par
00136 \par
00137 {\cf20 //----------------------------------------}\par
00138 {\cf21 #ifdef __cplusplus}\par
00139 {\cf21 #pragma DATA_SECTION("Cmpss1RegsFile")}\par
00140 {\cf21 #else}\par
00141 {\cf21 #pragma DATA_SECTION(Cmpss1Regs,"Cmpss1RegsFile");}\par
00142 {\cf21 #endif}\par
00143 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss1Regs;\par
00144 \par
00145 {\cf20 //----------------------------------------}\par
00146 {\cf21 #ifdef __cplusplus}\par
00147 {\cf21 #pragma DATA_SECTION("Cmpss2RegsFile")}\par
00148 {\cf21 #else}\par
00149 {\cf21 #pragma DATA_SECTION(Cmpss2Regs,"Cmpss2RegsFile");}\par
00150 {\cf21 #endif}\par
00151 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss2Regs;\par
00152 \par
00153 {\cf20 //----------------------------------------}\par
00154 {\cf21 #ifdef __cplusplus}\par
00155 {\cf21 #pragma DATA_SECTION("Cmpss3RegsFile")}\par
00156 {\cf21 #else}\par
00157 {\cf21 #pragma DATA_SECTION(Cmpss3Regs,"Cmpss3RegsFile");}\par
00158 {\cf21 #endif}\par
00159 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss3Regs;\par
00160 \par
00161 {\cf20 //----------------------------------------}\par
00162 {\cf21 #ifdef __cplusplus}\par
00163 {\cf21 #pragma DATA_SECTION("Cmpss4RegsFile")}\par
00164 {\cf21 #else}\par
00165 {\cf21 #pragma DATA_SECTION(Cmpss4Regs,"Cmpss4RegsFile");}\par
00166 {\cf21 #endif}\par
00167 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss4Regs;\par
00168 \par
00169 {\cf20 //----------------------------------------}\par
00170 {\cf21 #ifdef __cplusplus}\par
00171 {\cf21 #pragma DATA_SECTION("Cmpss5RegsFile")}\par
00172 {\cf21 #else}\par
00173 {\cf21 #pragma DATA_SECTION(Cmpss5Regs,"Cmpss5RegsFile");}\par
00174 {\cf21 #endif}\par
00175 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss5Regs;\par
00176 \par
00177 {\cf20 //----------------------------------------}\par
00178 {\cf21 #ifdef __cplusplus}\par
00179 {\cf21 #pragma DATA_SECTION("Cmpss6RegsFile")}\par
00180 {\cf21 #else}\par
00181 {\cf21 #pragma DATA_SECTION(Cmpss6Regs,"Cmpss6RegsFile");}\par
00182 {\cf21 #endif}\par
00183 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss6Regs;\par
00184 \par
00185 {\cf20 //----------------------------------------}\par
00186 {\cf21 #ifdef __cplusplus}\par
00187 {\cf21 #pragma DATA_SECTION("Cmpss7RegsFile")}\par
00188 {\cf21 #else}\par
00189 {\cf21 #pragma DATA_SECTION(Cmpss7Regs,"Cmpss7RegsFile");}\par
00190 {\cf21 #endif}\par
00191 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss7Regs;\par
00192 \par
00193 {\cf20 //----------------------------------------}\par
00194 {\cf21 #ifdef __cplusplus}\par
00195 {\cf21 #pragma DATA_SECTION("Cmpss8RegsFile")}\par
00196 {\cf21 #else}\par
00197 {\cf21 #pragma DATA_SECTION(Cmpss8Regs,"Cmpss8RegsFile");}\par
00198 {\cf21 #endif}\par
00199 {\cf17 volatile} {\cf17 struct }CMPSS_REGS Cmpss8Regs;\par
00200 \par
00201 {\cf20 //----------------------------------------}\par
00202 {\cf21 #ifdef __cplusplus}\par
00203 {\cf21 #pragma DATA_SECTION("DacaRegsFile")}\par
00204 {\cf21 #else}\par
00205 {\cf21 #pragma DATA_SECTION(DacaRegs,"DacaRegsFile");}\par
00206 {\cf21 #endif}\par
00207 {\cf17 volatile} {\cf17 struct }DAC_REGS DacaRegs;\par
00208 \par
00209 {\cf20 //----------------------------------------}\par
00210 {\cf21 #ifdef __cplusplus}\par
00211 {\cf21 #pragma DATA_SECTION("DacbRegsFile")}\par
00212 {\cf21 #else}\par
00213 {\cf21 #pragma DATA_SECTION(DacbRegs,"DacbRegsFile");}\par
00214 {\cf21 #endif}\par
00215 {\cf17 volatile} {\cf17 struct }DAC_REGS DacbRegs;\par
00216 \par
00217 {\cf20 //----------------------------------------}\par
00218 {\cf21 #ifdef __cplusplus}\par
00219 {\cf21 #pragma DATA_SECTION("DaccRegsFile")}\par
00220 {\cf21 #else}\par
00221 {\cf21 #pragma DATA_SECTION(DaccRegs,"DaccRegsFile");}\par
00222 {\cf21 #endif}\par
00223 {\cf17 volatile} {\cf17 struct }DAC_REGS DaccRegs;\par
00224 {\cf20 //----------------------------------------}\par
00225 \par
00226 {\cf21 #ifdef __cplusplus}\par
00227 {\cf21 #pragma DATA_SECTION("Cla1RegsFile")}\par
00228 {\cf21 #else}\par
00229 {\cf21 #pragma DATA_SECTION(Cla1Regs,"Cla1RegsFile");}\par
00230 {\cf21 #endif}\par
00231 {\cf17 volatile} {\cf17 struct }CLA_REGS Cla1Regs;\par
00232 {\cf20 //----------------------------------------}\par
00233 {\cf21 #ifdef __cplusplus}\par
00234 {\cf21 #pragma DATA_SECTION("Cla1SoftIntRegsFile")}\par
00235 {\cf21 #else}\par
00236 {\cf21 #pragma DATA_SECTION(Cla1SoftIntRegs,"Cla1SoftIntRegsFile");}\par
00237 {\cf21 #endif}\par
00238 {\cf17 volatile} {\cf17 struct }CLA_SOFTINT_REGS Cla1SoftIntRegs;\par
00239 {\cf20 //----------------------------------------}\par
00240 {\cf21 #ifdef __cplusplus}\par
00241 {\cf21 #pragma DATA_SECTION("ClkCfgRegsFile")}\par
00242 {\cf21 #else}\par
00243 {\cf21 #pragma DATA_SECTION(ClkCfgRegs,"ClkCfgRegsFile");}\par
00244 {\cf21 #endif}\par
00245 {\cf17 volatile} {\cf17 struct }CLK_CFG_REGS ClkCfgRegs;\par
00246 \par
00247 {\cf20 //----------------------------------------}\par
00248 {\cf21 #ifdef __cplusplus}\par
00249 {\cf21 #pragma DATA_SECTION("CpuSysRegsFile")}\par
00250 {\cf21 #else}\par
00251 {\cf21 #pragma DATA_SECTION(CpuSysRegs,"CpuSysRegsFile");}\par
00252 {\cf21 #endif}\par
00253 {\cf17 volatile} {\cf17 struct }CPU_SYS_REGS CpuSysRegs;\par
00254 \par
00255 {\cf20 //----------------------------------------}\par
00256 {\cf21 #ifdef __cplusplus}\par
00257 {\cf21 #pragma DATA_SECTION("CpuTimer0RegsFile")}\par
00258 {\cf21 #else}\par
00259 {\cf21 #pragma DATA_SECTION(CpuTimer0Regs,"CpuTimer0RegsFile");}\par
00260 {\cf21 #endif}\par
00261 {\cf17 volatile} {\cf17 struct }CPUTIMER_REGS CpuTimer0Regs;\par
00262 \par
00263 {\cf20 //----------------------------------------}\par
00264 {\cf21 #ifdef __cplusplus}\par
00265 {\cf21 #pragma DATA_SECTION("CpuTimer1RegsFile")}\par
00266 {\cf21 #else}\par
00267 {\cf21 #pragma DATA_SECTION(CpuTimer1Regs,"CpuTimer1RegsFile");}\par
00268 {\cf21 #endif}\par
00269 {\cf17 volatile} {\cf17 struct }CPUTIMER_REGS CpuTimer1Regs;\par
00270 \par
00271 {\cf20 //----------------------------------------}\par
00272 {\cf21 #ifdef __cplusplus}\par
00273 {\cf21 #pragma DATA_SECTION("CpuTimer2RegsFile")}\par
00274 {\cf21 #else}\par
00275 {\cf21 #pragma DATA_SECTION(CpuTimer2Regs,"CpuTimer2RegsFile");}\par
00276 {\cf21 #endif}\par
00277 {\cf17 volatile} {\cf17 struct }CPUTIMER_REGS CpuTimer2Regs;\par
00278 \par
00279 {\cf20 //----------------------------------------}\par
00280 {\cf21 #ifdef __cplusplus}\par
00281 {\cf21 #pragma DATA_SECTION("DcsmZ1RegsFile")}\par
00282 {\cf21 #else}\par
00283 {\cf21 #pragma DATA_SECTION(DcsmZ1Regs,"DcsmZ1RegsFile");}\par
00284 {\cf21 #endif}\par
00285 {\cf17 volatile} {\cf17 struct }DCSM_Z1_REGS DcsmZ1Regs;\par
00286 \par
00287 {\cf20 //----------------------------------------}\par
00288 {\cf21 #ifdef __cplusplus}\par
00289 {\cf21 #pragma DATA_SECTION("DcsmZ2RegsFile")}\par
00290 {\cf21 #else}\par
00291 {\cf21 #pragma DATA_SECTION(DcsmZ2Regs,"DcsmZ2RegsFile");}\par
00292 {\cf21 #endif}\par
00293 {\cf17 volatile} {\cf17 struct }DCSM_Z2_REGS DcsmZ2Regs;\par
00294 \par
00295 {\cf20 //----------------------------------------}\par
00296 {\cf21 #ifdef __cplusplus}\par
00297 {\cf21 #pragma DATA_SECTION("DcsmCommonRegsFile")}\par
00298 {\cf21 #else}\par
00299 {\cf21 #pragma DATA_SECTION(DcsmCommonRegs,"DcsmCommonRegsFile");}\par
00300 {\cf21 #endif}\par
00301 {\cf17 volatile} {\cf17 struct }DCSM_COMMON_REGS DcsmCommonRegs;\par
00302 \par
00303 {\cf20 //----------------------------------------}\par
00304 {\cf21 #ifdef __cplusplus}\par
00305 {\cf21 #pragma DATA_SECTION("DmaRegsFile")}\par
00306 {\cf21 #else}\par
00307 {\cf21 #pragma DATA_SECTION(DmaRegs,"DmaRegsFile");}\par
00308 {\cf21 #endif}\par
00309 {\cf17 volatile} {\cf17 struct }DMA_REGS DmaRegs;\par
00310 \par
00311 {\cf20 //----------------------------------------}\par
00312 {\cf21 #ifdef __cplusplus}\par
00313 {\cf21 #pragma DATA_SECTION("DmaClaSrcSelRegsFile")}\par
00314 {\cf21 #else}\par
00315 {\cf21 #pragma DATA_SECTION(DmaClaSrcSelRegs,"DmaClaSrcSelRegsFile");}\par
00316 {\cf21 #endif}\par
00317 {\cf17 volatile} {\cf17 struct }DMA_CLA_SRC_SEL_REGS DmaClaSrcSelRegs;\par
00318 \par
00319 {\cf20 //----------------------------------------}\par
00320 {\cf21 #ifdef CPU1}\par
00321 {\cf21 #ifdef __cplusplus}\par
00322 {\cf21 #pragma DATA_SECTION("DevCfgRegsFile")}\par
00323 {\cf21 #else}\par
00324 {\cf21 #pragma DATA_SECTION(DevCfgRegs,"DevCfgRegsFile");}\par
00325 {\cf21 #endif}\par
00326 {\cf17 volatile} {\cf17 struct }DEV_CFG_REGS DevCfgRegs;\par
00327 {\cf21 #endif}\par
00328 \par
00329 {\cf20 //----------------------------------------}\par
00330 {\cf21 #ifdef __cplusplus}\par
00331 {\cf21 #pragma DATA_SECTION("ECap1RegsFile")}\par
00332 {\cf21 #else}\par
00333 {\cf21 #pragma DATA_SECTION(ECap1Regs,"ECap1RegsFile");}\par
00334 {\cf21 #endif}\par
00335 {\cf17 volatile} {\cf17 struct }ECAP_REGS ECap1Regs;\par
00336 \par
00337 {\cf20 //----------------------------------------}\par
00338 {\cf21 #ifdef __cplusplus}\par
00339 {\cf21 #pragma DATA_SECTION("ECap2RegsFile")}\par
00340 {\cf21 #else}\par
00341 {\cf21 #pragma DATA_SECTION(ECap2Regs,"ECap2RegsFile");}\par
00342 {\cf21 #endif}\par
00343 {\cf17 volatile} {\cf17 struct }ECAP_REGS ECap2Regs;\par
00344 \par
00345 {\cf20 //----------------------------------------}\par
00346 {\cf21 #ifdef __cplusplus}\par
00347 {\cf21 #pragma DATA_SECTION("ECap3RegsFile")}\par
00348 {\cf21 #else}\par
00349 {\cf21 #pragma DATA_SECTION(ECap3Regs,"ECap3RegsFile");}\par
00350 {\cf21 #endif}\par
00351 {\cf17 volatile} {\cf17 struct }ECAP_REGS ECap3Regs;\par
00352 \par
00353 {\cf20 //----------------------------------------}\par
00354 {\cf21 #ifdef __cplusplus}\par
00355 {\cf21 #pragma DATA_SECTION("ECap4RegsFile")}\par
00356 {\cf21 #else}\par
00357 {\cf21 #pragma DATA_SECTION(ECap4Regs,"ECap4RegsFile");}\par
00358 {\cf21 #endif}\par
00359 {\cf17 volatile} {\cf17 struct }ECAP_REGS ECap4Regs;\par
00360 \par
00361 {\cf20 //----------------------------------------}\par
00362 {\cf21 #ifdef __cplusplus}\par
00363 {\cf21 #pragma DATA_SECTION("ECap5RegsFile")}\par
00364 {\cf21 #else}\par
00365 {\cf21 #pragma DATA_SECTION(ECap5Regs,"ECap5RegsFile");}\par
00366 {\cf21 #endif}\par
00367 {\cf17 volatile} {\cf17 struct }ECAP_REGS ECap5Regs;\par
00368 \par
00369 {\cf20 //----------------------------------------}\par
00370 {\cf21 #ifdef __cplusplus}\par
00371 {\cf21 #pragma DATA_SECTION("ECap6RegsFile")}\par
00372 {\cf21 #else}\par
00373 {\cf21 #pragma DATA_SECTION(ECap6Regs,"ECap6RegsFile");}\par
00374 {\cf21 #endif}\par
00375 {\cf17 volatile} {\cf17 struct }ECAP_REGS ECap6Regs;\par
00376 \par
00377 {\cf20 //----------------------------------------}\par
00378 {\cf21 #ifdef __cplusplus}\par
00379 {\cf21 #pragma DATA_SECTION("Emif1RegsFile")}\par
00380 {\cf21 #else}\par
00381 {\cf21 #pragma DATA_SECTION(Emif1Regs,"Emif1RegsFile");}\par
00382 {\cf21 #endif}\par
00383 {\cf17 volatile} {\cf17 struct }EMIF_REGS  Emif1Regs;\par
00384 \par
00385 {\cf20 //----------------------------------------}\par
00386 {\cf21 #ifdef __cplusplus}\par
00387 {\cf21 #pragma DATA_SECTION("Emif2RegsFile")}\par
00388 {\cf21 #else}\par
00389 {\cf21 #pragma DATA_SECTION(Emif2Regs,"Emif2RegsFile");}\par
00390 {\cf21 #endif}\par
00391 {\cf17 volatile} {\cf17 struct }EMIF_REGS  Emif2Regs;\par
00392 \par
00393 {\cf20 //----------------------------------------}\par
00394 {\cf21 #ifdef __cplusplus}\par
00395 {\cf21 #pragma DATA_SECTION("EQep1RegsFile")}\par
00396 {\cf21 #else}\par
00397 {\cf21 #pragma DATA_SECTION(EQep1Regs,"EQep1RegsFile");}\par
00398 {\cf21 #endif}\par
00399 {\cf17 volatile} {\cf17 struct }EQEP_REGS EQep1Regs;\par
00400 \par
00401 {\cf20 //----------------------------------------}\par
00402 {\cf21 #ifdef __cplusplus}\par
00403 {\cf21 #pragma DATA_SECTION("EQep2RegsFile")}\par
00404 {\cf21 #else}\par
00405 {\cf21 #pragma DATA_SECTION(EQep2Regs,"EQep2RegsFile");}\par
00406 {\cf21 #endif}\par
00407 {\cf17 volatile} {\cf17 struct }EQEP_REGS EQep2Regs;\par
00408 \par
00409 {\cf20 //----------------------------------------}\par
00410 {\cf21 #ifdef __cplusplus}\par
00411 {\cf21 #pragma DATA_SECTION("EQep3RegsFile")}\par
00412 {\cf21 #else}\par
00413 {\cf21 #pragma DATA_SECTION(EQep3Regs,"EQep3RegsFile");}\par
00414 {\cf21 #endif}\par
00415 {\cf17 volatile} {\cf17 struct }EQEP_REGS EQep3Regs;\par
00416 \par
00417 {\cf20 //----------------------------------------}\par
00418 {\cf21 #ifdef __cplusplus}\par
00419 {\cf21 #pragma DATA_SECTION("EPwm1RegsFile")}\par
00420 {\cf21 #else}\par
00421 {\cf21 #pragma DATA_SECTION(EPwm1Regs,"EPwm1RegsFile");}\par
00422 {\cf21 #endif}\par
00423 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm1Regs;\par
00424 \par
00425 {\cf20 //----------------------------------------}\par
00426 {\cf21 #ifdef __cplusplus}\par
00427 {\cf21 #pragma DATA_SECTION("EPwm2RegsFile")}\par
00428 {\cf21 #else}\par
00429 {\cf21 #pragma DATA_SECTION(EPwm2Regs,"EPwm2RegsFile");}\par
00430 {\cf21 #endif}\par
00431 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm2Regs;\par
00432 \par
00433 {\cf20 //----------------------------------------}\par
00434 {\cf21 #ifdef __cplusplus}\par
00435 {\cf21 #pragma DATA_SECTION("EPwm3RegsFile")}\par
00436 {\cf21 #else}\par
00437 {\cf21 #pragma DATA_SECTION(EPwm3Regs,"EPwm3RegsFile");}\par
00438 {\cf21 #endif}\par
00439 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm3Regs;\par
00440 \par
00441 {\cf20 //----------------------------------------}\par
00442 {\cf21 #ifdef __cplusplus}\par
00443 {\cf21 #pragma DATA_SECTION("EPwm4RegsFile")}\par
00444 {\cf21 #else}\par
00445 {\cf21 #pragma DATA_SECTION(EPwm4Regs,"EPwm4RegsFile");}\par
00446 {\cf21 #endif}\par
00447 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm4Regs;\par
00448 \par
00449 {\cf20 //----------------------------------------}\par
00450 {\cf21 #ifdef __cplusplus}\par
00451 {\cf21 #pragma DATA_SECTION("EPwm5RegsFile")}\par
00452 {\cf21 #else}\par
00453 {\cf21 #pragma DATA_SECTION(EPwm5Regs,"EPwm5RegsFile");}\par
00454 {\cf21 #endif}\par
00455 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm5Regs;\par
00456 \par
00457 {\cf20 //----------------------------------------}\par
00458 {\cf21 #ifdef __cplusplus}\par
00459 {\cf21 #pragma DATA_SECTION("EPwm6RegsFile")}\par
00460 {\cf21 #else}\par
00461 {\cf21 #pragma DATA_SECTION(EPwm6Regs,"EPwm6RegsFile");}\par
00462 {\cf21 #endif}\par
00463 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm6Regs;\par
00464 \par
00465 {\cf20 //----------------------------------------}\par
00466 {\cf21 #ifdef __cplusplus}\par
00467 {\cf21 #pragma DATA_SECTION("EPwm7RegsFile")}\par
00468 {\cf21 #else}\par
00469 {\cf21 #pragma DATA_SECTION(EPwm7Regs,"EPwm7RegsFile");}\par
00470 {\cf21 #endif}\par
00471 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm7Regs;\par
00472 \par
00473 {\cf20 //----------------------------------------}\par
00474 {\cf21 #ifdef __cplusplus}\par
00475 {\cf21 #pragma DATA_SECTION("EPwm8RegsFile")}\par
00476 {\cf21 #else}\par
00477 {\cf21 #pragma DATA_SECTION(EPwm8Regs,"EPwm8RegsFile");}\par
00478 {\cf21 #endif}\par
00479 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm8Regs;\par
00480 \par
00481 {\cf20 //----------------------------------------}\par
00482 {\cf21 #ifdef __cplusplus}\par
00483 {\cf21 #pragma DATA_SECTION("EPwm9RegsFile")}\par
00484 {\cf21 #else}\par
00485 {\cf21 #pragma DATA_SECTION(EPwm9Regs,"EPwm9RegsFile");}\par
00486 {\cf21 #endif}\par
00487 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm9Regs;\par
00488 \par
00489 {\cf20 //----------------------------------------}\par
00490 {\cf21 #ifdef __cplusplus}\par
00491 {\cf21 #pragma DATA_SECTION("EPwm10RegsFile")}\par
00492 {\cf21 #else}\par
00493 {\cf21 #pragma DATA_SECTION(EPwm10Regs,"EPwm10RegsFile");}\par
00494 {\cf21 #endif}\par
00495 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm10Regs;\par
00496 \par
00497 {\cf20 //----------------------------------------}\par
00498 {\cf21 #ifdef __cplusplus}\par
00499 {\cf21 #pragma DATA_SECTION("EPwm11RegsFile")}\par
00500 {\cf21 #else}\par
00501 {\cf21 #pragma DATA_SECTION(EPwm11Regs,"EPwm11RegsFile");}\par
00502 {\cf21 #endif}\par
00503 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm11Regs;\par
00504 \par
00505 {\cf20 //----------------------------------------}\par
00506 {\cf21 #ifdef __cplusplus}\par
00507 {\cf21 #pragma DATA_SECTION("EPwm12RegsFile")}\par
00508 {\cf21 #else}\par
00509 {\cf21 #pragma DATA_SECTION(EPwm12Regs,"EPwm12RegsFile");}\par
00510 {\cf21 #endif}\par
00511 {\cf17 volatile} {\cf17 struct }EPWM_REGS EPwm12Regs;\par
00512 \par
00513 {\cf20 //----------------------------------------}\par
00514 {\cf21 #ifdef CPU1}\par
00515 {\cf21 #ifdef __cplusplus}\par
00516 {\cf21 #pragma DATA_SECTION("EPwmXbarRegsFile")}\par
00517 {\cf21 #else}\par
00518 {\cf21 #pragma DATA_SECTION(EPwmXbarRegs,"EPwmXbarRegsFile");}\par
00519 {\cf21 #endif}\par
00520 {\cf17 volatile} {\cf17 struct }EPWM_XBAR_REGS EPwmXbarRegs;\par
00521 {\cf21 #endif}\par
00522 \par
00523 {\cf20 //----------------------------------------}\par
00524 {\cf21 #ifdef CPU1}\par
00525 {\cf21 #ifdef __cplusplus}\par
00526 {\cf21 #pragma DATA_SECTION("GpioCtrlRegsFile")}\par
00527 {\cf21 #else}\par
00528 {\cf21 #pragma DATA_SECTION(GpioCtrlRegs,"GpioCtrlRegsFile");}\par
00529 {\cf21 #endif}\par
00530 {\cf17 volatile} {\cf17 struct }GPIO_CTRL_REGS GpioCtrlRegs;\par
00531 {\cf21 #endif}\par
00532 \par
00533 {\cf20 //----------------------------------------}\par
00534 {\cf21 #ifdef __cplusplus}\par
00535 {\cf21 #pragma DATA_SECTION("GpioDataRegsFile")}\par
00536 {\cf21 #else}\par
00537 {\cf21 #pragma DATA_SECTION(GpioDataRegs,"GpioDataRegsFile");}\par
00538 {\cf21 #endif}\par
00539 {\cf17 volatile} {\cf17 struct }GPIO_DATA_REGS GpioDataRegs;\par
00540 \par
00541 {\cf20 //----------------------------------------}\par
00542 {\cf21 #ifdef CPU1}\par
00543 {\cf21 #ifdef __cplusplus}\par
00544 {\cf21 #pragma DATA_SECTION("InputXbarRegsFile")}\par
00545 {\cf21 #else}\par
00546 {\cf21 #pragma DATA_SECTION(InputXbarRegs,"InputXbarRegsFile");}\par
00547 {\cf21 #endif}\par
00548 {\cf17 volatile} {\cf17 struct }INPUT_XBAR_REGS InputXbarRegs;\par
00549 {\cf21 #endif}\par
00550 \par
00551 {\cf20 //----------------------------------------}\par
00552 {\cf21 #ifdef CPU1}\par
00553 {\cf21 #ifdef __cplusplus}\par
00554 {\cf21 #pragma DATA_SECTION("XbarRegsFile")}\par
00555 {\cf21 #else}\par
00556 {\cf21 #pragma DATA_SECTION(XbarRegs,"XbarRegsFile");}\par
00557 {\cf21 #endif}\par
00558 {\cf17 volatile} {\cf17 struct }XBAR_REGS XbarRegs;\par
00559 {\cf21 #endif}\par
00560 \par
00561 {\cf20 //----------------------------------------}\par
00562 {\cf21 #ifdef CPU1}\par
00563 {\cf21 #ifdef __cplusplus}\par
00564 {\cf21 #pragma DATA_SECTION("OutputXbarRegsFile")}\par
00565 {\cf21 #else}\par
00566 {\cf21 #pragma DATA_SECTION(OutputXbarRegs,"OutputXbarRegsFile");}\par
00567 {\cf21 #endif}\par
00568 {\cf17 volatile} {\cf17 struct }OUTPUT_XBAR_REGS OutputXbarRegs;\par
00569 {\cf21 #endif}\par
00570 \par
00571 {\cf20 //----------------------------------------}\par
00572 {\cf21 #ifdef __cplusplus}\par
00573 {\cf21 #pragma DATA_SECTION("I2caRegsFile")}\par
00574 {\cf21 #else}\par
00575 {\cf21 #pragma DATA_SECTION(I2caRegs,"I2caRegsFile");}\par
00576 {\cf21 #endif}\par
00577 {\cf17 volatile} {\cf17 struct }I2C_REGS I2caRegs;\par
00578 \par
00579 {\cf20 //----------------------------------------}\par
00580 {\cf21 #ifdef __cplusplus}\par
00581 {\cf21 #pragma DATA_SECTION("I2cbRegsFile")}\par
00582 {\cf21 #else}\par
00583 {\cf21 #pragma DATA_SECTION(I2cbRegs,"I2cbRegsFile");}\par
00584 {\cf21 #endif}\par
00585 {\cf17 volatile} {\cf17 struct }I2C_REGS I2cbRegs;\par
00586 \par
00587 {\cf20 //----------------------------------------}\par
00588 {\cf21 #ifdef CPU1}\par
00589 {\cf21 #ifdef __cplusplus}\par
00590 {\cf21 #pragma DATA_SECTION("IpcRegsFile")}\par
00591 {\cf21 #else}\par
00592 {\cf21 #pragma DATA_SECTION(IpcRegs,"IpcRegsFile");}\par
00593 {\cf21 #endif}\par
00594 {\cf17 volatile} {\cf17 struct }IPC_REGS_CPU1 IpcRegs;\par
00595 {\cf21 #endif}\par
00596 \par
00597 {\cf20 //----------------------------------------}\par
00598 {\cf21 #ifdef CPU2}\par
00599 {\cf21 #ifdef __cplusplus}\par
00600 {\cf21 #pragma DATA_SECTION("IpcRegsFile")}\par
00601 {\cf21 #else}\par
00602 {\cf21 #pragma DATA_SECTION(IpcRegs,"IpcRegsFile");}\par
00603 {\cf21 #endif}\par
00604 {\cf17 volatile} {\cf17 struct }IPC_REGS_CPU2 IpcRegs;\par
00605 {\cf21 #endif}\par
00606 \par
00607 {\cf20 //----------------------------------------}\par
00608 {\cf21 #ifdef CPU1}\par
00609 {\cf21 #ifdef __cplusplus}\par
00610 {\cf21 #pragma DATA_SECTION("FlashPumpSemaphoreRegsFile")}\par
00611 {\cf21 #else}\par
00612 {\cf21 #pragma DATA_SECTION(FlashPumpSemaphoreRegs,"FlashPumpSemaphoreRegsFile");}\par
00613 {\cf21 #endif}\par
00614 {\cf17 volatile} {\cf17 struct }FLASH_PUMP_SEMAPHORE_REGS FlashPumpSemaphoreRegs;\par
00615 {\cf21 #endif}\par
00616 \par
00617 {\cf20 //----------------------------------------}\par
00618 {\cf21 #ifdef CPU2}\par
00619 {\cf21 #ifdef __cplusplus}\par
00620 {\cf21 #pragma DATA_SECTION("FlashPumpSemaphoreRegsFile")}\par
00621 {\cf21 #else}\par
00622 {\cf21 #pragma DATA_SECTION(FlashPumpSemaphoreRegs,"FlashPumpSemaphoreRegsFile");}\par
00623 {\cf21 #endif}\par
00624 {\cf17 volatile} {\cf17 struct }FLASH_PUMP_SEMAPHORE_REGS FlashPumpSemaphoreRegs;\par
00625 {\cf21 #endif}\par
00626 \par
00627 {\cf20 //----------------------------------------}\par
00628 {\cf21 #ifdef __cplusplus}\par
00629 {\cf21 #pragma DATA_SECTION("McbspaRegsFile")}\par
00630 {\cf21 #else}\par
00631 {\cf21 #pragma DATA_SECTION(McbspaRegs,"McbspaRegsFile");}\par
00632 {\cf21 #endif}\par
00633 {\cf17 volatile} {\cf17 struct }McBSP_REGS McbspaRegs;\par
00634 \par
00635 {\cf20 //----------------------------------------}\par
00636 {\cf21 #ifdef CPU1}\par
00637 {\cf21 #ifdef __cplusplus}\par
00638 {\cf21 #pragma DATA_SECTION("RomPrefetchRegsFile")}\par
00639 {\cf21 #else}\par
00640 {\cf21 #pragma DATA_SECTION(RomPrefetchRegs,"RomPrefetchRegsFile");}\par
00641 {\cf21 #endif}\par
00642 {\cf17 volatile} {\cf17 struct }ROM_PREFETCH_REGS RomPrefetchRegs;\par
00643 {\cf21 #endif}\par
00644 \par
00645 {\cf20 //----------------------------------------}\par
00646 {\cf21 #ifdef __cplusplus}\par
00647 {\cf21 #pragma DATA_SECTION("MemCfgRegsFile")}\par
00648 {\cf21 #else}\par
00649 {\cf21 #pragma DATA_SECTION(MemCfgRegs,"MemCfgRegsFile");}\par
00650 {\cf21 #endif}\par
00651 {\cf17 volatile} {\cf17 struct }MEM_CFG_REGS MemCfgRegs;\par
00652 \par
00653 {\cf20 //----------------------------------------}\par
00654 {\cf21 #ifdef __cplusplus}\par
00655 {\cf21 #pragma DATA_SECTION("Emif1ConfigRegsFile")}\par
00656 {\cf21 #else}\par
00657 {\cf21 #pragma DATA_SECTION(Emif1ConfigRegs,"Emif1ConfigRegsFile");}\par
00658 {\cf21 #endif}\par
00659 {\cf17 volatile} {\cf17 struct }EMIF1_CONFIG_REGS Emif1ConfigRegs;\par
00660 \par
00661 {\cf20 //----------------------------------------}\par
00662 {\cf21 #ifdef CPU1}\par
00663 {\cf21 #ifdef __cplusplus}\par
00664 {\cf21 #pragma DATA_SECTION("Emif2ConfigRegsFile")}\par
00665 {\cf21 #else}\par
00666 {\cf21 #pragma DATA_SECTION(Emif2ConfigRegs,"Emif2ConfigRegsFile");}\par
00667 {\cf21 #endif}\par
00668 {\cf17 volatile} {\cf17 struct }EMIF2_CONFIG_REGS Emif2ConfigRegs;\par
00669 {\cf21 #endif}\par
00670 \par
00671 {\cf20 //----------------------------------------}\par
00672 {\cf21 #ifdef CPU1}\par
00673 {\cf21 #ifdef __cplusplus}\par
00674 {\cf21 #pragma DATA_SECTION("RomWaitStateRegsFile")}\par
00675 {\cf21 #else}\par
00676 {\cf21 #pragma DATA_SECTION(RomWaitStateRegs,"RomWaitStateRegsFile");}\par
00677 {\cf21 #endif}\par
00678 {\cf17 volatile} {\cf17 struct }ROM_WAIT_STATE_REGS RomWaitStateRegs;\par
00679 {\cf21 #endif}\par
00680 \par
00681 {\cf20 //----------------------------------------}\par
00682 {\cf21 #ifdef __cplusplus}\par
00683 {\cf21 #pragma DATA_SECTION("AccessProtectionRegsFile")}\par
00684 {\cf21 #else}\par
00685 {\cf21 #pragma DATA_SECTION(AccessProtectionRegs,"AccessProtectionRegsFile");}\par
00686 {\cf21 #endif}\par
00687 {\cf17 volatile} {\cf17 struct }ACCESS_PROTECTION_REGS AccessProtectionRegs;\par
00688 \par
00689 {\cf20 //----------------------------------------}\par
00690 {\cf21 #ifdef __cplusplus}\par
00691 {\cf21 #pragma DATA_SECTION("MemoryErrorRegsFile")}\par
00692 {\cf21 #else}\par
00693 {\cf21 #pragma DATA_SECTION(MemoryErrorRegs,"MemoryErrorRegsFile");}\par
00694 {\cf21 #endif}\par
00695 {\cf17 volatile} {\cf17 struct }MEMORY_ERROR_REGS MemoryErrorRegs;\par
00696 \par
00697 {\cf20 //----------------------------------------}\par
00698 {\cf21 #ifdef __cplusplus}\par
00699 {\cf21 #pragma DATA_SECTION("McbspbRegsFile")}\par
00700 {\cf21 #else}\par
00701 {\cf21 #pragma DATA_SECTION(McbspbRegs,"McbspbRegsFile");}\par
00702 {\cf21 #endif}\par
00703 {\cf17 volatile} {\cf17 struct }McBSP_REGS McbspbRegs;\par
00704 \par
00705 {\cf20 //----------------------------------------}\par
00706 {\cf21 #ifdef __cplusplus}\par
00707 {\cf21 #pragma DATA_SECTION("NmiIntruptRegsFile")}\par
00708 {\cf21 #else}\par
00709 {\cf21 #pragma DATA_SECTION(NmiIntruptRegs,"NmiIntruptRegsFile");}\par
00710 {\cf21 #endif}\par
00711 {\cf17 volatile} {\cf17 struct }NMI_INTRUPT_REGS NmiIntruptRegs;\par
00712 \par
00713 {\cf20 //----------------------------------------}\par
00714 {\cf21 #ifdef __cplusplus}\par
00715 {\cf21 #pragma DATA_SECTION("PieCtrlRegsFile")}\par
00716 {\cf21 #else}\par
00717 {\cf21 #pragma DATA_SECTION(PieCtrlRegs,"PieCtrlRegsFile");}\par
00718 {\cf21 #endif}\par
00719 {\cf17 volatile} {\cf17 struct }PIE_CTRL_REGS PieCtrlRegs;\par
00720 \par
00721 {\cf20 //----------------------------------------}\par
00722 {\cf21 #ifdef __cplusplus}\par
00723 {\cf21 #pragma DATA_SECTION("PieVectTableFile")}\par
00724 {\cf21 #else}\par
00725 {\cf21 #pragma DATA_SECTION(PieVectTable,"PieVectTableFile");}\par
00726 {\cf21 #endif}\par
00727 {\cf17 volatile} {\cf17 struct }PIE_VECT_TABLE PieVectTable;\par
00728 \par
00729 {\cf20 //----------------------------------------}\par
00730 {\cf21 #ifdef __cplusplus}\par
00731 {\cf21 #pragma DATA_SECTION("SciaRegsFile")}\par
00732 {\cf21 #else}\par
00733 {\cf21 #pragma DATA_SECTION(SciaRegs,"SciaRegsFile");}\par
00734 {\cf21 #endif}\par
00735 {\cf17 volatile} {\cf17 struct }SCI_REGS SciaRegs;\par
00736 \par
00737 {\cf20 //----------------------------------------}\par
00738 {\cf21 #ifdef __cplusplus}\par
00739 {\cf21 #pragma DATA_SECTION("ScibRegsFile")}\par
00740 {\cf21 #else}\par
00741 {\cf21 #pragma DATA_SECTION(ScibRegs,"ScibRegsFile");}\par
00742 {\cf21 #endif}\par
00743 {\cf17 volatile} {\cf17 struct }SCI_REGS ScibRegs;\par
00744 \par
00745 {\cf20 //----------------------------------------}\par
00746 {\cf21 #ifdef __cplusplus}\par
00747 {\cf21 #pragma DATA_SECTION("ScicRegsFile")}\par
00748 {\cf21 #else}\par
00749 {\cf21 #pragma DATA_SECTION(ScicRegs,"ScicRegsFile");}\par
00750 {\cf21 #endif}\par
00751 {\cf17 volatile} {\cf17 struct }SCI_REGS ScicRegs;\par
00752 \par
00753 {\cf20 //----------------------------------------}\par
00754 {\cf21 #ifdef __cplusplus}\par
00755 {\cf21 #pragma DATA_SECTION("ScidRegsFile")}\par
00756 {\cf21 #else}\par
00757 {\cf21 #pragma DATA_SECTION(ScidRegs,"ScidRegsFile");}\par
00758 {\cf21 #endif}\par
00759 {\cf17 volatile} {\cf17 struct }SCI_REGS ScidRegs;\par
00760 \par
00761 {\cf20 //----------------------------------------}\par
00762 {\cf21 #ifdef __cplusplus}\par
00763 {\cf21 #pragma DATA_SECTION("SpiaRegsFile")}\par
00764 {\cf21 #else}\par
00765 {\cf21 #pragma DATA_SECTION(SpiaRegs,"SpiaRegsFile");}\par
00766 {\cf21 #endif}\par
00767 {\cf17 volatile} {\cf17 struct }SPI_REGS SpiaRegs;\par
00768 \par
00769 {\cf20 //----------------------------------------}\par
00770 {\cf21 #ifdef __cplusplus}\par
00771 {\cf21 #pragma DATA_SECTION("SpibRegsFile")}\par
00772 {\cf21 #else}\par
00773 {\cf21 #pragma DATA_SECTION(SpibRegs,"SpibRegsFile");}\par
00774 {\cf21 #endif}\par
00775 {\cf17 volatile} {\cf17 struct }SPI_REGS SpibRegs;\par
00776 \par
00777 {\cf20 //----------------------------------------}\par
00778 {\cf21 #ifdef __cplusplus}\par
00779 {\cf21 #pragma DATA_SECTION("SpicRegsFile")}\par
00780 {\cf21 #else}\par
00781 {\cf21 #pragma DATA_SECTION(SpicRegs,"SpicRegsFile");}\par
00782 {\cf21 #endif}\par
00783 {\cf17 volatile} {\cf17 struct }SPI_REGS SpicRegs;\par
00784 \par
00785 {\cf20 //----------------------------------------}\par
00786 {\cf21 #ifdef __cplusplus}\par
00787 {\cf21 #pragma DATA_SECTION("Sdfm1RegsFile")}\par
00788 {\cf21 #else}\par
00789 {\cf21 #pragma DATA_SECTION(Sdfm1Regs,"Sdfm1RegsFile");}\par
00790 {\cf21 #endif}\par
00791 {\cf17 volatile} {\cf17 struct }SDFM_REGS Sdfm1Regs;\par
00792 \par
00793 {\cf20 //----------------------------------------}\par
00794 {\cf21 #ifdef __cplusplus}\par
00795 {\cf21 #pragma DATA_SECTION("Sdfm2RegsFile")}\par
00796 {\cf21 #else}\par
00797 {\cf21 #pragma DATA_SECTION(Sdfm2Regs,"Sdfm2RegsFile");}\par
00798 {\cf21 #endif}\par
00799 {\cf17 volatile} {\cf17 struct }SDFM_REGS Sdfm2Regs;\par
00800 \par
00801 \par
00802 {\cf20 //----------------------------------------}\par
00803 {\cf21 #ifdef CPU1}\par
00804 {\cf21 #ifdef __cplusplus}\par
00805 {\cf21 #pragma DATA_SECTION("SyncSocRegsFile")}\par
00806 {\cf21 #else}\par
00807 {\cf21 #pragma DATA_SECTION(SyncSocRegs,"SyncSocRegsFile");}\par
00808 {\cf21 #endif}\par
00809 {\cf17 volatile} {\cf17 struct }SYNC_SOC_REGS SyncSocRegs;\par
00810 {\cf21 #endif}\par
00811 \par
00812 {\cf20 //----------------------------------------}\par
00813 {\cf21 #if defined(CPU1)}\par
00814 {\cf21 #ifdef __cplusplus}\par
00815 {\cf21 #pragma DATA_SECTION("UppRegsFile")}\par
00816 {\cf21 #else}\par
00817 {\cf21 #pragma DATA_SECTION(UppRegs,"UppRegsFile");}\par
00818 {\cf21 #endif}\par
00819 {\cf17 volatile} {\cf17 struct }UPP_REGS UppRegs;\par
00820 {\cf21 #endif }{\cf20 //defined(CPU1)}\par
00821 \par
00822 {\cf20 //----------------------------------------}\par
00823 {\cf21 #ifdef __cplusplus}\par
00824 {\cf21 #pragma DATA_SECTION("WdRegsFile")}\par
00825 {\cf21 #else}\par
00826 {\cf21 #pragma DATA_SECTION(WdRegs,"WdRegsFile");}\par
00827 {\cf21 #endif}\par
00828 {\cf17 volatile} {\cf17 struct }WD_REGS WdRegs;\par
00829 \par
00830 {\cf20 //----------------------------------------}\par
00831 {\cf21 #ifdef __cplusplus}\par
00832 {\cf21 #pragma DATA_SECTION("XintRegsFile")}\par
00833 {\cf21 #else}\par
00834 {\cf21 #pragma DATA_SECTION(XintRegs,"XintRegsFile");}\par
00835 {\cf21 #endif}\par
00836 {\cf17 volatile} {\cf17 struct }XINT_REGS XintRegs;\par
00837 \par
00838 {\cf20 //--------------------------------------}\par
00839 {\cf21 #ifdef __cplusplus}\par
00840 {\cf21 #pragma DATA_SECTION("EmuBModeVar");}\par
00841 {\cf21 #else}\par
00842 {\cf21 #pragma DATA_SECTION(EmuBMode,"EmuBModeVar");}\par
00843 {\cf21 #endif}\par
00844 Uint16 EmuBMode;\par
00845 \par
00846 {\cf20 //----------------------------------------}\par
00847 {\cf21 #ifdef CPU1}\par
00848 {\cf21 #ifdef __cplusplus}\par
00849 {\cf21 #pragma DATA_SECTION("EmuBootPinsVar");}\par
00850 {\cf21 #else}\par
00851 {\cf21 #pragma DATA_SECTION(EmuBootPins,"EmuBootPinsVar");}\par
00852 {\cf21 #endif}\par
00853 Uint16 EmuBootPins;\par
00854 {\cf21 #endif}\par
00855 \par
00856 {\cf20 //----------------------------------------}\par
00857 {\cf21 #ifdef __cplusplus}\par
00858 {\cf21 #pragma DATA_SECTION("Flash0EccRegsFile")}\par
00859 {\cf21 #else}\par
00860 {\cf21 #pragma DATA_SECTION(Flash0EccRegs,"Flash0EccRegsFile");}\par
00861 {\cf21 #endif}\par
00862 {\cf17 volatile} {\cf17 struct }FLASH_ECC_REGS Flash0EccRegs;\par
00863 \par
00864 {\cf20 //----------------------------------------}\par
00865 {\cf21 #ifdef __cplusplus}\par
00866 {\cf21 #pragma DATA_SECTION("Flash0CtrlRegsFile")}\par
00867 {\cf21 #else}\par
00868 {\cf21 #pragma DATA_SECTION(Flash0CtrlRegs,"Flash0CtrlRegsFile");}\par
00869 {\cf21 #endif}\par
00870 {\cf17 volatile} {\cf17 struct }FLASH_CTRL_REGS Flash0CtrlRegs;\par
00871 \par
00872 \par
00873 {\cf20 //===========================================================================}\par
00874 {\cf20 // End of file.}\par
00875 {\cf20 //===========================================================================}\par
00876 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_Gpio.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_Gpio.c}
{\xe \v F2837xD_Gpio.c}
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Uint16 {\b GPIO_ReadPin} (Uint16 gpioNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GPIO_WritePin} (Uint16 gpioNumber, Uint16 outVal)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v GPIO_ReadPin\:F2837xD_Gpio.c}
{\xe \v F2837xD_Gpio.c\:GPIO_ReadPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Uint16 GPIO_ReadPin (Uint16 gpioNumber)}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 472} of file {\b F2837xD_Gpio.c}.}\par
}
{\xe \v GPIO_WritePin\:F2837xD_Gpio.c}
{\xe \v F2837xD_Gpio.c\:GPIO_WritePin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GPIO_WritePin (Uint16 gpioNumber, Uint16 outVal)}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 486} of file {\b F2837xD_Gpio.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_Gpio.c\par \pard\plain 
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:    F2837xD_Gpio.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:    GPIO module support functions}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}\par
00047 {\cf21 #include "F2837xD_Examples.h"}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 //Low-level functions for GPIO configuration (CPU1 only)}\par
00051 {\cf20 //}\par
00052 \par
00053 {\cf21 #ifdef CPU1}\par
00054     {\cf20 //}\par
00055     {\cf20 // InitGpio - Sets all pins to be muxed to GPIO in input mode with pull-ups}\par
00056     {\cf20 //            enabled. Also resets CPU control to CPU1 and disables open}\par
00057     {\cf20 //            drain and polarity inversion and sets the qualification to}\par
00058     {\cf20 //            synchronous. Also unlocks all GPIOs. Only one CPU should call}\par
00059     {\cf20 //            this function.}\par
00060     {\cf20 //}\par
00061     {\cf18 void} InitGpio()\par
00062     \{\par
00063         {\cf17 volatile} Uint32 *gpioBaseAddr;\par
00064         Uint16 regOffset;\par
00065 \par
00066         {\cf20 //}\par
00067         {\cf20 //Disable pin locks}\par
00068         {\cf20 //}\par
00069         EALLOW;\par
00070         GpioCtrlRegs.GPALOCK.all = 0x00000000;\par
00071         GpioCtrlRegs.GPBLOCK.all = 0x00000000;\par
00072         GpioCtrlRegs.GPCLOCK.all = 0x00000000;\par
00073         GpioCtrlRegs.GPDLOCK.all = 0x00000000;\par
00074         GpioCtrlRegs.GPELOCK.all = 0x00000000;\par
00075         GpioCtrlRegs.GPFLOCK.all = 0x00000000;\par
00076 \par
00077         {\cf20 //}\par
00078         {\cf20 // Fill all registers with zeros. Writing to each register separately}\par
00079         {\cf20 // for six GPIO modules would make this function *very* long.}\par
00080         {\cf20 // Fortunately, we'd be writing them all with zeros anyway, so this}\par
00081         {\cf20 // saves a lot of space.}\par
00082         {\cf20 //}\par
00083         gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\par
00084         {\cf19 for} (regOffset = 0; regOffset < {\cf17 sizeof}(GpioCtrlRegs)/2; regOffset++)\par
00085         \{\par
00086             {\cf20 //}\par
00087             {\cf20 //Hack to avoid enabling pull-ups on all pins. GPyPUD is offset}\par
00088             {\cf20 //0x0C in each register group of 0x40 words. Since this is a}\par
00089             {\cf20 //32-bit pointer, the addresses must be divided by 2.}\par
00090             {\cf20 //}\par
00091             {\cf19 if} (regOffset % (0x40/2) != (0x0C/2))\par
00092             \{\par
00093                 gpioBaseAddr[regOffset] = 0x00000000;\par
00094             \}\par
00095         \}\par
00096 \par
00097         gpioBaseAddr = (Uint32 *)&GpioDataRegs;\par
00098         {\cf19 for} (regOffset = 0; regOffset < {\cf17 sizeof}(GpioDataRegs)/2; regOffset++)\par
00099         \{\par
00100             gpioBaseAddr[regOffset] = 0x00000000;\par
00101         \}\par
00102 \par
00103         EDIS;\par
00104     \}\par
00105 \par
00106     {\cf20 //}\par
00107     {\cf20 // GPIO_SetupPinMux - Set the peripheral muxing for the specified pin. The}\par
00108     {\cf20 //                    appropriate parameters can be found in the GPIO Muxed}\par
00109     {\cf20 //                    Pins table(4.4) in the  datasheet. Use the GPIO index}\par
00110     {\cf20 //                    row (0 to 15) to select a muxing option for the GPIO.}\par
00111     {\cf20 //}\par
00112     {\cf18 void} GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\par
00113     \{\par
00114         {\cf17 volatile} Uint32 *gpioBaseAddr;\par
00115         {\cf17 volatile} Uint32 *mux, *gmux, *csel;\par
00116         Uint16 pin32, pin16, pin8;\par
00117 \par
00118         pin32 = gpioNumber % 32;\par
00119         pin16 = gpioNumber % 16;\par
00120         pin8 = gpioNumber % 8;\par
00121         gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\par
00122 \par
00123         {\cf20 //}\par
00124         {\cf20 //Sanity check for valid cpu and peripheral values}\par
00125         {\cf20 //}\par
00126         {\cf19 if} (cpu > GPIO_MUX_CPU2CLA || muxPosition > 0xF)\par
00127             {\cf19 return};\par
00128 \par
00129         {\cf20 //}\par
00130         {\cf20 //Create pointers to the appropriate registers. This is a workaround}\par
00131         {\cf20 //for the way GPIO registers are defined. The standard definition}\par
00132         {\cf20 //in the header file makes it very easy to do named accesses of one}\par
00133         {\cf20 //register or bit, but hard to do arbitrary numerical accesses. It's}\par
00134         {\cf20 //easier to have an array of GPIO modules with identical registers,}\par
00135         {\cf20 //including arrays for multi-register groups like GPyCSEL1-4. But}\par
00136         {\cf20 //the header file doesn't define anything we can turn into an array,}\par
00137         {\cf20 //so manual pointer arithmetic is used instead.}\par
00138         {\cf20 //}\par
00139         mux = gpioBaseAddr + GPYMUX + pin32/16;\par
00140         gmux = gpioBaseAddr + GPYGMUX + pin32/16;\par
00141         csel = gpioBaseAddr + GPYCSEL + pin32/8;\par
00142 \par
00143         {\cf20 //}\par
00144         {\cf20 //Now for the actual function}\par
00145         {\cf20 //}\par
00146         EALLOW;\par
00147 \par
00148         {\cf20 //}\par
00149         {\cf20 //To change the muxing, set the peripheral mux to 0/GPIO first to avoid}\par
00150         {\cf20 //glitches, then change the group mux, then set the peripheral mux to}\par
00151         {\cf20 //its target value. Finally, set the CPU select. This procedure is}\par
00152         {\cf20 //described in the TRM. Unfortunately, since we don't know the pin in}\par
00153         {\cf20 //advance we can't hardcode a bitfield reference, so there's some}\par
00154         {\cf20 //tricky bit twiddling here.}\par
00155         {\cf20 //}\par
00156         *mux &= ~(0x3UL << (2*pin16));\par
00157         *gmux &= ~(0x3UL << (2*pin16));\par
00158         *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\par
00159         *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\par
00160 \par
00161         *csel &= ~(0x3L << (4*pin8));\par
00162         *csel |= (Uint32)(cpu & 0x3L) << (4*pin8);\par
00163 \par
00164         {\cf20 //}\par
00165         {\cf20 //WARNING: This code does not touch the analog mode select registers,}\par
00166         {\cf20 //which are needed to give the USB module control of its IOs.}\par
00167         {\cf20 //}\par
00168         EDIS;\par
00169     \}\par
00170 \par
00171     {\cf20 //}\par
00172     {\cf20 // GPIO_SetupPinOptions - Setup up the GPIO input/output options for the}\par
00173     {\cf20 //                        specified pin.}\par
00174     {\cf20 //}\par
00175     {\cf20 //The flags are a 16-bit mask produced by ORing together options.}\par
00176     {\cf20 //For input pins, the valid flags are:}\par
00177     {\cf20 //GPIO_PULLUP    Enable pull-up}\par
00178     {\cf20 //GPIO_INVERT    Enable input polarity inversion}\par
00179     {\cf20 //GPIO_SYNC        Synchronize the input latch to PLLSYSCLK}\par
00180     {\cf20 //               (default -- you don't need to specify this)}\par
00181     {\cf20 //GPIO_QUAL3    Use 3-sample qualification}\par
00182     {\cf20 //GPIO_QUAL6    Use 6-sample qualification}\par
00183     {\cf20 //GPIO_ASYNC    Do not use synchronization or qualification}\par
00184     {\cf20 //(Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)}\par
00185     {\cf20 //}\par
00186     {\cf20 //For output pins, the valid flags are:}\par
00187     {\cf20 //GPIO_OPENDRAIN    Output in open drain mode}\par
00188     {\cf20 //GPIO_PULLUP        If open drain enabled, also enable the pull-up}\par
00189     {\cf20 //and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.}\par
00190     {\cf20 //}\par
00191     {\cf20 //With no flags, the default input state is synchronous with no}\par
00192     {\cf20 //pull-up or polarity inversion. The default output state is}\par
00193     {\cf20 //the standard digital output.}\par
00194     {\cf20 //}\par
00195     {\cf18 void} GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\par
00196     \{\par
00197         {\cf17 volatile} Uint32 *gpioBaseAddr;\par
00198         {\cf17 volatile} Uint32 *dir, *pud, *inv, *odr, *qsel;\par
00199         Uint32 pin32, pin16, pinMask, qual;\par
00200 \par
00201         pin32 = gpioNumber % 32;\par
00202         pin16 = gpioNumber % 16;\par
00203         pinMask = 1UL << pin32;\par
00204         gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\par
00205 \par
00206         {\cf20 //}\par
00207         {\cf20 //Create pointers to the appropriate registers. This is a workaround}\par
00208         {\cf20 //for the way GPIO registers are defined. The standard definition}\par
00209         {\cf20 //in the header file makes it very easy to do named accesses of one}\par
00210         {\cf20 //register or bit, but hard to do arbitrary numerical accesses. It's}\par
00211         {\cf20 //easier to have an array of GPIO modules with identical registers,}\par
00212         {\cf20 //including arrays for multi-register groups like GPyQSEL1-2. But}\par
00213         {\cf20 //the header file doesn't define anything we can turn into an array,}\par
00214         {\cf20 //so manual pointer arithmetic is used instead.}\par
00215         {\cf20 //}\par
00216         dir = gpioBaseAddr + GPYDIR;\par
00217         pud = gpioBaseAddr + GPYPUD;\par
00218         inv = gpioBaseAddr + GPYINV;\par
00219         odr = gpioBaseAddr + GPYODR;\par
00220         qsel = gpioBaseAddr + GPYQSEL + pin32/16;\par
00221 \par
00222         EALLOW;\par
00223 \par
00224         {\cf20 //}\par
00225         {\cf20 //Set the data direction}\par
00226         {\cf20 //}\par
00227         *dir &= ~pinMask;\par
00228         {\cf19 if} (output == 1)\par
00229         \{\par
00230             {\cf20 //}\par
00231             {\cf20 //Output, with optional open drain mode and pull-up}\par
00232             {\cf20 //}\par
00233             *dir |= pinMask;\par
00234 \par
00235             {\cf20 //}\par
00236             {\cf20 //Enable open drain if necessary}\par
00237             {\cf20 //}\par
00238             {\cf19 if} (flags & GPIO_OPENDRAIN)\par
00239             \{\par
00240                 *odr |= pinMask;\par
00241             \}\par
00242             {\cf19 else}\par
00243             \{\par
00244                 *odr &= ~pinMask;\par
00245             \}\par
00246 \par
00247             {\cf20 //}\par
00248             {\cf20 //Enable pull-up if necessary. Open drain mode must be active.}\par
00249             {\cf20 //}\par
00250             {\cf19 if} (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\par
00251             \{\par
00252                 *pud &= ~pinMask;\par
00253             \}\par
00254             {\cf19 else}\par
00255             \{\par
00256                 *pud |= pinMask;\par
00257             \}\par
00258         \}\par
00259         {\cf19 else}\par
00260         \{\par
00261             {\cf20 //}\par
00262             {\cf20 //Input, with optional pull-up, qualification, and polarity}\par
00263             {\cf20 //inversion}\par
00264             {\cf20 //}\par
00265             *dir &= ~pinMask;\par
00266 \par
00267             {\cf20 //}\par
00268             {\cf20 //Enable pull-up if necessary}\par
00269             {\cf20 //}\par
00270             {\cf19 if} (flags & GPIO_PULLUP)\par
00271             \{\par
00272                 *pud &= ~pinMask;\par
00273             \}\par
00274             {\cf19 else}\par
00275             \{\par
00276                 *pud |= pinMask;\par
00277             \}\par
00278 \par
00279             {\cf20 //}\par
00280             {\cf20 //Invert polarity if necessary}\par
00281             {\cf20 //}\par
00282             {\cf19 if} (flags & GPIO_INVERT)\par
00283             \{\par
00284                 *inv |= pinMask;\par
00285             \}\par
00286             {\cf19 else}\par
00287             \{\par
00288                 *inv &= ~pinMask;\par
00289             \}\par
00290         \}\par
00291 \par
00292         {\cf20 //}\par
00293         {\cf20 //Extract the qualification parameter and load it into the register.}\par
00294         {\cf20 //This is also needed for open drain outputs, so we might as well do it}\par
00295         {\cf20 //all the time.}\par
00296         {\cf20 //}\par
00297         qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\par
00298         *qsel &= ~(0x3L << (2 * pin16));\par
00299         {\cf19 if} (qual != 0x0)\par
00300         \{\par
00301             *qsel |= qual << (2 * pin16);\par
00302         \}\par
00303 \par
00304         EDIS;\par
00305     \}\par
00306 \par
00307     {\cf20 //}\par
00308     {\cf20 // GPIO_SetupLock - Enable or disable the GPIO register bit lock for the}\par
00309     {\cf20 //                  specified pin.}\par
00310     {\cf20 //                  The valid flags are:}\par
00311     {\cf20 //                  GPIO_UNLOCK - Unlock the pin setup register bits for}\par
00312     {\cf20 //                                the specified pin}\par
00313     {\cf20 //                  GPIO_LOCK - Lock the pin setup register bits for the}\par
00314     {\cf20 //                              specified pin}\par
00315     {\cf20 //}\par
00316     {\cf18 void} GPIO_SetupLock(Uint16 gpioNumber, Uint16 flags)\par
00317     \{\par
00318         {\cf17 volatile} Uint32 *gpioBaseAddr;\par
00319         {\cf17 volatile} Uint32 *lock;\par
00320         Uint32 pin32, pinMask;\par
00321 \par
00322         pin32 = gpioNumber % 32;\par
00323         pinMask = 1UL << pin32;\par
00324         gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\par
00325 \par
00326         {\cf20 //}\par
00327         {\cf20 //Create pointers to the appropriate registers. This is a workaround}\par
00328         {\cf20 //for the way GPIO registers are defined. The standard definition}\par
00329         {\cf20 //in the header file makes it very easy to do named accesses of one}\par
00330         {\cf20 //register or bit, but hard to do arbitrary numerical accesses. It's}\par
00331         {\cf20 //easier to have an array of GPIO modules with identical registers,}\par
00332         {\cf20 //including arrays for multi-register groups like GPyQSEL1-2. But}\par
00333         {\cf20 //the header file doesn't define anything we can turn into an array,}\par
00334         {\cf20 //so manual pointer arithmetic is used instead.}\par
00335         {\cf20 //}\par
00336         lock = gpioBaseAddr + GPYLOCK;\par
00337 \par
00338         EALLOW;\par
00339         {\cf19 if}(flags)\par
00340         \{\par
00341             {\cf20 //Lock the pin}\par
00342             *lock |= pinMask;\par
00343         \}\par
00344         {\cf19 else}\par
00345         \{\par
00346             {\cf20 //Unlock the pin}\par
00347             *lock &= ~pinMask;\par
00348         \}\par
00349         EDIS;\par
00350     \}\par
00351 \par
00352     {\cf20 //}\par
00353     {\cf20 //External interrupt setup}\par
00354     {\cf20 //}\par
00355     {\cf18 void} GPIO_SetupXINT1Gpio(Uint16 gpioNumber)\par
00356     \{\par
00357         EALLOW;\par
00358         InputXbarRegs.INPUT4SELECT = gpioNumber;      {\cf20 //Set XINT1 source to GPIO-pin}\par
00359         EDIS;\par
00360     \}\par
00361     {\cf18 void} GPIO_SetupXINT2Gpio(Uint16 gpioNumber)\par
00362     \{\par
00363         EALLOW;\par
00364         InputXbarRegs.INPUT5SELECT = gpioNumber;      {\cf20 //Set XINT2 source to GPIO-pin}\par
00365         EDIS;\par
00366     \}\par
00367     {\cf18 void} GPIO_SetupXINT3Gpio(Uint16 gpioNumber)\par
00368     \{\par
00369         EALLOW;\par
00370         InputXbarRegs.INPUT6SELECT = gpioNumber;      {\cf20 //Set XINT3 source to GPIO-pin}\par
00371         EDIS;\par
00372     \}\par
00373     {\cf18 void} GPIO_SetupXINT4Gpio(Uint16 gpioNumber)\par
00374     \{\par
00375         EALLOW;\par
00376         InputXbarRegs.INPUT13SELECT = gpioNumber;     {\cf20 //Set XINT4 source to GPIO-pin}\par
00377         EDIS;\par
00378     \}\par
00379     {\cf18 void} GPIO_SetupXINT5Gpio(Uint16 gpioNumber)\par
00380     \{\par
00381         EALLOW;\par
00382         InputXbarRegs.INPUT14SELECT = gpioNumber;     {\cf20 //Set XINT5 source to GPIO-pin}\par
00383         EDIS;\par
00384     \}\par
00385 \par
00386     {\cf20 //}\par
00387     {\cf20 //GPIO_EnableUnbondedIOPullupsFor176Pin - Enable pullups for the unbonded}\par
00388     {\cf20 //                                        GPIOs on the 176PTP package:}\par
00389     {\cf20 //                                        GPIOs     Grp Bits}\par
00390     {\cf20 //                                        95-132    C   31}\par
00391     {\cf20 //                                                  D   31:0}\par
00392     {\cf20 //                                                  E   4:0}\par
00393     {\cf20 //                                        134-168   E   31:6}\par
00394     {\cf20 //                                                  F   8:0}\par
00395     {\cf20 //}\par
00396     {\cf18 void} GPIO_EnableUnbondedIOPullupsFor176Pin()\par
00397     \{\par
00398         EALLOW;\par
00399         GpioCtrlRegs.GPCPUD.all = ~0x80000000;  {\cf20 //GPIO 95}\par
00400         GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  {\cf20 //GPIOs 96-127}\par
00401         GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDF;  {\cf20 //GPIOs 128-159 except for 133}\par
00402         GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  {\cf20 //GPIOs 160-168}\par
00403         EDIS;\par
00404     \}\par
00405 \par
00406     {\cf20 //}\par
00407     {\cf20 // GPIO_EnableUnbondedIOPullupsFor100Pin - Enable pullups for the unbonded}\par
00408     {\cf20 //                                         GPIOs on the 100PZ package:}\par
00409     {\cf20 //                                         GPIOs     Grp Bits}\par
00410     {\cf20 //                                         0-1       A   1:0}\par
00411     {\cf20 //                                         5-9       A   9:5}\par
00412     {\cf20 //                                         22-40     A   31:22}\par
00413     {\cf20 //                                                   B   8:0}\par
00414     {\cf20 //                                         44-57     B   25:12}\par
00415     {\cf20 //                                         67-68     C   4:3}\par
00416     {\cf20 //                                         74-77     C   13:10}\par
00417     {\cf20 //                                         79-83     C   19:15}\par
00418     {\cf20 //                                         93-168    C   31:29}\par
00419     {\cf20 //                                                   D   31:0}\par
00420     {\cf20 //                                                   E   31:0}\par
00421     {\cf20 //                                                   F   8:0}\par
00422     {\cf20 //}\par
00423     {\cf18 void} GPIO_EnableUnbondedIOPullupsFor100Pin()\par
00424     \{\par
00425         EALLOW;\par
00426         GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3;  {\cf20 //GPIOs 0-1, 5-9, 22-31}\par
00427         GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FF;  {\cf20 //GPIOs 32-40, 44-57}\par
00428         GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18;  {\cf20 //GPIOs 67-68, 74-77, 79-83, 93-95}\par
00429         GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  {\cf20 //GPIOs 96-127}\par
00430         GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFF;  {\cf20 //GPIOs 128-159}\par
00431         GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  {\cf20 //GPIOs 160-168}\par
00432         EDIS;\par
00433     \}\par
00434 \par
00435     {\cf20 //}\par
00436     {\cf20 // GPIO_EnableUnbondedIOPullups - InitSysCtrl would call this function}\par
00437     {\cf20 //                                this takes care of enabling IO pullups.}\par
00438     {\cf20 //}\par
00439     {\cf18 void} GPIO_EnableUnbondedIOPullups()\par
00440     \{\par
00441         {\cf20 //}\par
00442         {\cf20 //bits 8-10 have pin count}\par
00443         {\cf20 //}\par
00444         {\cf18 unsigned} {\cf18 char} pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700) >> 8) ;\par
00445 \par
00446         {\cf20 //}\par
00447         {\cf20 //5 = 100 pin}\par
00448         {\cf20 //6 = 176 pin}\par
00449         {\cf20 //7 = 337 pin}\par
00450         {\cf20 //}\par
00451         {\cf19 if}(pin_count == 5)\par
00452         \{\par
00453             GPIO_EnableUnbondedIOPullupsFor100Pin();\par
00454         \}\par
00455         {\cf19 else} {\cf19 if} (pin_count == 6)\par
00456         \{\par
00457             GPIO_EnableUnbondedIOPullupsFor176Pin();\par
00458         \}\par
00459         {\cf19 else}\par
00460         \{\par
00461             {\cf20 //do nothing - this is 337 pin package}\par
00462         \}\par
00463     \}\par
00464 \par
00465 {\cf21 #endif }{\cf20 //CPU1}\par
00466 \par
00467 {\cf20 //}\par
00468 {\cf20 // GPIO_ReadPin - Read the GPyDAT register bit for the specified pin. Note that}\par
00469 {\cf20 //                this returns the actual state of the pin, not the state of}\par
00470 {\cf20 //                the output latch.}\par
00471 {\cf20 //}\par
00472 Uint16 GPIO_ReadPin(Uint16 gpioNumber)\par
00473 \{\par
00474     {\cf17 volatile} Uint32 *gpioDataReg;\par
00475     Uint16 pinVal;\par
00476 \par
00477     gpioDataReg = ({\cf17 volatile} Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\par
00478     pinVal = (gpioDataReg[GPYDAT] >> (gpioNumber % 32)) & 0x1;\par
00479 \par
00480     {\cf19 return} pinVal;\par
00481 \}\par
00482 \par
00483 {\cf20 //}\par
00484 {\cf20 // GPIO_WritePin - Set the GPyDAT register bit for the specified pin.}\par
00485 {\cf20 //}\par
00486 {\cf18 void} GPIO_WritePin(Uint16 gpioNumber, Uint16 outVal)\par
00487 \{\par
00488     {\cf17 volatile} Uint32 *gpioDataReg;\par
00489     Uint32 pinMask;\par
00490 \par
00491     gpioDataReg = ({\cf17 volatile} Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\par
00492     pinMask = 1UL << (gpioNumber % 32);\par
00493 \par
00494     {\cf19 if} (outVal == 0)\par
00495     \{\par
00496         gpioDataReg[GPYCLEAR] = pinMask;\par
00497     \}\par
00498     {\cf19 else}\par
00499     \{\par
00500         gpioDataReg[GPYSET] = pinMask;\par
00501     \}\par
00502 \}\par
00503 \par
00504 {\cf20 //}\par
00505 {\cf20 // End of file}\par
00506 {\cf20 //}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_PieCtrl.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_PieCtrl.c}
{\xe \v F2837xD_PieCtrl.c}
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitPieCtrl} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EnableInterrupts} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EnableInterrupts\:F2837xD_PieCtrl.c}
{\xe \v F2837xD_PieCtrl.c\:EnableInterrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EnableInterrupts ()}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b F2837xD_PieCtrl.c}.}\par
}
{\xe \v InitPieCtrl\:F2837xD_PieCtrl.c}
{\xe \v F2837xD_PieCtrl.c\:InitPieCtrl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitPieCtrl (void )}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b F2837xD_PieCtrl.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_PieCtrl.c\par \pard\plain 
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:    F2837xD_PieCtrl.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:   F2837xD Device PIE Control Register Initialization Functions.}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}     {\cf20 // F2837xD Headerfile Include File}\par
00047 {\cf21 #include "F2837xD_Examples.h"}   {\cf20 // F2837xD Examples Include File}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // InitPieCtrl - This function initializes the PIE control registers to a}\par
00051 {\cf20 //               known state.}\par
00052 {\cf20 //}\par
00053 {\cf18 void} InitPieCtrl({\cf18 void})\par
00054 \{\par
00055     {\cf20 //}\par
00056     {\cf20 // Disable Interrupts at the CPU level:}\par
00057     {\cf20 //}\par
00058     DINT;\par
00059 \par
00060     {\cf20 //}\par
00061     {\cf20 // Disable the PIE}\par
00062     {\cf20 //}\par
00063     PieCtrlRegs.PIECTRL.bit.ENPIE = 0;\par
00064 \par
00065     {\cf20 //}\par
00066     {\cf20 // Clear all PIEIER registers:}\par
00067     {\cf20 //}\par
00068     PieCtrlRegs.PIEIER1.all = 0;\par
00069     PieCtrlRegs.PIEIER2.all = 0;\par
00070     PieCtrlRegs.PIEIER3.all = 0;\par
00071     PieCtrlRegs.PIEIER4.all = 0;\par
00072     PieCtrlRegs.PIEIER5.all = 0;\par
00073     PieCtrlRegs.PIEIER6.all = 0;\par
00074     PieCtrlRegs.PIEIER7.all = 0;\par
00075     PieCtrlRegs.PIEIER8.all = 0;\par
00076     PieCtrlRegs.PIEIER9.all = 0;\par
00077     PieCtrlRegs.PIEIER10.all = 0;\par
00078     PieCtrlRegs.PIEIER11.all = 0;\par
00079     PieCtrlRegs.PIEIER12.all = 0;\par
00080 \par
00081     {\cf20 //}\par
00082     {\cf20 // Clear all PIEIFR registers:}\par
00083     {\cf20 //}\par
00084     PieCtrlRegs.PIEIFR1.all = 0;\par
00085     PieCtrlRegs.PIEIFR2.all = 0;\par
00086     PieCtrlRegs.PIEIFR3.all = 0;\par
00087     PieCtrlRegs.PIEIFR4.all = 0;\par
00088     PieCtrlRegs.PIEIFR5.all = 0;\par
00089     PieCtrlRegs.PIEIFR6.all = 0;\par
00090     PieCtrlRegs.PIEIFR7.all = 0;\par
00091     PieCtrlRegs.PIEIFR8.all = 0;\par
00092     PieCtrlRegs.PIEIFR9.all = 0;\par
00093     PieCtrlRegs.PIEIFR10.all = 0;\par
00094     PieCtrlRegs.PIEIFR11.all = 0;\par
00095     PieCtrlRegs.PIEIFR12.all = 0;\par
00096 \}\par
00097 \par
00098 {\cf20 //}\par
00099 {\cf20 // EnableInterrupts - This function enables the PIE module and CPU __interrupts}\par
00100 {\cf20 //}\par
00101 {\cf18 void} EnableInterrupts()\par
00102 \{\par
00103     {\cf20 //}\par
00104     {\cf20 // Enable the PIE}\par
00105     {\cf20 //}\par
00106     PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\par
00107 \par
00108     {\cf20 //}\par
00109     {\cf20 // Enables PIE to drive a pulse into the CPU}\par
00110     {\cf20 //}\par
00111     PieCtrlRegs.PIEACK.all = 0xFFFF;\par
00112 \par
00113     {\cf20 //}\par
00114     {\cf20 // Enable Interrupts at the CPU level}\par
00115     {\cf20 //}\par
00116     EINT;\par
00117 \}\par
00118 \par
00119 {\cf20 //}\par
00120 {\cf20 // End of file}\par
00121 {\cf20 //}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_PieVect.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_PieVect.c}
{\xe \v F2837xD_PieVect.c}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitPieVectTable} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct PIE_VECT_TABLE {\b PieVectTableInit}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitPieVectTable\:F2837xD_PieVect.c}
{\xe \v F2837xD_PieVect.c\:InitPieVectTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitPieVectTable (void )}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 292} of file {\b F2837xD_PieVect.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PieVectTableInit\:F2837xD_PieVect.c}
{\xe \v F2837xD_PieVect.c\:PieVectTableInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct PIE_VECT_TABLE PieVectTableInit}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b F2837xD_PieVect.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_PieVect.c\par \pard\plain 
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:   F2837xD_PieVect.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:  F2837xD Device PIE Vector Initialization Functions}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}\par
00047 {\cf21 #include "F2837xD_Examples.h"}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // Globals}\par
00051 {\cf20 //}\par
00052 {\cf17 const} {\cf17 struct }PIE_VECT_TABLE PieVectTableInit = \{\par
00053     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00054     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00055     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00056     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00057     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00058     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00059     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00060     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00061     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00062     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00063     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00064     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00065     PIE_RESERVED_ISR,             {\cf20 // Reserved}\par
00066     TIMER1_ISR,                   {\cf20 // CPU Timer 1 Interrupt}\par
00067     TIMER2_ISR,                   {\cf20 // CPU Timer 2 Interrupt}\par
00068     DATALOG_ISR,                  {\cf20 // Datalogging Interrupt}\par
00069     RTOS_ISR,                     {\cf20 // RTOS Interrupt}\par
00070     EMU_ISR,                      {\cf20 // Emulation Interrupt}\par
00071     NMI_ISR,                      {\cf20 // Non-Maskable Interrupt}\par
00072     ILLEGAL_ISR,                  {\cf20 // Illegal Operation Trap}\par
00073     USER1_ISR,                    {\cf20 // User Defined Trap 1}\par
00074     USER2_ISR,                    {\cf20 // User Defined Trap 2}\par
00075     USER3_ISR,                    {\cf20 // User Defined Trap 3}\par
00076     USER4_ISR,                    {\cf20 // User Defined Trap 4}\par
00077     USER5_ISR,                    {\cf20 // User Defined Trap 5}\par
00078     USER6_ISR,                    {\cf20 // User Defined Trap 6}\par
00079     USER7_ISR,                    {\cf20 // User Defined Trap 7}\par
00080     USER8_ISR,                    {\cf20 // User Defined Trap 8}\par
00081     USER9_ISR,                    {\cf20 // User Defined Trap 9}\par
00082     USER10_ISR,                   {\cf20 // User Defined Trap 10}\par
00083     USER11_ISR,                   {\cf20 // User Defined Trap 11}\par
00084     USER12_ISR,                   {\cf20 // User Defined Trap 12}\par
00085     ADCA1_ISR,                    {\cf20 // 1.1 - ADCA Interrupt 1}\par
00086     ADCB1_ISR,                    {\cf20 // 1.2 - ADCB Interrupt 1}\par
00087     ADCC1_ISR,                    {\cf20 // 1.3 - ADCC Interrupt 1}\par
00088     XINT1_ISR,                    {\cf20 // 1.4 - XINT1 Interrupt}\par
00089     XINT2_ISR,                    {\cf20 // 1.5 - XINT2 Interrupt}\par
00090     ADCD1_ISR,                    {\cf20 // 1.6 - ADCD Interrupt 1}\par
00091     TIMER0_ISR,                   {\cf20 // 1.7 - Timer 0 Interrupt}\par
00092     WAKE_ISR,                     {\cf20 // 1.8 - Standby and Halt Wakeup Interrupt}\par
00093     EPWM1_TZ_ISR,                 {\cf20 // 2.1 - ePWM1 Trip Zone Interrupt}\par
00094     EPWM2_TZ_ISR,                 {\cf20 // 2.2 - ePWM2 Trip Zone Interrupt}\par
00095     EPWM3_TZ_ISR,                 {\cf20 // 2.3 - ePWM3 Trip Zone Interrupt}\par
00096     EPWM4_TZ_ISR,                 {\cf20 // 2.4 - ePWM4 Trip Zone Interrupt}\par
00097     EPWM5_TZ_ISR,                 {\cf20 // 2.5 - ePWM5 Trip Zone Interrupt}\par
00098     EPWM6_TZ_ISR,                 {\cf20 // 2.6 - ePWM6 Trip Zone Interrupt}\par
00099     EPWM7_TZ_ISR,                 {\cf20 // 2.7 - ePWM7 Trip Zone Interrupt}\par
00100     EPWM8_TZ_ISR,                 {\cf20 // 2.8 - ePWM8 Trip Zone Interrupt}\par
00101     EPWM1_ISR,                    {\cf20 // 3.1 - ePWM1 Interrupt}\par
00102     EPWM2_ISR,                    {\cf20 // 3.2 - ePWM2 Interrupt}\par
00103     EPWM3_ISR,                    {\cf20 // 3.3 - ePWM3 Interrupt}\par
00104     EPWM4_ISR,                    {\cf20 // 3.4 - ePWM4 Interrupt}\par
00105     EPWM5_ISR,                    {\cf20 // 3.5 - ePWM5 Interrupt}\par
00106     EPWM6_ISR,                    {\cf20 // 3.6 - ePWM6 Interrupt}\par
00107     EPWM7_ISR,                    {\cf20 // 3.7 - ePWM7 Interrupt}\par
00108     EPWM8_ISR,                    {\cf20 // 3.8 - ePWM8 Interrupt}\par
00109     ECAP1_ISR,                    {\cf20 // 4.1 - eCAP1 Interrupt}\par
00110     ECAP2_ISR,                    {\cf20 // 4.2 - eCAP2 Interrupt}\par
00111     ECAP3_ISR,                    {\cf20 // 4.3 - eCAP3 Interrupt}\par
00112     ECAP4_ISR,                    {\cf20 // 4.4 - eCAP4 Interrupt}\par
00113     ECAP5_ISR,                    {\cf20 // 4.5 - eCAP5 Interrupt}\par
00114     ECAP6_ISR,                    {\cf20 // 4.6 - eCAP6 Interrupt}\par
00115     PIE_RESERVED_ISR,             {\cf20 // 4.7 - Reserved}\par
00116     PIE_RESERVED_ISR,             {\cf20 // 4.8 - Reserved}\par
00117     EQEP1_ISR,                    {\cf20 // 5.1 - eQEP1 Interrupt}\par
00118     EQEP2_ISR,                    {\cf20 // 5.2 - eQEP2 Interrupt}\par
00119     EQEP3_ISR,                    {\cf20 // 5.3 - eQEP3 Interrupt}\par
00120     PIE_RESERVED_ISR,             {\cf20 // 5.4 - Reserved}\par
00121     PIE_RESERVED_ISR,             {\cf20 // 5.5 - Reserved}\par
00122     PIE_RESERVED_ISR,             {\cf20 // 5.6 - Reserved}\par
00123     PIE_RESERVED_ISR,             {\cf20 // 5.7 - Reserved}\par
00124     PIE_RESERVED_ISR,             {\cf20 // 5.8 - Reserved}\par
00125     SPIA_RX_ISR,                  {\cf20 // 6.1 - SPIA Receive Interrupt}\par
00126     SPIA_TX_ISR,                  {\cf20 // 6.2 - SPIA Transmit Interrupt}\par
00127     SPIB_RX_ISR,                  {\cf20 // 6.3 - SPIB Receive Interrupt}\par
00128     SPIB_TX_ISR,                  {\cf20 // 6.4 - SPIB Transmit Interrupt}\par
00129     MCBSPA_RX_ISR,                {\cf20 // 6.5 - McBSPA Receive Interrupt}\par
00130     MCBSPA_TX_ISR,                {\cf20 // 6.6 - McBSPA Transmit Interrupt}\par
00131     MCBSPB_RX_ISR,                {\cf20 // 6.7 - McBSPB Receive Interrupt}\par
00132     MCBSPB_TX_ISR,                {\cf20 // 6.8 - McBSPB Transmit Interrupt}\par
00133     DMA_CH1_ISR,                  {\cf20 // 7.1 - DMA Channel 1 Interrupt}\par
00134     DMA_CH2_ISR,                  {\cf20 // 7.2 - DMA Channel 2 Interrupt}\par
00135     DMA_CH3_ISR,                  {\cf20 // 7.3 - DMA Channel 3 Interrupt}\par
00136     DMA_CH4_ISR,                  {\cf20 // 7.4 - DMA Channel 4 Interrupt}\par
00137     DMA_CH5_ISR,                  {\cf20 // 7.5 - DMA Channel 5 Interrupt}\par
00138     DMA_CH6_ISR,                  {\cf20 // 7.6 - DMA Channel 6 Interrupt}\par
00139     PIE_RESERVED_ISR,             {\cf20 // 7.7 - Reserved}\par
00140     PIE_RESERVED_ISR,             {\cf20 // 7.8 - Reserved}\par
00141     I2CA_ISR,                     {\cf20 // 8.1 - I2CA Interrupt 1}\par
00142     I2CA_FIFO_ISR,                {\cf20 // 8.2 - I2CA Interrupt 2}\par
00143     I2CB_ISR,                     {\cf20 // 8.3 - I2CB Interrupt 1}\par
00144     I2CB_FIFO_ISR,                {\cf20 // 8.4 - I2CB Interrupt 2}\par
00145     SCIC_RX_ISR,                  {\cf20 // 8.5 - SCIC Receive Interrupt}\par
00146     SCIC_TX_ISR,                  {\cf20 // 8.6 - SCIC Transmit Interrupt}\par
00147     SCID_RX_ISR,                  {\cf20 // 8.7 - SCID Receive Interrupt}\par
00148     SCID_TX_ISR,                  {\cf20 // 8.8 - SCID Transmit Interrupt}\par
00149     SCIA_RX_ISR,                  {\cf20 // 9.1 - SCIA Receive Interrupt}\par
00150     SCIA_TX_ISR,                  {\cf20 // 9.2 - SCIA Transmit Interrupt}\par
00151     SCIB_RX_ISR,                  {\cf20 // 9.3 - SCIB Receive Interrupt}\par
00152     SCIB_TX_ISR,                  {\cf20 // 9.4 - SCIB Transmit Interrupt}\par
00153     CANA0_ISR,                    {\cf20 // 9.5 - CANA Interrupt 0}\par
00154     CANA1_ISR,                    {\cf20 // 9.6 - CANA Interrupt 1}\par
00155     CANB0_ISR,                    {\cf20 // 9.7 - CANB Interrupt 0}\par
00156     CANB1_ISR,                    {\cf20 // 9.8 - CANB Interrupt 1}\par
00157     ADCA_EVT_ISR,                 {\cf20 // 10.1 - ADCA Event Interrupt}\par
00158     ADCA2_ISR,                    {\cf20 // 10.2 - ADCA Interrupt 2}\par
00159     ADCA3_ISR,                    {\cf20 // 10.3 - ADCA Interrupt 3}\par
00160     ADCA4_ISR,                    {\cf20 // 10.4 - ADCA Interrupt 4}\par
00161     ADCB_EVT_ISR,                 {\cf20 // 10.5 - ADCB Event Interrupt}\par
00162     ADCB2_ISR,                    {\cf20 // 10.6 - ADCB Interrupt 2}\par
00163     ADCB3_ISR,                    {\cf20 // 10.7 - ADCB Interrupt 3}\par
00164     ADCB4_ISR,                    {\cf20 // 10.8 - ADCB Interrupt 4}\par
00165     CLA1_1_ISR,                   {\cf20 // 11.1 - CLA1 Interrupt 1}\par
00166     CLA1_2_ISR,                   {\cf20 // 11.2 - CLA1 Interrupt 2}\par
00167     CLA1_3_ISR,                   {\cf20 // 11.3 - CLA1 Interrupt 3}\par
00168     CLA1_4_ISR,                   {\cf20 // 11.4 - CLA1 Interrupt 4}\par
00169     CLA1_5_ISR,                   {\cf20 // 11.5 - CLA1 Interrupt 5}\par
00170     CLA1_6_ISR,                   {\cf20 // 11.6 - CLA1 Interrupt 6}\par
00171     CLA1_7_ISR,                   {\cf20 // 11.7 - CLA1 Interrupt 7}\par
00172     CLA1_8_ISR,                   {\cf20 // 11.8 - CLA1 Interrupt 8}\par
00173     XINT3_ISR,                    {\cf20 // 12.1 - XINT3 Interrupt}\par
00174     XINT4_ISR,                    {\cf20 // 12.2 - XINT4 Interrupt}\par
00175     XINT5_ISR,                    {\cf20 // 12.3 - XINT5 Interrupt}\par
00176     PIE_RESERVED_ISR,             {\cf20 // 12.4 - Reserved}\par
00177     PIE_RESERVED_ISR,             {\cf20 // 12.5 - Reserved}\par
00178     VCU_ISR,                      {\cf20 // 12.6 - VCU Interrupt}\par
00179     FPU_OVERFLOW_ISR,             {\cf20 // 12.7 - FPU Overflow Interrupt}\par
00180     FPU_UNDERFLOW_ISR,            {\cf20 // 12.8 - FPU Underflow Interrupt}\par
00181     PIE_RESERVED_ISR,             {\cf20 // 1.9 - Reserved}\par
00182     PIE_RESERVED_ISR,             {\cf20 // 1.10 - Reserved}\par
00183     PIE_RESERVED_ISR,             {\cf20 // 1.11 - Reserved}\par
00184     PIE_RESERVED_ISR,             {\cf20 // 1.12 - Reserved}\par
00185     IPC0_ISR,                     {\cf20 // 1.13 - IPC Interrupt 0}\par
00186     IPC1_ISR,                     {\cf20 // 1.14 - IPC Interrupt 1}\par
00187     IPC2_ISR,                     {\cf20 // 1.15 - IPC Interrupt 2}\par
00188     IPC3_ISR,                     {\cf20 // 1.16 - IPC Interrupt 3}\par
00189     EPWM9_TZ_ISR,                 {\cf20 // 2.9 - ePWM9 Trip Zone Interrupt}\par
00190     EPWM10_TZ_ISR,                {\cf20 // 2.10 - ePWM10 Trip Zone Interrupt}\par
00191     EPWM11_TZ_ISR,                {\cf20 // 2.11 - ePWM11 Trip Zone Interrupt}\par
00192     EPWM12_TZ_ISR,                {\cf20 // 2.12 - ePWM12 Trip Zone Interrupt}\par
00193     PIE_RESERVED_ISR,             {\cf20 // 2.13 - Reserved}\par
00194     PIE_RESERVED_ISR,             {\cf20 // 2.14 - Reserved}\par
00195     PIE_RESERVED_ISR,             {\cf20 // 2.15 - Reserved}\par
00196     PIE_RESERVED_ISR,             {\cf20 // 2.16 - Reserved}\par
00197     EPWM9_ISR,                    {\cf20 // 3.9 - ePWM9 Interrupt}\par
00198     EPWM10_ISR,                   {\cf20 // 3.10 - ePWM10 Interrupt}\par
00199     EPWM11_ISR,                   {\cf20 // 3.11 - ePWM11 Interrupt}\par
00200     EPWM12_ISR,                   {\cf20 // 3.12 - ePWM12 Interrupt}\par
00201     PIE_RESERVED_ISR,             {\cf20 // 3.13 - Reserved}\par
00202     PIE_RESERVED_ISR,             {\cf20 // 3.14 - Reserved}\par
00203     PIE_RESERVED_ISR,             {\cf20 // 3.15 - Reserved}\par
00204     PIE_RESERVED_ISR,             {\cf20 // 3.16 - Reserved}\par
00205     PIE_RESERVED_ISR,             {\cf20 // 4.9 - Reserved}\par
00206     PIE_RESERVED_ISR,             {\cf20 // 4.10 - Reserved}\par
00207     PIE_RESERVED_ISR,             {\cf20 // 4.11 - Reserved}\par
00208     PIE_RESERVED_ISR,             {\cf20 // 4.12 - Reserved}\par
00209     PIE_RESERVED_ISR,             {\cf20 // 4.13 - Reserved}\par
00210     PIE_RESERVED_ISR,             {\cf20 // 4.14 - Reserved}\par
00211     PIE_RESERVED_ISR,             {\cf20 // 4.15 - Reserved}\par
00212     PIE_RESERVED_ISR,             {\cf20 // 4.16 - Reserved}\par
00213     SD1_ISR,                      {\cf20 // 5.9 - SD1 Interrupt}\par
00214     SD2_ISR,                      {\cf20 // 5.10 - SD2 Interrupt}\par
00215     PIE_RESERVED_ISR,             {\cf20 // 5.11 - Reserved}\par
00216     PIE_RESERVED_ISR,             {\cf20 // 5.12 - Reserved}\par
00217     PIE_RESERVED_ISR,             {\cf20 // 5.13 - Reserved}\par
00218     PIE_RESERVED_ISR,             {\cf20 // 5.14 - Reserved}\par
00219     PIE_RESERVED_ISR,             {\cf20 // 5.15 - Reserved}\par
00220     PIE_RESERVED_ISR,             {\cf20 // 5.16 - Reserved}\par
00221     SPIC_RX_ISR,                  {\cf20 // 6.9 - SPIC Receive Interrupt}\par
00222     SPIC_TX_ISR,                  {\cf20 // 6.10 - SPIC Transmit Interrupt}\par
00223     PIE_RESERVED_ISR,             {\cf20 // 6.11 - Reserved}\par
00224     PIE_RESERVED_ISR,             {\cf20 // 6.12 - Reserved}\par
00225     PIE_RESERVED_ISR,             {\cf20 // 6.13 - Reserved}\par
00226     PIE_RESERVED_ISR,             {\cf20 // 6.14 - Reserved}\par
00227     PIE_RESERVED_ISR,             {\cf20 // 6.15 - Reserved}\par
00228     PIE_RESERVED_ISR,             {\cf20 // 6.16 - Reserved}\par
00229     PIE_RESERVED_ISR,             {\cf20 // 7.9 - Reserved}\par
00230     PIE_RESERVED_ISR,             {\cf20 // 7.10 - Reserved}\par
00231     PIE_RESERVED_ISR,             {\cf20 // 7.11 - Reserved}\par
00232     PIE_RESERVED_ISR,             {\cf20 // 7.12 - Reserved}\par
00233     PIE_RESERVED_ISR,             {\cf20 // 7.13 - Reserved}\par
00234     PIE_RESERVED_ISR,             {\cf20 // 7.14 - Reserved}\par
00235     PIE_RESERVED_ISR,             {\cf20 // 7.15 - Reserved}\par
00236     PIE_RESERVED_ISR,             {\cf20 // 7.16 - Reserved}\par
00237     PIE_RESERVED_ISR,             {\cf20 // 8.9 - Reserved}\par
00238     PIE_RESERVED_ISR,             {\cf20 // 8.10 - Reserved}\par
00239     PIE_RESERVED_ISR,             {\cf20 // 8.11 - Reserved}\par
00240     PIE_RESERVED_ISR,             {\cf20 // 8.12 - Reserved}\par
00241     PIE_RESERVED_ISR,             {\cf20 // 8.13 - Reserved}\par
00242     PIE_RESERVED_ISR,             {\cf20 // 8.14 - Reserved}\par
00243 {\cf21 #ifdef CPU1    }\par
00244     UPPA_ISR,                     {\cf20 // 8.15 - uPPA Interrupt}\par
00245     PIE_RESERVED_ISR,             {\cf20 // 8.16 - Reserved}\par
00246 {\cf21 #elif defined(CPU2)}\par
00247     PIE_RESERVED_ISR,             {\cf20 // 8.15 - Reserved}\par
00248     PIE_RESERVED_ISR,             {\cf20 // 8.16 - Reserved}\par
00249 {\cf21 #endif    }\par
00250     PIE_RESERVED_ISR,             {\cf20 // 9.9 - Reserved}\par
00251     PIE_RESERVED_ISR,             {\cf20 // 9.10 - Reserved}\par
00252     PIE_RESERVED_ISR,             {\cf20 // 9.11 - Reserved}\par
00253     PIE_RESERVED_ISR,             {\cf20 // 9.12 - Reserved}\par
00254     PIE_RESERVED_ISR,             {\cf20 // 9.13 - Reserved}\par
00255     PIE_RESERVED_ISR,             {\cf20 // 9.14 - Reserved}\par
00256 {\cf21 #ifdef CPU1    }\par
00257     USBA_ISR,                     {\cf20 // 9.15 - USBA Interrupt}\par
00258 {\cf21 #elif defined(CPU2)}\par
00259     PIE_RESERVED_ISR,             {\cf20 // 9.15 - Reserved}\par
00260 {\cf21 #endif    }\par
00261     PIE_RESERVED_ISR,             {\cf20 // 9.16 - Reserved}\par
00262     ADCC_EVT_ISR,                 {\cf20 // 10.9 - ADCC Event Interrupt}\par
00263     ADCC2_ISR,                    {\cf20 // 10.10 - ADCC Interrupt 2}\par
00264     ADCC3_ISR,                    {\cf20 // 10.11 - ADCC Interrupt 3}\par
00265     ADCC4_ISR,                    {\cf20 // 10.12 - ADCC Interrupt 4}\par
00266     ADCD_EVT_ISR,                 {\cf20 // 10.13 - ADCD Event Interrupt}\par
00267     ADCD2_ISR,                    {\cf20 // 10.14 - ADCD Interrupt 2}\par
00268     ADCD3_ISR,                    {\cf20 // 10.15 - ADCD Interrupt 3}\par
00269     ADCD4_ISR,                    {\cf20 // 10.16 - ADCD Interrupt 4}\par
00270     PIE_RESERVED_ISR,             {\cf20 // 11.9 - Reserved}\par
00271     PIE_RESERVED_ISR,             {\cf20 // 11.10 - Reserved}\par
00272     PIE_RESERVED_ISR,             {\cf20 // 11.11 - Reserved}\par
00273     PIE_RESERVED_ISR,             {\cf20 // 11.12 - Reserved}\par
00274     PIE_RESERVED_ISR,             {\cf20 // 11.13 - Reserved}\par
00275     PIE_RESERVED_ISR,             {\cf20 // 11.14 - Reserved}\par
00276     PIE_RESERVED_ISR,             {\cf20 // 11.15 - Reserved}\par
00277     PIE_RESERVED_ISR,             {\cf20 // 11.16 - Reserved}\par
00278     EMIF_ERROR_ISR,               {\cf20 // 12.9 - EMIF Error Interrupt}\par
00279     RAM_CORRECTABLE_ERROR_ISR,    {\cf20 // 12.10 - RAM Correctable Error Interrupt}\par
00280     FLASH_CORRECTABLE_ERROR_ISR,  {\cf20 // 12.11 - Flash Correctable Error Interrupt}\par
00281     RAM_ACCESS_VIOLATION_ISR,     {\cf20 // 12.12 - RAM Access Violation Interrupt}\par
00282     SYS_PLL_SLIP_ISR,             {\cf20 // 12.13 - System PLL Slip Interrupt}\par
00283     AUX_PLL_SLIP_ISR,             {\cf20 // 12.14 - Auxiliary PLL Slip Interrupt}\par
00284     CLA_OVERFLOW_ISR,             {\cf20 // 12.15 - CLA Overflow Interrupt}\par
00285     CLA_UNDERFLOW_ISR             {\cf20 // 12.16 - CLA Underflow Interrupt}\par
00286 \};\par
00287 \par
00288 {\cf20 //}\par
00289 {\cf20 // InitPieVectTable - This function initializes the PIE vector table to a}\par
00290 {\cf20 //                    known state and must be executed after boot time.}\par
00291 {\cf20 //}\par
00292 {\cf18 void} InitPieVectTable({\cf18 void})\par
00293 \{\par
00294     Uint16 i;\par
00295     Uint32 *Source = ({\cf18 void} *) &PieVectTableInit;\par
00296     Uint32 *Dest = ({\cf18 void} *) &PieVectTable;\par
00297 \par
00298     {\cf20 //}\par
00299     {\cf20 // Do not write over first 3 32-bit locations (these locations are}\par
00300     {\cf20 // initialized by Boot ROM with boot variables)}\par
00301     {\cf20 //}\par
00302     Source = Source + 3;\par
00303     Dest = Dest + 3;\par
00304 \par
00305     EALLOW;\par
00306     {\cf19 for}(i = 0; i < 221; i++)\par
00307     \{\par
00308         *Dest++ = *Source++;\par
00309     \}\par
00310     EDIS;\par
00311 \par
00312     {\cf20 //}\par
00313     {\cf20 // Enable the PIE Vector Table}\par
00314     {\cf20 //}\par
00315     PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\par
00316 \}\par
00317 \par
00318 {\cf20 //}\par
00319 {\cf20 // End of file}\par
00320 {\cf20 //}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_Spi.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_Spi.c}
{\xe \v F2837xD_Spi.c}
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitSpi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitSpiGpio} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitSpiaGpio} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitSpi\:F2837xD_Spi.c}
{\xe \v F2837xD_Spi.c\:InitSpi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitSpi (void )}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b F2837xD_Spi.c}.}\par
}
{\xe \v InitSpiaGpio\:F2837xD_Spi.c}
{\xe \v F2837xD_Spi.c\:InitSpiaGpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitSpiaGpio ()}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b F2837xD_Spi.c}.}\par
}
{\xe \v InitSpiGpio\:F2837xD_Spi.c}
{\xe \v F2837xD_Spi.c\:InitSpiGpio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitSpiGpio ()}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b F2837xD_Spi.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_Spi.c\par \pard\plain 
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:   F2837xD_Spi.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:  F2837xD SPI Initialization & Support Functions.}\par
00006 {\cf20 //}\par
00007 {\cf20 //###########################################################################}\par
00008 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00009 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00010 {\cf20 // $Copyright:}\par
00011 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00012 {\cf20 //}\par
00013 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00014 {\cf20 // modification, are permitted provided that the following conditions }\par
00015 {\cf20 // are met:}\par
00016 {\cf20 // }\par
00017 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00018 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00019 {\cf20 // }\par
00020 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00021 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00022 {\cf20 //   documentation and/or other materials provided with the   }\par
00023 {\cf20 //   distribution.}\par
00024 {\cf20 // }\par
00025 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00026 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00027 {\cf20 //   from this software without specific prior written permission.}\par
00028 {\cf20 // }\par
00029 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00030 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00031 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00032 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00033 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00034 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00036 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00037 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00038 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00039 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00040 {\cf20 // $}\par
00041 {\cf20 //###########################################################################}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // Included Files}\par
00045 {\cf20 //}\par
00046 {\cf21 #include "F2837xD_device.h"}\par
00047 {\cf21 #include "F2837xD_Examples.h"}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // Calculate BRR: 7-bit baud rate register value}\par
00051 {\cf20 // SPI CLK freq = 500 kHz}\par
00052 {\cf20 // LSPCLK freq  = CPU freq / 4  (by default)}\par
00053 {\cf20 // BRR          = (LSPCLK freq / SPI CLK freq) - 1}\par
00054 {\cf20 //}\par
00055 {\cf21 #if CPU_FRQ_200MHZ}\par
00056 {\cf21 #define SPI_BRR        ((200E6 / 4) / 500E3) - 1}\par
00057 {\cf21 #endif}\par
00058 \par
00059 {\cf21 #if CPU_FRQ_150MHZ}\par
00060 {\cf21 #define SPI_BRR        ((150E6 / 4) / 500E3) - 1}\par
00061 {\cf21 #endif}\par
00062 \par
00063 {\cf21 #if CPU_FRQ_120MHZ}\par
00064 {\cf21 #define SPI_BRR        ((120E6 / 4) / 500E3) - 1}\par
00065 {\cf21 #endif}\par
00066 \par
00067 {\cf20 //}\par
00068 {\cf20 // InitSPI - This function initializes the SPI to a known state}\par
00069 {\cf20 //}\par
00070 {\cf18 void} InitSpi({\cf18 void})\par
00071 \{\par
00072     {\cf20 // Initialize SPI-A}\par
00073 \par
00074     {\cf20 // Set reset low before configuration changes}\par
00075     {\cf20 // Clock polarity (0 == rising, 1 == falling)}\par
00076     {\cf20 // 16-bit character}\par
00077     {\cf20 // Enable loop-back}\par
00078     SpiaRegs.SPICCR.bit.SPISWRESET = 0;\par
00079     SpiaRegs.SPICCR.bit.CLKPOLARITY = 0;\par
00080     SpiaRegs.SPICCR.bit.SPICHAR = (16-1);\par
00081     SpiaRegs.SPICCR.bit.SPILBK = 1;\par
00082 \par
00083     {\cf20 // Enable master (0 == slave, 1 == master)}\par
00084     {\cf20 // Enable transmission (Talk)}\par
00085     {\cf20 // Clock phase (0 == normal, 1 == delayed)}\par
00086     {\cf20 // SPI interrupts are disabled}\par
00087     SpiaRegs.SPICTL.bit.MASTER_SLAVE = 1;\par
00088     SpiaRegs.SPICTL.bit.TALK = 1;\par
00089     SpiaRegs.SPICTL.bit.CLK_PHASE = 0;\par
00090     SpiaRegs.SPICTL.bit.SPIINTENA = 0;\par
00091 \par
00092     {\cf20 // Set the baud rate}\par
00093     SpiaRegs.SPIBRR.bit.SPI_BIT_RATE = SPI_BRR;\par
00094 \par
00095     {\cf20 // Set FREE bit}\par
00096     {\cf20 // Halting on a breakpoint will not halt the SPI}\par
00097     SpiaRegs.SPIPRI.bit.FREE = 1;\par
00098 \par
00099     {\cf20 // Release the SPI from reset}\par
00100     SpiaRegs.SPICCR.bit.SPISWRESET = 1;\par
00101 \}\par
00102 \par
00103 {\cf20 //}\par
00104 {\cf20 // InitSpiGpio - This function initializes GPIO pins to function as SPI pins.}\par
00105 {\cf20 //               Each GPIO pin can be configured as a GPIO pin or up to 3}\par
00106 {\cf20 //               different peripheral functional pins. By default all pins come}\par
00107 {\cf20 //               up as GPIO inputs after reset.}\par
00108 {\cf20 //}\par
00109 {\cf20 //               Caution:}\par
00110 {\cf20 //               For each SPI peripheral}\par
00111 {\cf20 //               Only one GPIO pin should be enabled for SPISOMO operation.}\par
00112 {\cf20 //               Only one GPIO pin should be enabled for SPISOMI operation.}\par
00113 {\cf20 //               Only one GPIO pin should be enabled for SPICLK  operation.}\par
00114 {\cf20 //               Only one GPIO pin should be enabled for SPISTE  operation.}\par
00115 {\cf20 //               Comment out other unwanted lines.}\par
00116 {\cf20 //}\par
00117 {\cf18 void} InitSpiGpio()\par
00118 \{\par
00119    InitSpiaGpio();\par
00120 \}\par
00121 \par
00122 {\cf20 //}\par
00123 {\cf20 // InitSpiaGpio - Initialize SPIA GPIOs}\par
00124 {\cf20 //}\par
00125 {\cf18 void} InitSpiaGpio()\par
00126 \{\par
00127    EALLOW;\par
00128 \par
00129     {\cf20 //}\par
00130     {\cf20 // Enable internal pull-up for the selected pins}\par
00131     {\cf20 //}\par
00132     {\cf20 // Pull-ups can be enabled or disabled by the user.}\par
00133     {\cf20 // This will enable the pullups for the specified pins.}\par
00134     {\cf20 // Comment out other unwanted lines.}\par
00135     {\cf20 //}\par
00136     GpioCtrlRegs.GPAPUD.bit.GPIO16 = 0;  {\cf20 // Enable pull-up on GPIO16 (SPISIMOA)}\par
00137 {\cf20 //  GpioCtrlRegs.GPAPUD.bit.GPIO5 = 0;   // Enable pull-up on GPIO5 (SPISIMOA)}\par
00138     GpioCtrlRegs.GPAPUD.bit.GPIO17 = 0;  {\cf20 // Enable pull-up on GPIO17 (SPISOMIA)}\par
00139 {\cf20 //  GpioCtrlRegs.GPAPUD.bit.GPIO3 = 0;   // Enable pull-up on GPIO3 (SPISOMIA)}\par
00140     GpioCtrlRegs.GPAPUD.bit.GPIO18 = 0;  {\cf20 // Enable pull-up on GPIO18 (SPICLKA)}\par
00141     GpioCtrlRegs.GPAPUD.bit.GPIO19 = 0;  {\cf20 // Enable pull-up on GPIO19 (SPISTEA)}\par
00142 \par
00143     {\cf20 //}\par
00144     {\cf20 // Set qualification for selected pins to asynch only}\par
00145     {\cf20 //}\par
00146     {\cf20 // This will select asynch (no qualification) for the selected pins.}\par
00147     {\cf20 // Comment out other unwanted lines.}\par
00148     {\cf20 //}\par
00149     GpioCtrlRegs.GPAQSEL2.bit.GPIO16 = 3; {\cf20 // Asynch input GPIO16 (SPISIMOA)}\par
00150 {\cf20 //  GpioCtrlRegs.GPAQSEL1.bit.GPIO5 = 3;  // Asynch input GPIO5 (SPISIMOA)}\par
00151     GpioCtrlRegs.GPAQSEL2.bit.GPIO17 = 3; {\cf20 // Asynch input GPIO17 (SPISOMIA)}\par
00152 {\cf20 //  GpioCtrlRegs.GPAQSEL1.bit.GPIO3 = 3;  // Asynch input GPIO3 (SPISOMIA)}\par
00153     GpioCtrlRegs.GPAQSEL2.bit.GPIO18 = 3; {\cf20 // Asynch input GPIO18 (SPICLKA)}\par
00154     GpioCtrlRegs.GPAQSEL2.bit.GPIO19 = 3; {\cf20 // Asynch input GPIO19 (SPISTEA)}\par
00155 \par
00156     {\cf20 //}\par
00157     {\cf20 //Configure SPI-A pins using GPIO regs}\par
00158     {\cf20 //}\par
00159     {\cf20 // This specifies which of the possible GPIO pins will be SPI functional}\par
00160     {\cf20 // pins.}\par
00161     {\cf20 // Comment out other unwanted lines.}\par
00162     {\cf20 //}\par
00163     GpioCtrlRegs.GPAMUX2.bit.GPIO16 = 1; {\cf20 // Configure GPIO16 as SPISIMOA}\par
00164 {\cf20 //  GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 2;  // Configure GPIO5 as SPISIMOA}\par
00165     GpioCtrlRegs.GPAMUX2.bit.GPIO17 = 1; {\cf20 // Configure GPIO17 as SPISOMIA}\par
00166 {\cf20 //  GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 2;  // Configure GPIO3 as SPISOMIA}\par
00167     GpioCtrlRegs.GPAMUX2.bit.GPIO18 = 1; {\cf20 // Configure GPIO18 as SPICLKA}\par
00168     GpioCtrlRegs.GPAMUX2.bit.GPIO19 = 1; {\cf20 // Configure GPIO19 as SPISTEA}\par
00169 \par
00170     EDIS;\par
00171 \}\par
00172 \par
00173 {\cf20 //}\par
00174 {\cf20 // End of file}\par
00175 {\cf20 //}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_SysCtrl.c File Reference\par \pard\plain 
{\tc\tcl2 \v F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "F2837xD_device.h"}\par
{\f2 #include "F2837xD_Examples.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STATUS_FAIL}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STATUS_SUCCESS}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TMR1SYSCLKCTR}\~ 0xF0000000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TMR2INPCLKCTR}\~ 0x800\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSCTRL_CLKSRCCTL1_DELAY}\~ asm(" RPT #250 || NOP \\n RPT #50 || NOP")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitSysCtrl} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitPeripheralClocks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DisablePeripheralClocks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitFlash} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FlashOff} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SeizeFlashPump} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReleaseFlashPump} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ServiceDog} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DisableDog} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitAuxPll} (Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Uint16 {\b CsmUnlock} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SysIntOsc1Sel} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SysIntOsc2Sel} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SysXtalOscSel} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AuxIntOsc2Sel} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AuxXtalOscSel} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AuxAuxClkSel} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b IDLE} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b STANDBY} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HALT} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HIB} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v STATUS_FAIL\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:STATUS_FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STATUS_FAIL\~ 0}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v STATUS_SUCCESS\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:STATUS_SUCCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STATUS_SUCCESS\~ 1}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v SYSCTRL_CLKSRCCTL1_DELAY\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:SYSCTRL_CLKSRCCTL1_DELAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSCTRL_CLKSRCCTL1_DELAY\~ asm(" RPT #250 || NOP \\n RPT #50 || NOP")}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v TMR1SYSCLKCTR\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:TMR1SYSCLKCTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TMR1SYSCLKCTR\~ 0xF0000000}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v TMR2INPCLKCTR\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:TMR2INPCLKCTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TMR2INPCLKCTR\~ 0x800}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v AuxAuxClkSel\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:AuxAuxClkSel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AuxAuxClkSel (void )}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1231} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v AuxIntOsc2Sel\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:AuxIntOsc2Sel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AuxIntOsc2Sel (void )}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1209} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v AuxXtalOscSel\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:AuxXtalOscSel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AuxXtalOscSel (void )}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1220} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v CsmUnlock\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:CsmUnlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Uint16 CsmUnlock (void )}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1144} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v DisableDog\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:DisableDog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DisableDog (void )}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 489} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v DisablePeripheralClocks\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:DisablePeripheralClocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DisablePeripheralClocks (void )}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 289} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v FlashOff\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:FlashOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlashOff (void )}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 419} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v HALT\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:HALT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HALT (void )}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1263} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v HIB\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:HIB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HIB (void )}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1285} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v IDLE\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:IDLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void IDLE (void )}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1241} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v InitAuxPll\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:InitAuxPll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitAuxPll (Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 909} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v InitFlash\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:InitFlash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitFlash (void )}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 328} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v InitPeripheralClocks\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:InitPeripheralClocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitPeripheralClocks (void )}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 193} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v InitSysCtrl\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:InitSysCtrl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitSysCtrl (void )}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v ReleaseFlashPump\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:ReleaseFlashPump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ReleaseFlashPump (void )}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 466} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v SeizeFlashPump\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:SeizeFlashPump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SeizeFlashPump (void )}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 445} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v ServiceDog\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:ServiceDog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ServiceDog (void )}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v STANDBY\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:STANDBY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void STANDBY (void )}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1252} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v SysIntOsc1Sel\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:SysIntOsc1Sel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SysIntOsc1Sel (void )}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1171} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v SysIntOsc2Sel\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:SysIntOsc2Sel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SysIntOsc2Sel (void )}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1183} of file {\b F2837xD_SysCtrl.c}.}\par
}
{\xe \v SysXtalOscSel\:F2837xD_SysCtrl.c}
{\xe \v F2837xD_SysCtrl.c\:SysXtalOscSel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SysXtalOscSel (void )}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1197} of file {\b F2837xD_SysCtrl.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F2837xD_SysCtrl.c\par \pard\plain 
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //###########################################################################}\par
00002 {\cf20 //}\par
00003 {\cf20 // FILE:   F2837xD_SysCtrl.c}\par
00004 {\cf20 //}\par
00005 {\cf20 // TITLE:  F2837xD Device System Control Initialization & Support Functions.}\par
00006 {\cf20 //}\par
00007 {\cf20 // DESCRIPTION:}\par
00008 {\cf20 //}\par
00009 {\cf20 //         Example initialization of system resources.}\par
00010 {\cf20 //}\par
00011 {\cf20 //###########################################################################}\par
00012 {\cf20 // $TI Release: F2837xD Support Library v3.10.00.00 $}\par
00013 {\cf20 // $Release Date: Tue May 26 17:13:46 IST 2020 $}\par
00014 {\cf20 // $Copyright:}\par
00015 {\cf20 // Copyright (C) 2013-2020 Texas Instruments Incorporated - http://www.ti.com/}\par
00016 {\cf20 //}\par
00017 {\cf20 // Redistribution and use in source and binary forms, with or without }\par
00018 {\cf20 // modification, are permitted provided that the following conditions }\par
00019 {\cf20 // are met:}\par
00020 {\cf20 // }\par
00021 {\cf20 //   Redistributions of source code must retain the above copyright }\par
00022 {\cf20 //   notice, this list of conditions and the following disclaimer.}\par
00023 {\cf20 // }\par
00024 {\cf20 //   Redistributions in binary form must reproduce the above copyright}\par
00025 {\cf20 //   notice, this list of conditions and the following disclaimer in the }\par
00026 {\cf20 //   documentation and/or other materials provided with the   }\par
00027 {\cf20 //   distribution.}\par
00028 {\cf20 // }\par
00029 {\cf20 //   Neither the name of Texas Instruments Incorporated nor the names of}\par
00030 {\cf20 //   its contributors may be used to endorse or promote products derived}\par
00031 {\cf20 //   from this software without specific prior written permission.}\par
00032 {\cf20 // }\par
00033 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }\par
00034 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT }\par
00035 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00036 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT }\par
00037 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, }\par
00038 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT }\par
00039 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00040 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00041 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT }\par
00042 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE }\par
00043 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00044 {\cf20 // $}\par
00045 {\cf20 //###########################################################################}\par
00046 \par
00047 {\cf20 //}\par
00048 {\cf20 // Included Files}\par
00049 {\cf20 //}\par
00050 {\cf21 #include "F2837xD_device.h"}\par
00051 {\cf21 #include "F2837xD_Examples.h"}\par
00052 {\cf21 #ifdef __cplusplus}\par
00053 {\cf17 using }std::memcpy;\par
00054 {\cf21 #endif}\par
00055 \par
00056 {\cf21 #define STATUS_FAIL          0}\par
00057 {\cf21 #define STATUS_SUCCESS       1}\par
00058 {\cf21 #define TMR1SYSCLKCTR        0xF0000000}\par
00059 {\cf21 #define TMR2INPCLKCTR        0x800}\par
00060 \par
00061 {\cf20 //}\par
00062 {\cf20 // Functions that will be run from RAM need to be assigned to a different}\par
00063 {\cf20 // section.  This section will then be mapped to a load and run address using}\par
00064 {\cf20 // the linker cmd file.}\par
00065 {\cf20 //}\par
00066 {\cf20 //      *IMPORTANT*}\par
00067 {\cf20 //}\par
00068 {\cf20 //  IF RUNNING FROM FLASH, PLEASE COPY OVER THE SECTION ".TI.ramfunc" FROM}\par
00069 {\cf20 //  FLASH TO RAM PRIOR TO CALLING InitSysCtrl(). THIS PREVENTS THE MCU FROM}\par
00070 {\cf20 //  THROWING AN EXCEPTION WHEN A CALL TO DELAY_US() IS MADE.}\par
00071 {\cf20 //}\par
00072 {\cf21 #ifndef __cplusplus}\par
00073 {\cf21     #ifdef __TI_COMPILER_VERSION__}\par
00074 {\cf21         #if __TI_COMPILER_VERSION__ >= 15009000}\par
00075 {\cf21             #pragma CODE_SECTION(InitFlash, ".TI.ramfunc");}\par
00076 {\cf21             #pragma CODE_SECTION(FlashOff, ".TI.ramfunc");}\par
00077 {\cf21         #else}\par
00078 {\cf21             #pragma CODE_SECTION(InitFlash, "ramfuncs");}\par
00079 {\cf21             #pragma CODE_SECTION(FlashOff, "ramfuncs");}\par
00080 {\cf21         #endif}\par
00081 {\cf21     #endif}\par
00082 {\cf21 #endif}\par
00083 \par
00084 {\cf20 //}\par
00085 {\cf20 // Macro used for adding delay between 2 consecutive writes to CLKSRCCTL1}\par
00086 {\cf20 // register.}\par
00087 {\cf20 // Delay = 300 NOPs}\par
00088 {\cf20 //}\par
00089 {\cf21 #define SYSCTRL_CLKSRCCTL1_DELAY  asm(" RPT #250 || NOP \\n RPT #50 || NOP")}\par
00090 \par
00091 {\cf20 //}\par
00092 {\cf20 // InitSysCtrl - Initialization of system resources.}\par
00093 {\cf20 //}\par
00094 {\cf18 void} InitSysCtrl({\cf18 void})\par
00095 \{\par
00096     {\cf20 //}\par
00097     {\cf20 // Disable the watchdog}\par
00098     {\cf20 //}\par
00099     DisableDog();\par
00100 \par
00101 {\cf21 #ifdef _FLASH}\par
00102     {\cf20 //}\par
00103     {\cf20 // Copy time critical code and Flash setup code to RAM. This includes the}\par
00104     {\cf20 // following functions: InitFlash()}\par
00105     {\cf20 //}\par
00106     {\cf20 // The  RamfuncsLoadStart, RamfuncsLoadSize, and RamfuncsRunStart}\par
00107     {\cf20 // symbols are created by the linker. Refer to the device .cmd file.}\par
00108     {\cf20 //}\par
00109     memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, ({\cf18 size_t})&RamfuncsLoadSize);\par
00110 \par
00111     {\cf20 //}\par
00112     {\cf20 // Call Flash Initialization to setup flash waitstates. This function must}\par
00113     {\cf20 // reside in RAM.}\par
00114     {\cf20 //}\par
00115     InitFlash();\par
00116 {\cf21 #endif}\par
00117 \par
00118     {\cf20 //}\par
00119     {\cf20 //      *IMPORTANT*}\par
00120     {\cf20 //}\par
00121     {\cf20 // The Device_cal function, which copies the ADC & oscillator calibration}\par
00122     {\cf20 // values from TI reserved OTP into the appropriate trim registers, occurs}\par
00123     {\cf20 // automatically in the Boot ROM. If the boot ROM code is bypassed during}\par
00124     {\cf20 // the debug process, the following function MUST be called for the ADC and}\par
00125     {\cf20 // oscillators to function according to specification. The clocks to the}\par
00126     {\cf20 // ADC MUST be enabled before calling this function.}\par
00127     {\cf20 //}\par
00128     {\cf20 // See the device data manual and/or the ADC Reference Manual for more}\par
00129     {\cf20 // information.}\par
00130     {\cf20 //}\par
00131 {\cf21 #ifdef CPU1}\par
00132     EALLOW;\par
00133 \par
00134     {\cf20 //}\par
00135     {\cf20 // Enable pull-ups on unbonded IOs as soon as possible to reduce power}\par
00136     {\cf20 // consumption.}\par
00137     {\cf20 //}\par
00138     GPIO_EnableUnbondedIOPullups();\par
00139 \par
00140     {\cf20 //}\par
00141     {\cf20 // Check if the device is trimmed}\par
00142     {\cf20 //}\par
00143     {\cf19 if}((DevCfgRegs.PARTIDL.bit.QUAL == 0x0) &&\par
00144        (AnalogSubsysRegs.ANAREFTRIMA.all == 0x0))\par
00145     \{\par
00146         ConfigureTMXAnalogTrim();\par
00147     \}\par
00148 \par
00149     EDIS;\par
00150 \par
00151     {\cf20 //}\par
00152     {\cf20 // Initialize the PLL control: SYSPLLMULT and SYSCLKDIVSEL.}\par
00153     {\cf20 //}\par
00154     {\cf20 // Defined options to be passed as arguments to this function are defined}\par
00155     {\cf20 // in F2837xD_Examples.h.}\par
00156     {\cf20 //}\par
00157     {\cf20 // Note: The internal oscillator CANNOT be used as the PLL source if the}\par
00158     {\cf20 // PLLSYSCLK is configured to frequencies above 194 MHz.}\par
00159     {\cf20 //}\par
00160     {\cf20 //  PLLSYSCLK = (XTAL_OSC) * (IMULT + FMULT) / (PLLSYSCLKDIV)}\par
00161     {\cf20 //}\par
00162 {\cf21 #ifdef _LAUNCHXL_F28379D}\par
00163     InitSysPll(XTAL_OSC,IMULT_40,FMULT_0,PLLCLK_BY_2);\par
00164 {\cf21 #else}\par
00165     InitSysPll(XTAL_OSC, IMULT_20, FMULT_0, PLLCLK_BY_2);\par
00166 {\cf21 #endif }{\cf20 // _LAUNCHXL_F28379D}\par
00167 \par
00168 {\cf21 #ifndef _FLASH}\par
00169     {\cf20 //}\par
00170     {\cf20 // Call Device_cal function when run using debugger}\par
00171     {\cf20 // This function is called as part of the Boot code. The function is called}\par
00172     {\cf20 // in the InitSysCtrl function since during debug time resets, the boot code}\par
00173     {\cf20 // will not be executed and the gel script will reinitialize all the}\par
00174     {\cf20 // registers and the calibrated values will be lost.}\par
00175     {\cf20 //}\par
00176     Device_cal();\par
00177 {\cf21 #endif}\par
00178 {\cf21 #endif }{\cf20 // CPU1}\par
00179 \par
00180     {\cf20 //}\par
00181     {\cf20 // Turn on all peripherals}\par
00182     {\cf20 //}\par
00183     InitPeripheralClocks();\par
00184 \}\par
00185 \par
00186 {\cf20 //}\par
00187 {\cf20 // InitPeripheralClocks - Initializes the clocks for the peripherals.}\par
00188 {\cf20 //}\par
00189 {\cf20 // Note: In order to reduce power consumption, turn off the clocks to any}\par
00190 {\cf20 // peripheral that is not specified for your part-number or is not used in the}\par
00191 {\cf20 // application}\par
00192 {\cf20 //}\par
00193 {\cf18 void} InitPeripheralClocks({\cf18 void})\par
00194 \{\par
00195     EALLOW;\par
00196 \par
00197     CpuSysRegs.PCLKCR0.bit.CLA1 = 1;\par
00198     CpuSysRegs.PCLKCR0.bit.DMA = 1;\par
00199     CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;\par
00200     CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1;\par
00201     CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1;\par
00202 \par
00203 {\cf21 #ifdef CPU1}\par
00204     CpuSysRegs.PCLKCR0.bit.HRPWM = 1;\par
00205 {\cf21 #endif}\par
00206 \par
00207     CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;\par
00208 \par
00209 {\cf21 #ifdef CPU1}\par
00210     CpuSysRegs.PCLKCR1.bit.EMIF1 = 1;\par
00211     CpuSysRegs.PCLKCR1.bit.EMIF2 = 1;\par
00212 {\cf21 #endif}\par
00213 \par
00214     CpuSysRegs.PCLKCR2.bit.EPWM1 = 1;\par
00215     CpuSysRegs.PCLKCR2.bit.EPWM2 = 1;\par
00216     CpuSysRegs.PCLKCR2.bit.EPWM3 = 1;\par
00217     CpuSysRegs.PCLKCR2.bit.EPWM4 = 1;\par
00218     CpuSysRegs.PCLKCR2.bit.EPWM5 = 1;\par
00219     CpuSysRegs.PCLKCR2.bit.EPWM6 = 1;\par
00220     CpuSysRegs.PCLKCR2.bit.EPWM7 = 1;\par
00221     CpuSysRegs.PCLKCR2.bit.EPWM8 = 1;\par
00222     CpuSysRegs.PCLKCR2.bit.EPWM9 = 1;\par
00223     CpuSysRegs.PCLKCR2.bit.EPWM10 = 1;\par
00224     CpuSysRegs.PCLKCR2.bit.EPWM11 = 1;\par
00225     CpuSysRegs.PCLKCR2.bit.EPWM12 = 1;\par
00226 \par
00227     CpuSysRegs.PCLKCR3.bit.ECAP1 = 1;\par
00228     CpuSysRegs.PCLKCR3.bit.ECAP2 = 1;\par
00229     CpuSysRegs.PCLKCR3.bit.ECAP3 = 1;\par
00230     CpuSysRegs.PCLKCR3.bit.ECAP4 = 1;\par
00231     CpuSysRegs.PCLKCR3.bit.ECAP5 = 1;\par
00232     CpuSysRegs.PCLKCR3.bit.ECAP6 = 1;\par
00233 \par
00234     CpuSysRegs.PCLKCR4.bit.EQEP1 = 1;\par
00235     CpuSysRegs.PCLKCR4.bit.EQEP2 = 1;\par
00236     CpuSysRegs.PCLKCR4.bit.EQEP3 = 1;\par
00237 \par
00238     CpuSysRegs.PCLKCR6.bit.SD1 = 1;\par
00239     CpuSysRegs.PCLKCR6.bit.SD2 = 1;\par
00240 \par
00241     CpuSysRegs.PCLKCR7.bit.SCI_A = 1;\par
00242     CpuSysRegs.PCLKCR7.bit.SCI_B = 1;\par
00243     CpuSysRegs.PCLKCR7.bit.SCI_C = 1;\par
00244     CpuSysRegs.PCLKCR7.bit.SCI_D = 1;\par
00245 \par
00246     CpuSysRegs.PCLKCR8.bit.SPI_A = 1;\par
00247     CpuSysRegs.PCLKCR8.bit.SPI_B = 1;\par
00248     CpuSysRegs.PCLKCR8.bit.SPI_C = 1;\par
00249 \par
00250     CpuSysRegs.PCLKCR9.bit.I2C_A = 1;\par
00251     CpuSysRegs.PCLKCR9.bit.I2C_B = 1;\par
00252 \par
00253     CpuSysRegs.PCLKCR10.bit.CAN_A = 1;\par
00254     CpuSysRegs.PCLKCR10.bit.CAN_B = 1;\par
00255 \par
00256     CpuSysRegs.PCLKCR11.bit.McBSP_A = 1;\par
00257     CpuSysRegs.PCLKCR11.bit.McBSP_B = 1;\par
00258 \par
00259 {\cf21 #ifdef CPU1}\par
00260     CpuSysRegs.PCLKCR11.bit.USB_A = 1;\par
00261 \par
00262     CpuSysRegs.PCLKCR12.bit.uPP_A = 1;\par
00263 {\cf21 #endif}\par
00264 \par
00265     CpuSysRegs.PCLKCR13.bit.ADC_A = 1;\par
00266     CpuSysRegs.PCLKCR13.bit.ADC_B = 1;\par
00267     CpuSysRegs.PCLKCR13.bit.ADC_C = 1;\par
00268     CpuSysRegs.PCLKCR13.bit.ADC_D = 1;\par
00269 \par
00270     CpuSysRegs.PCLKCR14.bit.CMPSS1 = 1;\par
00271     CpuSysRegs.PCLKCR14.bit.CMPSS2 = 1;\par
00272     CpuSysRegs.PCLKCR14.bit.CMPSS3 = 1;\par
00273     CpuSysRegs.PCLKCR14.bit.CMPSS4 = 1;\par
00274     CpuSysRegs.PCLKCR14.bit.CMPSS5 = 1;\par
00275     CpuSysRegs.PCLKCR14.bit.CMPSS6 = 1;\par
00276     CpuSysRegs.PCLKCR14.bit.CMPSS7 = 1;\par
00277     CpuSysRegs.PCLKCR14.bit.CMPSS8 = 1;\par
00278 \par
00279     CpuSysRegs.PCLKCR16.bit.DAC_A = 1;\par
00280     CpuSysRegs.PCLKCR16.bit.DAC_B = 1;\par
00281     CpuSysRegs.PCLKCR16.bit.DAC_C = 1;\par
00282 \par
00283     EDIS;\par
00284 \}\par
00285 \par
00286 {\cf20 //}\par
00287 {\cf20 // DisablePeripheralClocks - Gates-off all peripheral clocks.}\par
00288 {\cf20 //}\par
00289 {\cf18 void} DisablePeripheralClocks({\cf18 void})\par
00290 \{\par
00291     EALLOW;\par
00292 \par
00293     CpuSysRegs.PCLKCR0.all = 0;\par
00294     CpuSysRegs.PCLKCR1.all = 0;\par
00295     CpuSysRegs.PCLKCR2.all = 0;\par
00296     CpuSysRegs.PCLKCR3.all = 0;\par
00297     CpuSysRegs.PCLKCR4.all = 0;\par
00298     CpuSysRegs.PCLKCR6.all = 0;\par
00299     CpuSysRegs.PCLKCR7.all = 0;\par
00300     CpuSysRegs.PCLKCR8.all = 0;\par
00301     CpuSysRegs.PCLKCR9.all = 0;\par
00302     CpuSysRegs.PCLKCR10.all = 0;\par
00303     CpuSysRegs.PCLKCR11.all = 0;\par
00304     CpuSysRegs.PCLKCR12.all = 0;\par
00305     CpuSysRegs.PCLKCR13.all = 0;\par
00306     CpuSysRegs.PCLKCR14.all = 0;\par
00307     CpuSysRegs.PCLKCR16.all = 0;\par
00308 \par
00309     EDIS;\par
00310 \}\par
00311 \par
00312 {\cf20 //}\par
00313 {\cf20 // InitFlash - This function initializes the Flash Control registers.}\par
00314 {\cf20 //}\par
00315 {\cf20 //      *CAUTION*}\par
00316 {\cf20 // This function MUST be executed out of RAM. Executing it out of OTP/Flash}\par
00317 {\cf20 // will yield unpredictable results.}\par
00318 {\cf20 //}\par
00319 {\cf21 #ifdef __cplusplus}\par
00320 {\cf21     #ifdef __TI_COMPILER_VERSION__}\par
00321 {\cf21         #if __TI_COMPILER_VERSION__ >= 15009000}\par
00322 {\cf21             #pragma CODE_SECTION(".TI.ramfunc");}\par
00323 {\cf21         #else}\par
00324 {\cf21             #pragma CODE_SECTION("ramfuncs");}\par
00325 {\cf21         #endif}\par
00326 {\cf21     #endif}\par
00327 {\cf21 #endif}\par
00328 {\cf18 void} InitFlash({\cf18 void})\par
00329 \{\par
00330     EALLOW;\par
00331 \par
00332     {\cf20 //}\par
00333     {\cf20 // The default value of VREADST is good enough for the flash to power up}\par
00334     {\cf20 // properly at the INTOSC frequency. Below VREADST configuration covers up}\par
00335     {\cf20 // to the max frequency possible for this device. This is required for}\par
00336     {\cf20 // proper flash wake up at the higher frequencies if users put it to sleep}\par
00337     {\cf20 // for power saving reason.}\par
00338     {\cf20 //}\par
00339     Flash0CtrlRegs.FBAC.bit.VREADST = 0x14;\par
00340 \par
00341     {\cf20 //}\par
00342     {\cf20 // At reset bank and pump are in sleep. A Flash access will power up the}\par
00343     {\cf20 // bank and pump automatically.}\par
00344     {\cf20 //}\par
00345     {\cf20 // After a Flash access, bank and pump go to low power mode (configurable}\par
00346     {\cf20 // in FBFALLBACK/FPAC1 registers) if there is no further access to flash.}\par
00347     {\cf20 //}\par
00348     {\cf20 // Power up Flash bank and pump. This also sets the fall back mode of}\par
00349     {\cf20 // flash and pump as active.}\par
00350     {\cf20 //}\par
00351     Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0x1;\par
00352     Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0x3;\par
00353 \par
00354     {\cf20 //}\par
00355     {\cf20 // Disable Cache and prefetch mechanism before changing wait states}\par
00356     {\cf20 //}\par
00357     Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 0;\par
00358     Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 0;\par
00359 \par
00360     {\cf20 //}\par
00361     {\cf20 // Set waitstates according to frequency}\par
00362     {\cf20 //}\par
00363     {\cf20 //      *CAUTION*}\par
00364     {\cf20 // Minimum waitstates required for the flash operating at a given CPU rate}\par
00365     {\cf20 // must be characterized by TI. Refer to the datasheet for the latest}\par
00366     {\cf20 // information.}\par
00367     {\cf20 //}\par
00368 {\cf21     #if CPU_FRQ_200MHZ}\par
00369     Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x3;\par
00370 {\cf21     #endif}\par
00371 \par
00372 {\cf21     #if CPU_FRQ_150MHZ}\par
00373     Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x2;\par
00374 {\cf21     #endif}\par
00375 \par
00376 {\cf21     #if CPU_FRQ_120MHZ}\par
00377     Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x2;\par
00378 {\cf21     #endif}\par
00379 \par
00380     {\cf20 //}\par
00381     {\cf20 // Enable Cache and prefetch mechanism to improve performance of code}\par
00382     {\cf20 // executed from Flash.}\par
00383     {\cf20 //}\par
00384     Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 1;\par
00385     Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 1;\par
00386 \par
00387     {\cf20 //}\par
00388     {\cf20 // At reset, ECC is enabled. If it is disabled by application software and}\par
00389     {\cf20 // if application again wants to enable ECC.}\par
00390     {\cf20 //}\par
00391     Flash0EccRegs.ECC_ENABLE.bit.ENABLE = 0xA;\par
00392 \par
00393     EDIS;\par
00394 \par
00395     {\cf20 //}\par
00396     {\cf20 // Force a pipeline flush to ensure that the write to the last register}\par
00397     {\cf20 // configured occurs before returning.}\par
00398     {\cf20 //}\par
00399     __asm({\cf22 " RPT #7 || NOP"});\par
00400 \}\par
00401 \par
00402 {\cf20 //}\par
00403 {\cf20 // FlashOff - This function powers down the flash}\par
00404 {\cf20 //}\par
00405 {\cf20 //      *CAUTION*}\par
00406 {\cf20 // This function MUST be executed out of RAM. Executing it out of OTP/Flash}\par
00407 {\cf20 // will yield unpredictable results. Also you must seize the flash pump in}\par
00408 {\cf20 // order to power it down.}\par
00409 {\cf20 //}\par
00410 {\cf21 #ifdef __cplusplus}\par
00411 {\cf21     #ifdef __TI_COMPILER_VERSION__}\par
00412 {\cf21         #if __TI_COMPILER_VERSION__ >= 15009000}\par
00413 {\cf21             #pragma CODE_SECTION(".TI.ramfunc");}\par
00414 {\cf21         #else}\par
00415 {\cf21             #pragma CODE_SECTION("ramfuncs");}\par
00416 {\cf21         #endif}\par
00417 {\cf21     #endif}\par
00418 {\cf21 #endif}\par
00419 {\cf18 void} FlashOff({\cf18 void})\par
00420 \{\par
00421     EALLOW;\par
00422 \par
00423     {\cf20 //}\par
00424     {\cf20 // Set VREADST to the proper value for the flash banks to power up properly}\par
00425     {\cf20 //}\par
00426     Flash0CtrlRegs.FBAC.bit.VREADST = 0x14;\par
00427 \par
00428     {\cf20 //}\par
00429     {\cf20 // Power down bank}\par
00430     {\cf20 //}\par
00431     Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0;\par
00432 \par
00433     {\cf20 //}\par
00434     {\cf20 // Power down pump}\par
00435     {\cf20 //}\par
00436     Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0;\par
00437 \par
00438     EDIS;\par
00439 \}\par
00440 \par
00441 {\cf20 //}\par
00442 {\cf20 // SeizeFlashPump - Wait until the flash pump is available. Then take control}\par
00443 {\cf20 //                  of it using the flash pump Semaphore.}\par
00444 {\cf20 //}\par
00445 {\cf18 void} SeizeFlashPump({\cf18 void})\par
00446 \{\par
00447     EALLOW;\par
00448 {\cf21     #ifdef CPU1}\par
00449         {\cf19 while} (FlashPumpSemaphoreRegs.PUMPREQUEST.bit.PUMP_OWNERSHIP != 0x2)\par
00450         \{\par
00451             FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x2;\par
00452         \}\par
00453 {\cf21     #elif defined(CPU2)}\par
00454         {\cf19 while} (FlashPumpSemaphoreRegs.PUMPREQUEST.bit.PUMP_OWNERSHIP != 0x1)\par
00455         \{\par
00456             FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x1;\par
00457         \}\par
00458 {\cf21     #endif}\par
00459     EDIS;\par
00460 \}\par
00461 \par
00462 {\cf20 //}\par
00463 {\cf20 // ReleaseFlashPump - Release control of the flash pump using the flash pump}\par
00464 {\cf20 //                    semaphore.}\par
00465 {\cf20 //}\par
00466 {\cf18 void} ReleaseFlashPump({\cf18 void})\par
00467 \{\par
00468     EALLOW;\par
00469     FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x0;\par
00470     EDIS;\par
00471 \}\par
00472 \par
00473 {\cf20 //}\par
00474 {\cf20 // ServiceDog - This function resets the watchdog timer.}\par
00475 {\cf20 //}\par
00476 {\cf20 // Enable this function for using ServiceDog in the application.}\par
00477 {\cf20 //}\par
00478 {\cf18 void} ServiceDog({\cf18 void})\par
00479 \{\par
00480     EALLOW;\par
00481     WdRegs.WDKEY.bit.WDKEY = 0x0055;\par
00482     WdRegs.WDKEY.bit.WDKEY = 0x00AA;\par
00483     EDIS;\par
00484 \}\par
00485 \par
00486 {\cf20 //}\par
00487 {\cf20 // DisableDog - This function disables the watchdog timer.}\par
00488 {\cf20 //}\par
00489 {\cf18 void} DisableDog({\cf18 void})\par
00490 \{\par
00491     {\cf17 volatile} Uint16 temp;\par
00492 \par
00493     {\cf20 //}\par
00494     {\cf20 // Grab the clock config first so we don't clobber it}\par
00495     {\cf20 //}\par
00496     EALLOW;\par
00497     temp = WdRegs.WDCR.all & 0x0007;\par
00498     WdRegs.WDCR.all = 0x0068 | temp;\par
00499     EDIS;\par
00500 \}\par
00501 \par
00502 {\cf21 #ifdef CPU1}\par
00503 {\cf20 //}\par
00504 {\cf20 // InitSysPll()}\par
00505 {\cf20 // This function initializes the PLL registers.}\par
00506 {\cf20 // Note:}\par
00507 {\cf20 //  - The internal oscillator CANNOT be used as the PLL source if the}\par
00508 {\cf20 //    PLLSYSCLK is configured to frequencies above 194 MHz.}\par
00509 {\cf20 //}\par
00510 {\cf20 //  - This function uses the Watchdog as a monitor for the PLL. The user}\par
00511 {\cf20 //  watchdog settings will be modified and restored upon completion.  Function}\par
00512 {\cf20 //  allows for a minimum re lock attempt for 5 tries.  Re lock attempt is carried}\par
00513 {\cf20 //  out if either SLIP condition occurs or SYSCLK to Input Clock ratio is off by 10%}\par
00514 {\cf20 //}\par
00515 {\cf20 //  - This function uses the following resources to support PLL initialization:}\par
00516 {\cf20 //          o Watchdog}\par
00517 {\cf20 //          o CPU Timer 1}\par
00518 {\cf20 //          o CPU Timer 2}\par
00519 {\cf20 //}\par
00520 {\cf18 void} InitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\par
00521 \{\par
00522     Uint16 SCSR, WDCR, WDWCR, intStatus,  t1TCR, t1TPR, t1TPRH;\par
00523     Uint16 t2TCR, t2TPR, t2TPRH, t2SRC, t2Prescale;\par
00524     Uint32 t1PRD, t2PRD, ctr1;\par
00525     {\cf18 float} sysclkToInClkError, mult, div;\par
00526     {\cf18 bool} sysclkInvalidFreq={\cf17 true};\par
00527 \par
00528     {\cf19 if}((clock_source == ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)    &&\par
00529        (imult        == ClkCfgRegs.SYSPLLMULT.bit.IMULT)           &&\par
00530        (fmult        == ClkCfgRegs.SYSPLLMULT.bit.FMULT)           &&\par
00531        (divsel       == ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV))\par
00532     \{\par
00533         {\cf20 //}\par
00534         {\cf20 // Everything is set as required, so just return}\par
00535         {\cf20 //}\par
00536         {\cf19 return};\par
00537     \}\par
00538 \par
00539     {\cf19 if}(clock_source != ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)\par
00540     \{\par
00541         {\cf19 switch} (clock_source)\par
00542         \{\par
00543             {\cf19 case} INT_OSC1:\par
00544                 SysIntOsc1Sel();\par
00545                 {\cf19 break};\par
00546 \par
00547             {\cf19 case} INT_OSC2:\par
00548                 SysIntOsc2Sel();\par
00549                 {\cf19 break};\par
00550 \par
00551             {\cf19 case} XTAL_OSC:\par
00552                 SysXtalOscSel();\par
00553                 {\cf19 break};\par
00554         \}\par
00555     \}\par
00556 \par
00557     EALLOW;\par
00558     {\cf19 if}(imult != ClkCfgRegs.SYSPLLMULT.bit.IMULT ||\par
00559        fmult != ClkCfgRegs.SYSPLLMULT.bit.FMULT)\par
00560     \{\par
00561         Uint16 i;\par
00562 \par
00563         {\cf20 //}\par
00564         {\cf20 // This bit is reset only by POR}\par
00565         {\cf20 //}\par
00566         {\cf19 if}(DevCfgRegs.SYSDBGCTL.bit.BIT_0 == 1)\par
00567         \{\par
00568             {\cf20 //}\par
00569             {\cf20 // The user can optionally insert handler code here. This will only}\par
00570             {\cf20 // be executed if a watchdog reset occurred after a failed system}\par
00571             {\cf20 // PLL initialization. See your device user's guide for more}\par
00572             {\cf20 // information.}\par
00573             {\cf20 //}\par
00574             {\cf20 // If the application has a watchdog reset handler, this bit should}\par
00575             {\cf20 // be checked to determine if the watchdog reset occurred because}\par
00576             {\cf20 // of the PLL.}\par
00577             {\cf20 //}\par
00578             {\cf20 // No action here will continue with retrying the PLL as normal.}\par
00579             {\cf20 //}\par
00580             {\cf20 // Failed PLL initialization is due to any of the following:}\par
00581             {\cf20 //      - No PLL clock}\par
00582             {\cf20 //      - SLIP condition}\par
00583             {\cf20 //      - Wrong Frequency}\par
00584             {\cf20 //}\par
00585         \}\par
00586 \par
00587         {\cf20 //}\par
00588         {\cf20 // Bypass PLL and set dividers to /1}\par
00589         {\cf20 //}\par
00590         ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\par
00591 \par
00592         {\cf20 //}\par
00593         {\cf20 // Delay of at least 120 OSCCLK cycles required post PLL bypass}\par
00594         {\cf20 //}\par
00595         {\cf17 asm}({\cf22 " RPT #120 || NOP"});\par
00596         ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = 0;\par
00597 \par
00598         {\cf20 //}\par
00599         {\cf20 // Lock the PLL five times. This helps ensure a successful start.}\par
00600         {\cf20 // Five is the minimum recommended number. The user can increase this}\par
00601         {\cf20 // number according to allotted system initialization time.}\par
00602         {\cf20 //}\par
00603         {\cf19 for}(i = 0; i < 5; i++)\par
00604         \{\par
00605             {\cf20 //}\par
00606             {\cf20 // Turn off PLL}\par
00607             {\cf20 //}\par
00608             ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\par
00609             {\cf17 asm}({\cf22 " RPT #20 || NOP"});\par
00610 \par
00611             {\cf20 //}\par
00612             {\cf20 // Write multiplier, which automatically turns on the PLL}\par
00613             {\cf20 //}\par
00614             ClkCfgRegs.SYSPLLMULT.all = ((fmult << 8U) | imult);\par
00615 \par
00616             {\cf20 //}\par
00617             {\cf20 // Wait for the SYSPLL lock counter}\par
00618             {\cf20 //}\par
00619             {\cf19 while}(ClkCfgRegs.SYSPLLSTS.bit.LOCKS != 1)\par
00620             \{\par
00621                 {\cf20 //}\par
00622                 {\cf20 // Uncomment to service the watchdog}\par
00623                 {\cf20 //}\par
00624                 {\cf20 // ServiceDog();}\par
00625             \}\par
00626         \}\par
00627     \}\par
00628 \par
00629     {\cf20 //}\par
00630     {\cf20 // Set divider to produce slower output frequency to limit current increase}\par
00631     {\cf20 //}\par
00632     {\cf19 if}(divsel != PLLCLK_BY_126)\par
00633     \{\par
00634          ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel + 1;\par
00635     \}\par
00636     {\cf19 else}\par
00637     \{\par
00638          ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\par
00639     \}\par
00640 \par
00641     {\cf20 //}\par
00642     {\cf20 //      *CAUTION*}\par
00643     {\cf20 // It is recommended to use the following watchdog code to monitor the PLL}\par
00644     {\cf20 // startup sequence. If your application has already cleared the watchdog}\par
00645     {\cf20 // SCRS[WDOVERRIDE] bit this cannot be done. It is recommended not to clear}\par
00646     {\cf20 // this bit until after the PLL has been initiated.}\par
00647     {\cf20 //}\par
00648 \par
00649     {\cf20 //}\par
00650     {\cf20 // Backup User Watchdog}\par
00651     {\cf20 //}\par
00652     SCSR = WdRegs.SCSR.all;\par
00653     WDCR = WdRegs.WDCR.all;\par
00654     WDWCR = WdRegs.WDWCR.all;\par
00655 \par
00656     {\cf20 //}\par
00657     {\cf20 // Disable windowed functionality, reset counter}\par
00658     {\cf20 //}\par
00659     EALLOW;\par
00660     WdRegs.WDWCR.all = 0x0;\par
00661     WdRegs.WDKEY.bit.WDKEY = 0x55;\par
00662     WdRegs.WDKEY.bit.WDKEY = 0xAA;\par
00663 \par
00664     {\cf20 //}\par
00665     {\cf20 // Disable global interrupts}\par
00666     {\cf20 //}\par
00667     intStatus = __disable_interrupts();\par
00668 \par
00669     {\cf20 //}\par
00670     {\cf20 // Configure for watchdog reset and to run at max frequency}\par
00671     {\cf20 //}\par
00672     WdRegs.SCSR.all = 0x0;\par
00673     WdRegs.WDCR.all = 0x28;\par
00674 \par
00675     {\cf20 //}\par
00676     {\cf20 // This bit is reset only by power-on-reset (POR) and will not be cleared}\par
00677     {\cf20 // by a WD reset}\par
00678     {\cf20 //}\par
00679     DevCfgRegs.SYSDBGCTL.bit.BIT_0 = 1;\par
00680 \par
00681     {\cf20 //}\par
00682     {\cf20 // Enable PLLSYSCLK is fed from system PLL clock}\par
00683     {\cf20 //}\par
00684     ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\par
00685 \par
00686     {\cf20 //}\par
00687     {\cf20 // Delay to ensure system is clocking from PLL prior to clearing status bit}\par
00688     {\cf20 //}\par
00689     {\cf17 asm}({\cf22 " RPT #20 || NOP"});\par
00690 \par
00691     {\cf20 //}\par
00692     {\cf20 // Service watchdog}\par
00693     {\cf20 //}\par
00694     ServiceDog();\par
00695 \par
00696     {\cf20 //}\par
00697     {\cf20 // Slip Bit Monitor and SYSCLK Frequency Check using timers}\par
00698     {\cf20 // Re-lock routine for SLIP condition or if SYSCLK and CLKSRC timer counts}\par
00699     {\cf20 // are off by +/- 10%.}\par
00700     {\cf20 // At a minimum, SYSCLK check is performed.  Re lock attempt is carried out}\par
00701     {\cf20 // if SLIPS bit is set. This while loop is monitored by watchdog.}\par
00702     {\cf20 // In the event that the PLL does not successfully lock, the loop will be}\par
00703     {\cf20 // aborted by watchdog reset.}\par
00704     {\cf20 //}\par
00705     EALLOW;\par
00706     {\cf19 while}(sysclkInvalidFreq == {\cf17 true})\par
00707     \{\par
00708         {\cf19 if}(ClkCfgRegs.SYSPLLSTS.bit.SLIPS == 1)\par
00709         \{\par
00710             {\cf20 //}\par
00711             {\cf20 // Bypass PLL}\par
00712             {\cf20 //}\par
00713             ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\par
00714 \par
00715             {\cf20 //}\par
00716             {\cf20 // Delay of at least 120 OSCCLK cycles required post PLL bypass}\par
00717             {\cf20 //}\par
00718             {\cf17 asm}({\cf22 " RPT #120 || NOP"});\par
00719 \par
00720             {\cf20 //}\par
00721             {\cf20 // Turn off PLL}\par
00722             {\cf20 //}\par
00723             ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\par
00724             {\cf17 asm}({\cf22 " RPT #20 || NOP"});\par
00725 \par
00726             {\cf20 //}\par
00727             {\cf20 // Write multipliers, which automatically turns on the PLL}\par
00728             {\cf20 //}\par
00729             ClkCfgRegs.SYSPLLMULT.all = ((fmult << 8U) | imult);\par
00730 \par
00731             {\cf20 //}\par
00732             {\cf20 // Wait for the SYSPLL lock counter to expire}\par
00733             {\cf20 //}\par
00734             {\cf19 while}(ClkCfgRegs.SYSPLLSTS.bit.LOCKS != 1);\par
00735 \par
00736             {\cf20 //}\par
00737             {\cf20 // Enable PLLSYSCLK is fed from system PLL clock}\par
00738             {\cf20 //}\par
00739             ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\par
00740 \par
00741             {\cf20 //}\par
00742             {\cf20 // Delay to ensure system is clocking from PLL}\par
00743             {\cf20 //}\par
00744             {\cf17 asm}({\cf22 " RPT #20 || NOP"});\par
00745         \}\par
00746 \par
00747         {\cf20 //}\par
00748         {\cf20 // Backup timer1 and timer2 settings}\par
00749         {\cf20 //}\par
00750         t1TCR = CpuTimer1Regs.TCR.all;\par
00751         t1PRD = CpuTimer1Regs.PRD.all;\par
00752         t1TPR = CpuTimer1Regs.TPR.all;\par
00753         t1TPRH = CpuTimer1Regs.TPRH.all;\par
00754         t2SRC = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL;\par
00755         t2Prescale = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE;\par
00756         t2TCR = CpuTimer2Regs.TCR.all;\par
00757         t2PRD = CpuTimer2Regs.PRD.all;\par
00758         t2TPR = CpuTimer2Regs.TPR.all;\par
00759         t2TPRH = CpuTimer2Regs.TPRH.all;\par
00760 \par
00761         {\cf20 //}\par
00762         {\cf20 // Set up timers 1 and 2}\par
00763         {\cf20 // Configure timer1 to count SYSCLK cycles}\par
00764         {\cf20 //}\par
00765         CpuTimer1Regs.TCR.bit.TSS = 1;                                    {\cf20 // stop timer1}\par
00766         CpuTimer1Regs.PRD.all = TMR1SYSCLKCTR;                            {\cf20 // seed timer1 counter}\par
00767         CpuTimer1Regs.TPR.bit.TDDR = 0x0;                                 {\cf20 // sysclock divider}\par
00768         CpuTimer1Regs.TCR.bit.TRB = 1;                                    {\cf20 // reload timer with value in PRD}\par
00769         CpuTimer1Regs.TCR.bit.TIF = 1;                                    {\cf20 // clear interrupt flag}\par
00770         CpuTimer1Regs.TCR.bit.TIE = 1;                                    {\cf20 // enable interrupt}\par
00771 \par
00772         {\cf20 //}\par
00773         {\cf20 // Configure timer2 to count Input clock cycles}\par
00774         {\cf20 //}\par
00775         {\cf19 switch}(clock_source)\par
00776         \{\par
00777             {\cf19 case} INT_OSC1:\par
00778                 {\cf20 // Clk Src = INT_OSC1}\par
00779                 CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x1;\par
00780                 {\cf19 break};\par
00781             {\cf19 case} INT_OSC2:\par
00782                 {\cf20 // Clk Src = INT_OSC2}\par
00783                 CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x2;\par
00784                 {\cf19 break};\par
00785             {\cf19 case} XTAL_OSC:\par
00786                 {\cf20 // Clk Src = XTAL}\par
00787                 CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x3;\par
00788                 {\cf19 break};\par
00789 \par
00790         \}\par
00791         CpuTimer2Regs.TCR.bit.TIF = 1;                                    {\cf20 // clear interrupt flag}\par
00792         CpuTimer2Regs.TCR.bit.TIE = 1;                                    {\cf20 // enable interrupt}\par
00793         CpuTimer2Regs.TCR.bit.TSS = 1;                                    {\cf20 // stop timer2}\par
00794         CpuTimer2Regs.PRD.all = TMR2INPCLKCTR;                            {\cf20 // seed timer2 counter}\par
00795         CpuTimer2Regs.TPR.bit.TDDR = 0x0;                                 {\cf20 // sysclock divider}\par
00796         CpuTimer2Regs.TCR.bit.TRB = 1;                                    {\cf20 // reload timer with value in PRD}\par
00797 \par
00798         {\cf20 //}\par
00799         {\cf20 // Stop/Start timer counters}\par
00800         {\cf20 //}\par
00801         CpuTimer1Regs.TCR.bit.TSS = 1;                                    {\cf20 // stop timer1}\par
00802         CpuTimer2Regs.TCR.bit.TSS = 1;                                    {\cf20 // stop timer2}\par
00803         CpuTimer1Regs.TCR.bit.TRB = 1;                                    {\cf20 // reload timer1 with value in PRD}\par
00804         CpuTimer2Regs.TCR.bit.TRB = 1;                                    {\cf20 // reload timer2 with value in PRD}\par
00805         CpuTimer2Regs.TCR.bit.TIF = 1;                                    {\cf20 // clear timer2 interrupt flag}\par
00806         CpuTimer2Regs.TCR.bit.TSS = 0;                                    {\cf20 // start timer2}\par
00807         CpuTimer1Regs.TCR.bit.TSS = 0;                                    {\cf20 // start timer1}\par
00808 \par
00809         {\cf20 //}\par
00810         {\cf20 // Stop timers if either timer1 or timer2 counters overflow}\par
00811         {\cf20 //}\par
00812         {\cf19 while}((CpuTimer2Regs.TCR.bit.TIF == 0) && (CpuTimer1Regs.TCR.bit.TIF == 0));\par
00813 \par
00814         CpuTimer1Regs.TCR.bit.TSS = 1;                                    {\cf20 // stop timer1}\par
00815         CpuTimer2Regs.TCR.bit.TSS = 1;                                    {\cf20 // stop timer2}\par
00816 \par
00817         {\cf20 //}\par
00818         {\cf20 // Calculate elapsed counts on timer1}\par
00819         {\cf20 //}\par
00820         ctr1 = TMR1SYSCLKCTR - CpuTimer1Regs.TIM.all;\par
00821 \par
00822         {\cf20 //}\par
00823         {\cf20 // Restore timer settings}\par
00824         {\cf20 //}\par
00825         CpuTimer1Regs.TCR.all = t1TCR;\par
00826         CpuTimer1Regs.PRD.all = t1PRD;\par
00827         CpuTimer1Regs.TPR.all = t1TPR;\par
00828         CpuTimer1Regs.TPRH.all = t1TPRH;\par
00829         CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = t2SRC;\par
00830         CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = t2Prescale;\par
00831         CpuTimer2Regs.TCR.all = t2TCR;\par
00832         CpuTimer2Regs.PRD.all = t2PRD;\par
00833         CpuTimer2Regs.TPR.all = t2TPR;\par
00834         CpuTimer2Regs.TPRH.all = t2TPRH;\par
00835 \par
00836         {\cf20 //}\par
00837         {\cf20 // Calculate Clock Error:}\par
00838         {\cf20 // Error = (mult/div) - (timer1 count/timer2 count)}\par
00839         {\cf20 //}\par
00840         mult = (float)(imult) + (float)(fmult)/4;\par
00841         div = (float)((!ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV) ? 1 : (ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV << 1));\par
00842 \par
00843         sysclkToInClkError = (mult/div) - (({\cf18 float})ctr1/(float)TMR2INPCLKCTR);\par
00844 \par
00845         {\cf20 //}\par
00846         {\cf20 // sysclkInvalidFreq will be set to true if sysclkToInClkError is off by 10%}\par
00847         {\cf20 //}\par
00848         sysclkInvalidFreq = ((sysclkToInClkError > 0.10) || (sysclkToInClkError < -0.10));\par
00849     \}\par
00850 \par
00851     {\cf20 //}\par
00852     {\cf20 // Clear bit}\par
00853     {\cf20 //}\par
00854     DevCfgRegs.SYSDBGCTL.bit.BIT_0 = 0;\par
00855 \par
00856     {\cf20 //}\par
00857     {\cf20 // Restore user watchdog, first resetting counter}\par
00858     {\cf20 //}\par
00859     WdRegs.WDKEY.bit.WDKEY = 0x55;\par
00860     WdRegs.WDKEY.bit.WDKEY = 0xAA;\par
00861 \par
00862     WDCR |= 0x28;                     {\cf20 // Setup WD key--KEY bits always read 0}\par
00863     WdRegs.WDCR.all = WDCR;\par
00864     WdRegs.WDWCR.all = WDWCR;\par
00865     WdRegs.SCSR.all = SCSR & 0xFFFE;  {\cf20 // Mask write to bit 0 (W1toClr)}\par
00866 \par
00867     {\cf20 //}\par
00868     {\cf20 // Restore state of ST1[INTM]. This was set by the __disable_interrupts()}\par
00869     {\cf20 // intrinsic previously.}\par
00870     {\cf20 //}\par
00871     {\cf19 if}(!(intStatus & 0x1))\par
00872     \{\par
00873         EINT;\par
00874     \}\par
00875 \par
00876     {\cf20 //}\par
00877     {\cf20 // Restore state of ST1[DBGM]. This was set by the __disable_interrupts()}\par
00878     {\cf20 // intrinsic previously.}\par
00879     {\cf20 //}\par
00880     {\cf19 if}(!(intStatus & 0x2))\par
00881     \{\par
00882         {\cf17 asm}({\cf22 " CLRC DBGM"});\par
00883     \}\par
00884 \par
00885     {\cf20 //}\par
00886     {\cf20 // 200 PLLSYSCLK delay to allow voltage regulator to stabilize prior}\par
00887     {\cf20 // to increasing entire system clock frequency.}\par
00888     {\cf20 //}\par
00889     {\cf17 asm}({\cf22 " RPT #200 || NOP"});\par
00890 \par
00891     {\cf20 //}\par
00892     {\cf20 // Set the divider to user value}\par
00893     {\cf20 //}\par
00894     ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\par
00895 \par
00896     EDIS;\par
00897 \}\par
00898 {\cf21 #endif }{\cf20 // CPU1}\par
00899 \par
00900 {\cf20 //}\par
00901 {\cf20 // InitAuxPll - This function initializes the AUXPLL registers.}\par
00902 {\cf20 //}\par
00903 {\cf20 // Note: For this function to properly detect PLL startup,}\par
00904 {\cf20 // SYSCLK >= 2*AUXPLLCLK after the AUXPLL is selected as the clocking source.}\par
00905 {\cf20 //}\par
00906 {\cf20 // This function will use CPU Timer 2 to monitor a successful lock of the}\par
00907 {\cf20 // AUXPLL.}\par
00908 {\cf20 //}\par
00909 {\cf18 void} InitAuxPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\par
00910 \{\par
00911     Uint16 i;\par
00912     Uint16 counter = 0;\par
00913     Uint16 started = 0;\par
00914     Uint16 t2TCR, t2TPR, t2TPRH, t2SRC, t2Prescale, attempts;\par
00915     Uint32 t2PRD;\par
00916 \par
00917     {\cf19 if}((clock_source == ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL) &&\par
00918        (imult        == ClkCfgRegs.AUXPLLMULT.bit.IMULT)           &&\par
00919        (fmult        == ClkCfgRegs.AUXPLLMULT.bit.FMULT)           &&\par
00920        (divsel       == ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV))\par
00921     \{\par
00922         {\cf20 //}\par
00923         {\cf20 // Everything is set as required, so just return}\par
00924         {\cf20 //}\par
00925         {\cf19 return};\par
00926     \}\par
00927 \par
00928     {\cf19 switch} (clock_source)\par
00929     \{\par
00930         {\cf19 case} INT_OSC2:\par
00931             AuxIntOsc2Sel();\par
00932             {\cf19 break};\par
00933 \par
00934         {\cf19 case} XTAL_OSC:\par
00935             AuxXtalOscSel();\par
00936             {\cf19 break};\par
00937 \par
00938         {\cf19 case} AUXCLKIN:\par
00939             AuxAuxClkSel();\par
00940             {\cf19 break};\par
00941     \}\par
00942 \par
00943     EALLOW;\par
00944     ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 0;    {\cf20 // Bypass AUXPLL}\par
00945     EDIS;\par
00946 \par
00947     {\cf20 //}\par
00948     {\cf20 // Delay of at least 120 OSCCLK cycles required post PLL bypass}\par
00949     {\cf20 //}\par
00950     {\cf17 asm}({\cf22 " RPT #120 || NOP"});\par
00951 \par
00952     {\cf20 //}\par
00953     {\cf20 // Backup Timer 2 settings}\par
00954     {\cf20 //}\par
00955     t2SRC = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL;\par
00956     t2Prescale = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE;\par
00957     t2TCR = CpuTimer2Regs.TCR.all;\par
00958     t2PRD = CpuTimer2Regs.PRD.all;\par
00959     t2TPR = CpuTimer2Regs.TPR.all;\par
00960     t2TPRH = CpuTimer2Regs.TPRH.all;\par
00961 \par
00962     {\cf20 //}\par
00963     {\cf20 // Configure Timer 2 for AUXPLL as source in known configuration}\par
00964     {\cf20 //}\par
00965     EALLOW;\par
00966     CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x6;\par
00967     CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = 0x0;    {\cf20 // Divide by 1}\par
00968 \par
00969     CpuTimer2Regs.TCR.bit.TSS = 1;      {\cf20 // Stop timer}\par
00970     CpuTimer2Regs.PRD.all = 10;         {\cf20 // Small PRD value to detect overflow}\par
00971     CpuTimer2Regs.TPR.all = 0;\par
00972     CpuTimer2Regs.TPRH.all = 0;\par
00973     CpuTimer2Regs.TCR.bit.TIE = 0;      {\cf20 // Disable timer interrupts}\par
00974 \par
00975     {\cf20 //}\par
00976     {\cf20 // Set AUX Divide by 8 to ensure that AUXPLLCLK <= SYSCLK/2 while using}\par
00977     {\cf20 // Timer 2}\par
00978     {\cf20 //}\par
00979     ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV = 0x3;\par
00980     EDIS;\par
00981 \par
00982     {\cf19 while}((counter < 5) && (started == 0))\par
00983     \{\par
00984         EALLOW;\par
00985         ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 0;    {\cf20 // Turn off AUXPLL}\par
00986         {\cf17 asm}({\cf22 " RPT #20 || NOP"});                 {\cf20 // Small delay for power down}\par
00987 \par
00988         {\cf20 //}\par
00989         {\cf20 // Set integer and fractional multiplier, which automatically turns on}\par
00990         {\cf20 // the PLL}\par
00991         {\cf20 //}\par
00992         ClkCfgRegs.AUXPLLMULT.all = ((fmult << 8U) | imult);\par
00993 \par
00994         {\cf20 //}\par
00995         {\cf20 // Enable AUXPLL}\par
00996         {\cf20 //}\par
00997         ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 1;\par
00998         EDIS;\par
00999 \par
01000         {\cf20 //}\par
01001         {\cf20 // Wait for the AUXPLL lock counter}\par
01002         {\cf20 //}\par
01003         {\cf19 while}(ClkCfgRegs.AUXPLLSTS.bit.LOCKS != 1)\par
01004         \{\par
01005             {\cf20 //}\par
01006             {\cf20 // Uncomment to service the watchdog}\par
01007             {\cf20 //}\par
01008             {\cf20 // ServiceDog();}\par
01009         \}\par
01010 \par
01011         {\cf20 //}\par
01012         {\cf20 // Enable AUXPLLCLK to be fed from AUX PLL}\par
01013         {\cf20 //}\par
01014         EALLOW;\par
01015         ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 1;\par
01016         {\cf17 asm}({\cf22 " RPT #20 || NOP"});\par
01017 \par
01018         {\cf20 //}\par
01019         {\cf20 // CPU Timer 2 will now be setup to be clocked from AUXPLLCLK. This is}\par
01020         {\cf20 // used to test that the PLL has successfully started.}\par
01021         {\cf20 //}\par
01022         CpuTimer2Regs.TCR.bit.TRB = 1;      {\cf20 // Reload period value}\par
01023         CpuTimer2Regs.TCR.bit.TSS = 0;      {\cf20 // Start Timer}\par
01024 \par
01025         {\cf20 //}\par
01026         {\cf20 // Check to see timer is counting properly}\par
01027         {\cf20 //}\par
01028         {\cf19 for}(i = 0; i < 1000; i++)\par
01029         \{\par
01030             {\cf20 //}\par
01031             {\cf20 // Check overflow flag}\par
01032             {\cf20 //}\par
01033             {\cf19 if}(CpuTimer2Regs.TCR.bit.TIF)\par
01034             \{\par
01035                 {\cf20 //}\par
01036                 {\cf20 // Clear overflow flag}\par
01037                 {\cf20 //}\par
01038                 CpuTimer2Regs.TCR.bit.TIF = 1;\par
01039 \par
01040                 {\cf20 //}\par
01041                 {\cf20 // Set flag to indicate PLL started and break out of for-loop}\par
01042                 {\cf20 //}\par
01043                 started = 1;\par
01044                 {\cf19 break};\par
01045             \}\par
01046         \}\par
01047 \par
01048         {\cf20 //}\par
01049         {\cf20 // Stop timer}\par
01050         {\cf20 //}\par
01051         CpuTimer2Regs.TCR.bit.TSS = 1;\par
01052         counter++;\par
01053         EDIS;\par
01054     \}\par
01055 \par
01056     {\cf19 if}(started == 0)\par
01057     \{\par
01058         {\cf20 //}\par
01059         {\cf20 // AUX PLL may not have started. Reset multiplier to 0 (bypass PLL).}\par
01060         {\cf20 //}\par
01061         EALLOW;\par
01062         ClkCfgRegs.AUXPLLMULT.all = 0;\par
01063         EDIS;\par
01064 \par
01065         {\cf20 //}\par
01066         {\cf20 // The user should put some handler code here based on how this}\par
01067         {\cf20 // condition should be handled in their application.}\par
01068         {\cf20 //}\par
01069         {\cf17 asm}({\cf22 " ESTOP0"});\par
01070     \}\par
01071 \par
01072     {\cf20 //}\par
01073     {\cf20 // Slip Bit Monitor}\par
01074     {\cf20 // Re-lock routine for SLIP condition}\par
01075     {\cf20 //}\par
01076     attempts = 0;\par
01077     {\cf19 while}(ClkCfgRegs.AUXPLLSTS.bit.SLIPS && (attempts < 10))\par
01078     \{\par
01079         EALLOW;\par
01080         {\cf20 //}\par
01081         {\cf20 // Bypass AUXPLL}\par
01082         {\cf20 //}\par
01083         ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 0;\par
01084 \par
01085         {\cf20 //}\par
01086         {\cf20 // Delay of at least 120 OSCCLK cycles required post PLL bypass}\par
01087         {\cf20 //}\par
01088         {\cf17 asm}({\cf22 " RPT #120 || NOP"});\par
01089 \par
01090         {\cf20 //}\par
01091         {\cf20 // Turn off AUXPLL}\par
01092         {\cf20 //}\par
01093         ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 0;\par
01094         {\cf17 asm}({\cf22 " RPT #20 || NOP"});\par
01095 \par
01096         {\cf20 //}\par
01097         {\cf20 // Set integer and fractional multiplier, which automatically turns}\par
01098         {\cf20 // on the PLL}\par
01099         {\cf20 //}\par
01100         ClkCfgRegs.AUXPLLMULT.all = ((fmult << 8U) | imult);\par
01101 \par
01102         {\cf20 //}\par
01103         {\cf20 // Wait for the AUXPLL lock counter}\par
01104         {\cf20 //}\par
01105         {\cf19 while}(ClkCfgRegs.AUXPLLSTS.bit.LOCKS != 1);\par
01106 \par
01107         {\cf20 //}\par
01108         {\cf20 // Enable AUXPLLCLK to be fed from AUXPLL}\par
01109         {\cf20 //}\par
01110         ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 1;\par
01111         {\cf17 asm}({\cf22 " RPT #20 || NOP"});\par
01112 \par
01113         attempts++;\par
01114         EDIS;\par
01115     \}\par
01116 \par
01117     {\cf20 //}\par
01118     {\cf20 // Set divider to desired value}\par
01119     {\cf20 //}\par
01120     EALLOW;\par
01121     ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV = divsel;\par
01122 \par
01123     {\cf20 //}\par
01124     {\cf20 // Restore Timer 2 configuration}\par
01125     {\cf20 //}\par
01126     CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = t2SRC;\par
01127     CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = t2Prescale;\par
01128     CpuTimer2Regs.TCR.all = t2TCR;\par
01129     CpuTimer2Regs.PRD.all = t2PRD;\par
01130     CpuTimer2Regs.TPR.all = t2TPR;\par
01131     CpuTimer2Regs.TPRH.all = t2TPRH;\par
01132 \par
01133     {\cf20 //}\par
01134     {\cf20 // Reload period value}\par
01135     {\cf20 //}\par
01136     CpuTimer2Regs.TCR.bit.TRB = 1;\par
01137     EDIS;\par
01138 \}\par
01139 \par
01140 {\cf20 //}\par
01141 {\cf20 // CsmUnlock - This function unlocks the CSM. User must replace 0xFFFF's with}\par
01142 {\cf20 //             current password for the DSP. Returns 1 if unlock is successful.}\par
01143 {\cf20 //}\par
01144 Uint16 CsmUnlock({\cf18 void})\par
01145 \{\par
01146     {\cf17 volatile} Uint16 temp;\par
01147 \par
01148     {\cf20 //}\par
01149     {\cf20 // Load the key registers with the current password. The 0xFFFF's are dummy}\par
01150     {\cf20 // passwords.  User should replace them with the correct password for the}\par
01151     {\cf20 // DSP.}\par
01152     {\cf20 //}\par
01153     EALLOW;\par
01154     DcsmZ1Regs.Z1_CSMKEY0 = 0xFFFFFFFF;\par
01155     DcsmZ1Regs.Z1_CSMKEY1 = 0xFFFFFFFF;\par
01156     DcsmZ1Regs.Z1_CSMKEY2 = 0xFFFFFFFF;\par
01157     DcsmZ1Regs.Z1_CSMKEY3 = 0xFFFFFFFF;\par
01158 \par
01159     DcsmZ2Regs.Z2_CSMKEY0 = 0xFFFFFFFF;\par
01160     DcsmZ2Regs.Z2_CSMKEY1 = 0xFFFFFFFF;\par
01161     DcsmZ2Regs.Z2_CSMKEY2 = 0xFFFFFFFF;\par
01162     DcsmZ2Regs.Z2_CSMKEY3 = 0xFFFFFFFF;\par
01163     EDIS;\par
01164 \par
01165     {\cf19 return}(0);\par
01166 \}\par
01167 \par
01168 {\cf20 //}\par
01169 {\cf20 // SysIntOsc1Sel - This function switches to Internal Oscillator 1.}\par
01170 {\cf20 //}\par
01171 {\cf18 void} SysIntOsc1Sel({\cf18 void})\par
01172 \{\par
01173     EALLOW;\par
01174     ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 2;     {\cf20 // Clk Src = INTOSC1}\par
01175     SYSCTRL_CLKSRCCTL1_DELAY;\par
01176     ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=1;            {\cf20 // Turn off XTALOSC}\par
01177     EDIS;\par
01178 \}\par
01179 \par
01180 {\cf20 //}\par
01181 {\cf20 // SysIntOsc2Sel - This function switches to Internal oscillator 2.}\par
01182 {\cf20 //}\par
01183 {\cf18 void} SysIntOsc2Sel({\cf18 void})\par
01184 \{\par
01185     EALLOW;\par
01186     ClkCfgRegs.CLKSRCCTL1.bit.INTOSC2OFF=0;         {\cf20 // Turn on INTOSC2}\par
01187     SYSCTRL_CLKSRCCTL1_DELAY;\par
01188     ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 0;     {\cf20 // Clk Src = INTOSC2}\par
01189     SYSCTRL_CLKSRCCTL1_DELAY;\par
01190     ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=1;            {\cf20 // Turn off XTALOSC}\par
01191     EDIS;\par
01192 \}\par
01193 \par
01194 {\cf20 //}\par
01195 {\cf20 // SysXtalOscSel - This function switches to External CRYSTAL oscillator.}\par
01196 {\cf20 //}\par
01197 {\cf18 void} SysXtalOscSel({\cf18 void})\par
01198 \{\par
01199     EALLOW;\par
01200     ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=0;            {\cf20 // Turn on XTALOSC}\par
01201     SYSCTRL_CLKSRCCTL1_DELAY;\par
01202     ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 1;     {\cf20 // Clk Src = XTAL}\par
01203     EDIS;\par
01204 \}\par
01205 \par
01206 {\cf20 //}\par
01207 {\cf20 // AuxIntOsc2Sel - This function switches to Internal oscillator 2.}\par
01208 {\cf20 //}\par
01209 {\cf18 void} AuxIntOsc2Sel({\cf18 void})\par
01210 \{\par
01211     EALLOW;\par
01212     ClkCfgRegs.CLKSRCCTL1.bit.INTOSC2OFF=0;         {\cf20 // Turn on INTOSC2}\par
01213     ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 0;  {\cf20 // Clk Src = INTOSC2}\par
01214     EDIS;\par
01215 \}\par
01216 \par
01217 {\cf20 //}\par
01218 {\cf20 // AuxXtalOscSel - This function switches to External CRYSTAL oscillator.}\par
01219 {\cf20 //}\par
01220 {\cf18 void} AuxXtalOscSel({\cf18 void})\par
01221 \{\par
01222     EALLOW;\par
01223     ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=0;            {\cf20 // Turn on XTALOSC}\par
01224     ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 1;  {\cf20 // Clk Src = XTAL}\par
01225     EDIS;\par
01226 \}\par
01227 \par
01228 {\cf20 //}\par
01229 {\cf20 // AuxAUXCLKOscSel - This function switches to AUXCLKIN (from a GPIO).}\par
01230 {\cf20 //}\par
01231 {\cf18 void} AuxAuxClkSel({\cf18 void})\par
01232 \{\par
01233     EALLOW;\par
01234     ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 2; {\cf20 // Clk Src = XTAL}\par
01235     EDIS;\par
01236 \}\par
01237 \par
01238 {\cf20 //}\par
01239 {\cf20 // IDLE - Enter IDLE mode (single CPU).}\par
01240 {\cf20 //}\par
01241 {\cf18 void} IDLE({\cf18 void})\par
01242 \{\par
01243     EALLOW;\par
01244     CpuSysRegs.LPMCR.bit.LPM = LPM_IDLE;\par
01245     EDIS;\par
01246     {\cf17 asm}({\cf22 " IDLE"});\par
01247 \}\par
01248 \par
01249 {\cf20 //}\par
01250 {\cf20 // STANDBY - Enter STANDBY mode (single CPU).}\par
01251 {\cf20 //}\par
01252 {\cf18 void} STANDBY({\cf18 void})\par
01253 \{\par
01254     EALLOW;\par
01255     CpuSysRegs.LPMCR.bit.LPM = LPM_STANDBY;\par
01256     EDIS;\par
01257     {\cf17 asm}({\cf22 " IDLE"});\par
01258 \}\par
01259 \par
01260 {\cf20 //}\par
01261 {\cf20 // HALT - Enter HALT mode (dual CPU). Puts CPU2 in IDLE mode first.}\par
01262 {\cf20 //}\par
01263 {\cf18 void} HALT({\cf18 void})\par
01264 \{\par
01265 {\cf21 #if defined(CPU2)}\par
01266     IDLE();\par
01267 {\cf21 #elif defined(CPU1)}\par
01268     EALLOW;\par
01269     CpuSysRegs.LPMCR.bit.LPM = LPM_HALT;\par
01270     EDIS;\par
01271 \par
01272     {\cf19 while}(DevCfgRegs.LPMSTAT.bit.CPU2LPMSTAT != 0x1);\par
01273 \par
01274     EALLOW;\par
01275     ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\par
01276     ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\par
01277     EDIS;\par
01278     {\cf17 asm}({\cf22 " IDLE"});\par
01279 {\cf21 #endif}\par
01280 \}\par
01281 \par
01282 {\cf20 //}\par
01283 {\cf20 // HIB - Enter HIB mode (dual CPU). Puts CPU2 in STANDBY first. Alternately,}\par
01284 {\cf20 //       CPU2 may be in reset.}\par
01285 {\cf18 void} HIB({\cf18 void})\par
01286 \{\par
01287 {\cf21 #if defined(CPU2)}\par
01288     STANDBY();\par
01289 {\cf21 #elif defined(CPU1)}\par
01290     EALLOW;\par
01291     CpuSysRegs.LPMCR.bit.LPM = LPM_HIB;\par
01292     EDIS;\par
01293 \par
01294     {\cf19 while}((DevCfgRegs.LPMSTAT.bit.CPU2LPMSTAT == 0x0) &&\par
01295           (DevCfgRegs.RSTSTAT.bit.CPU2RES == 1));\par
01296 \par
01297     DisablePeripheralClocks();\par
01298     EALLOW;\par
01299     ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\par
01300     ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\par
01301     EDIS;\par
01302     {\cf17 asm}({\cf22 " IDLE"});\par
01303 {\cf21 #endif}\par
01304 \}\par
01305 \par
01306 {\cf21 #ifdef CPU1}\par
01307 {\cf20 //}\par
01308 {\cf20 // Function to implement Analog trim of TMX devices. This function should be}\par
01309 {\cf20 // called post enabling the EALLOW protected writes.}\par
01310 {\cf20 //}\par
01311 {\cf18 void} ConfigureTMXAnalogTrim({\cf18 void})\par
01312 \{\par
01313     {\cf20 //}\par
01314     {\cf20 // Enable ADC clock}\par
01315     {\cf20 //}\par
01316     CpuSysRegs.PCLKCR13.bit.ADC_A = 1;\par
01317     CpuSysRegs.PCLKCR13.bit.ADC_B = 1;\par
01318     CpuSysRegs.PCLKCR13.bit.ADC_C = 1;\par
01319     CpuSysRegs.PCLKCR13.bit.ADC_D = 1;\par
01320 \par
01321 \par
01322     {\cf20 //}\par
01323     {\cf20 // Device is not trimmed--apply static calibration values}\par
01324     {\cf20 //}\par
01325     AnalogSubsysRegs.ANAREFTRIMA.all = 0x7BDD;\par
01326     AnalogSubsysRegs.ANAREFTRIMB.all = 0x7BDD;\par
01327     AnalogSubsysRegs.ANAREFTRIMC.all = 0x7BDD;\par
01328     AnalogSubsysRegs.ANAREFTRIMD.all = 0x7BDD;\par
01329 \par
01330     {\cf20 //}\par
01331     {\cf20 // Configure ADC offset trim. The user should generate the trim values}\par
01332     {\cf20 // by following the instructions in the "ADC Zero Offset Calibration"}\par
01333     {\cf20 // section in device TRM. The below lines needs to be uncommented and}\par
01334     {\cf20 // updated with the correct trim values.}\par
01335     {\cf20 //}\par
01336 {\cf20 //    AdcaRegs.ADCOFFTRIM.all = 0x0;}\par
01337 {\cf20 //    AdcbRegs.ADCOFFTRIM.all = 0x0;}\par
01338 {\cf20 //    AdccRegs.ADCOFFTRIM.all = 0x0;}\par
01339 {\cf20 //    AdcdRegs.ADCOFFTRIM.all = 0x0;}\par
01340 \par
01341     {\cf20 //}\par
01342     {\cf20 // Configure internal oscillator trim. If the internal oscillator trim}\par
01343     {\cf20 // contains all zeros, the user can adjust the lowest 10 bits of the}\par
01344     {\cf20 // oscillator trim register between 1 (minimum) and 1023 (maximum)}\par
01345     {\cf20 // while observing the system clock on the XCLOCKOUT pin. The below}\par
01346     {\cf20 // lines needs to be uncommented and updated with the correct trim values.}\par
01347     {\cf20 //}\par
01348 {\cf20 //    if(AnalogSubsysRegs.INTOSC1TRIM.all == 0x0)}\par
01349 {\cf20 //    \{}\par
01350 {\cf20 //        AnalogSubsysRegs.INTOSC1TRIM.all = 0x0;}\par
01351 {\cf20 //    \}}\par
01352 {\cf20 //}\par
01353 {\cf20 //    if(AnalogSubsysRegs.INTOSC2TRIM.all == 0x0)}\par
01354 {\cf20 //    \{}\par
01355 {\cf20 //        AnalogSubsysRegs.INTOSC2TRIM.all = 0x0;}\par
01356 {\cf20 //    \}}\par
01357 \par
01358     {\cf20 //}\par
01359     {\cf20 // Disable ADC clock}\par
01360     {\cf20 //}\par
01361     CpuSysRegs.PCLKCR13.bit.ADC_A = 0;\par
01362     CpuSysRegs.PCLKCR13.bit.ADC_B = 0;\par
01363     CpuSysRegs.PCLKCR13.bit.ADC_C = 0;\par
01364     CpuSysRegs.PCLKCR13.bit.ADC_D = 0;\par
01365 \}\par
01366 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fpu_rfft.h File Reference\par \pard\plain 
{\tc\tcl2 \v fpu_rfft.h}
{\xe \v fpu_rfft.h}
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "fpu_types.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RFFT_F32_STRUCT}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RFFT_ADC_F32_STRUCT}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for the Real FFT with ADC input. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b RFFT_F32_STRUCT} * {\b RFFT_F32_STRUCT_Handle}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle to the Real FFT object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b RFFT_ADC_F32_STRUCT} * {\b RFFT_ADC_F32_STRUCT_Handle}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle to the Real FFT (with ADC input) structure. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_f32} ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real Fast Fourier Transform (RFFT). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_f32u} ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT (Unaligned). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_adc_f32} ({\b RFFT_ADC_F32_STRUCT_Handle} hndRFFT_ADC_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT with ADC Input. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_adc_f32u} ({\b RFFT_ADC_F32_STRUCT_Handle} hndRFFT_ADC_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT with ADC Input (Unaligned). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_f32_win} (float *pBuffer, const float *pWindow, const uint16_t size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windowing function for the 32-bit real FFT. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_adc_f32_win} (uint16_t *pBuffer, const uint16_t *pWindow, const uint16_t size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windowing function for the 32-bit real FFT with ADC Input. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_f32_mag} ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT Magnitude. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_f32s_mag} ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT Magnitude (Scaled). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_f32_phase} ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT Phase. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RFFT_f32_sincostable} ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate twiddle factors for the Real FFT. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RFFT_f32_twiddleFactors} [1020]\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Twiddle Factor Table for a 2048-pt (max) Real FFT. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b FPU32RFFTtwiddleFactors} [1020]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v RFFT_ADC_F32_STRUCT_Handle\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_ADC_F32_STRUCT_Handle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b RFFT_ADC_F32_STRUCT}* {\b RFFT_ADC_F32_STRUCT_Handle}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle to the Real FFT (with ADC input) structure. }}\par
{
Definition at line {\b 99} of file {\b fpu_rfft.h}.}\par
}
{\xe \v RFFT_F32_STRUCT_Handle\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_F32_STRUCT_Handle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b RFFT_F32_STRUCT}* {\b RFFT_F32_STRUCT_Handle}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle to the Real FFT object. }}\par
{
Definition at line {\b 88} of file {\b fpu_rfft.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v RFFT_adc_f32\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_adc_f32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_adc_f32 ({\b RFFT_ADC_F32_STRUCT_Handle} hndRFFT_ADC_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT with ADC Input. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This routine computes the 32-bit single precision FFT for an N-pt ( { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}) real 12-bit ADC input. This function reorders the input in bit-reversed format as part of the stage 1,2 and 3 computations. The routine uses two buffers in ping-pong fashion i.e. after each FFT stage the output and input buffers become the input and output buffers respectively for the next stage. This algorithm only allocates memory, and performs computation, for the non-zero elements of the input (the real part). The complex conjugate nature of the spectrum (for real only data) affords savings in space and computaion, therefore the algorithm only calculates the spectrum from the 0th bin to the nyquist bin (included).\par
Another approach to calculate the real FFT would be to treat the real N-point data as N/2 complex, run the forward complex N/2 point FFT followed by an "unpack" function\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_ADC_F32} \cell }{Pointer to the RFFT_ADC F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The routine requires the use of two buffers, the input of size 2N and type uint16_t, the output of size N and type float, for computation; the input buffer must be aligned to a memory address of N words (16-bit). Refer to the RFFT linker command file to see an example of this.\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab If alignment is not possible the user can use the alternative, albeit slower, function RFFT_adc_f32u\par}
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{1295 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{2769 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{6059 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{13360 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{29466 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_adc_f32_win\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_adc_f32_win}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_adc_f32_win (uint16_t * pBuffer, const uint16_t * pWindow, const uint16_t size){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windowing function for the 32-bit real FFT with ADC Input. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pBuffer} \cell }{pointer to the uint16_t buffer that needs to be windowed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pWindow} \cell }{pointer to the float windowing table \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{size of the buffer This function applies the window to a 2N point real data buffer that has not been reordered in the bit-reversed format \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The routine requires the window to be unsigned int (16-bit). The user must take the desired floating point window from the header files (e.g. HANN1024 from fpu32/fpu_fft_hann.h)and convert it to Q16 by multiplying by 2^16 and then flooring the value before converting it to uint16_t\par}
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{346 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{666 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{1306 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{2586 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{5146 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_adc_f32u\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_adc_f32u}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_adc_f32u ({\b RFFT_ADC_F32_STRUCT_Handle} hndRFFT_ADC_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT with ADC Input (Unaligned). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This routine computes the 64-bit double precision FFT for an N-pt ( { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}) real 12-bit ADC input. This function reorders the input in bit-reversed format as part of the stage 1,2 and 3 computations. The routine uses two buffers in ping-pong fashion i.e. after each FFT stage the output and input buffers become the input and output buffers respectively for the next stage. This algorithm only allocates memory, and performs computation, for the non-zero elements of the input (the real part). The complex conjugate nature of the spectrum (for real only data) affords savings in space and computaion, therefore the algorithm only calculates the spectrum from the 0th bin to the nyquist bin (included).\par
Another approach to calculate the real FFT would be to treat the real N-point data as N/2 complex, run the forward complex N/2 point FFT followed by an "unpack" function\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_ADC_F32} \cell }{Pointer to the RFFT_ADC F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The routine requires the use of two buffers, the input of size 2N and type uint16_t, the output of size N and type float, for computation; the input buffer need not be aligned to any boundary.\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab If alignment is possible it is recommended to use the faster function RFFT_adc_f32\par}
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{1415 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{3009 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{6539 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{14320 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{31386 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_f32\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_f32 ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real Fast Fourier Transform (RFFT). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This routine computes the 32-bit floating-point FFT for an N-pt ( { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}) This routine computes the 32-bit single precision FFT for an N-pt ( { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}) real input. This function reorders the input in bit-reversed format as part of the stage 1,2 and 3 computations. The routine uses two buffers in ping-pong fashion i.e. after each FFT stage the output and input buffers become the input and output buffers respectively for the next stage. This algorithm only allocates memory, and performs computation, for the non-zero elements of the input (the real part). The complex conjugate nature of the spectrum (for real only data) affords savings in space and computaion, therefore the algorithm only calculates the spectrum from the 0th bin to the nyquist bin (included).\par
Another approach to calculate the real FFT would be to treat the real N-point data as N/2 complex, run the forward complex N/2 point FFT followed by an "unpack" function\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_F32} \cell }{Pointer to the RFFT_F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The routine requires the use of two buffers, each of size N (32-bit float), for computation; the input buffer must be aligned to a memory address of 2N words (16-bit). Refer to the RFFT linker command file to see an example of this.\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab If alignment is not possible the user can use the alternative, albeit slower, function RFFT_f32u \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
SSEC_RFFT_F32_USING_CFFT_F32\par
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{1281 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{2779 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{6149 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{13674 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{30356 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_f32_mag\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32_mag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_f32_mag ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT Magnitude. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This module computes the real FFT magnitude. The output from RFFT_f32_mag matches the magnitude output from the FFT found in common mathematics software and Code Composer Studio FFT graphs. If instead a normalized magnitude like that performed by the fixed-point TMS320C28x IQmath FFT library is required, then the RFFT_f32s_mag function can be used. In fixed-point algorithms scaling is performed to avoid overflowing data. Floating-point calculations do not need this scaling to avoid overflow and therefore the RFFT_f32_mag function can be used instead. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_F32} \cell }{Pointer to the RFFT_F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The Magnitude buffer does not require memory alignment to a boundary\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab For C28x devices that have the TMU0 (or higher) module, use RFFT_f32_mag_TMU0() instead for better performance.\par}
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{635 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{1243 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{2459 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{4888 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{9752 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_f32_phase\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32_phase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_f32_phase ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT Phase. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_F32} \cell }{Pointer to the RFFT_F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The Phase buffer does not require memory alignment to a boundary\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab For C28x devices that have the TMU0 (or higher) module, use RFFT_f32_phase_TMU0() instead for better performance.\par}
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{1949 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{3933 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{7901 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{16835 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{31707 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_f32_sincostable\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32_sincostable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_f32_sincostable ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate twiddle factors for the Real FFT. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_F32} \cell }{Pointer to the RFFT_F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function is written in C and compiled without optimization turned on. \par
}}}}
{\xe \v RFFT_f32_win\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32_win}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_f32_win (float * pBuffer, const float * pWindow, const uint16_t size){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Windowing function for the 32-bit real FFT. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pBuffer} \cell }{pointer to the buffer that needs to be windowed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pWindow} \cell }{pointer to the windowing table \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{size of the buffer This function applies the window to a 2N point real data buffer that has not been reordered in the bit-reversed format\cell }
{\row }
}
\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{308 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{596 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{1172 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{2324 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{4628 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_f32s_mag\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32s_mag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_f32s_mag ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT Magnitude (Scaled). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This module computes the scaled real FFT magnitude. The scaling is { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_1.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, and is done to match the normalization performed by the fixed-point TMS320C28x IQmath FFT library for overflow avoidance. Floating-point calculations do not need this scaling to avoid overflow and therefore the RFFT_f32_mag function can be used instead. The output from RFFT_f32s_mag matches the magnitude output from the FFT found in common mathematics software and Code Composer Studio FFT graphs. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_F32} \cell }{Pointer to the RFFT_F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The Magnitude buffer does not require memory alignment to a boundary\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab For C28x devices that have the TMU0 (or higher) module, use RFFT_f32s_mag_TMU0() instead for better performance.\par}
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{723 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{1336 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{2557 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{4990 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{9859 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\xe \v RFFT_f32u\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32u}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RFFT_f32u ({\b RFFT_F32_STRUCT_Handle} hndRFFT_F32){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Real FFT (Unaligned). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This routine computes the 32-bit single precision FFT for an N-pt ( { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}) real input. This function reorders the input in bit-reversed format as part of the stage 1,2 and 3 computations. The routine uses two buffers in ping-pong fashion i.e. after each FFT stage the output and input buffers become the input and output buffers respectively for the next stage. This algorithm only allocates memory, and performs computation, for the non-zero elements of the input (the real part). The complex conjugate nature of the spectrum (for real only data) affords savings in space and computaion, therefore the algorithm only calculates the spectrum from the 0th bin to the nyquist bin (included).\par
Another approach to calculate the real FFT would be to treat the real N-point data as N/2 complex, run the forward complex N/2 point FFT followed by an "unpack" function\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hndRFFT_F32} \cell }{Pointer to the RFFT_F32 object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Attention\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab The routine requires the use of two buffers, each of size N (32-bit float), for computation; the input buffer need not be aligned to a boundary\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab If alignment is possible it is recommended to use the faster routine, RFFT_f32 \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
SSEC_RFFT_F32_USING_CFFT_F32\par
}}\pard \qc \b{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{Table \field\flddirty{\*\fldinst { SEQ Table \\*Arabic }}{\fldrslt {\noproof 1}} Performance Data}
\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Samples \cell }{Cycles \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{64 \cell }{1393 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128 \cell }{3003 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{256 \cell }{6597 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{512 \cell }{14570 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{1024 \cell }{32148 \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v FPU32RFFTtwiddleFactors\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:FPU32RFFTtwiddleFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float FPU32RFFTtwiddleFactors[1020]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RFFT_f32_twiddleFactors\:fpu_rfft.h}
{\xe \v fpu_rfft.h\:RFFT_f32_twiddleFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RFFT_f32_twiddleFactors[1020]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Twiddle Factor Table for a 2048-pt (max) Real FFT. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note:{
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab RFFT_f32_twiddleFactors name is deprecated and only supported for legacy reasons. Users are encouraged to use FPU32RFFTtwiddleFactors as the table symbol.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab The RFFT_f32_twiddleFactors is an alias for the new table. It is not a separate table. \par}
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fpu_rfft.h\par \pard\plain 
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef _FPU_RFFT_H_}\par
00002 {\cf21 #define _FPU_RFFT_H_}\par
00003 {\cf20 //#############################################################################}\par
00007 {\cf20 //#############################################################################}\par
00052 {\cf20 //#############################################################################}\par
00053 \par
00054 \par
00055 {\cf20 //*****************************************************************************}\par
00056 {\cf20 // includes}\par
00057 {\cf20 //*****************************************************************************}\par
00058 {\cf21 #include "fpu_types.h"}\par
00059 \par
00062 \par
00065 {\cf20 // @\{}\par
00066     \par
00067 {\cf21 #ifdef __cplusplus}\par
00068 {\cf17 extern} {\cf22 "C"} \{\par
00069 {\cf21 #endif}\par
00070 {\cf20 //*****************************************************************************}\par
00071 {\cf20 // typedefs}\par
00072 {\cf20 //*****************************************************************************}\par
00073 \par
00076 {\cf17 typedef} {\cf17 struct }\{\par
00077   {\cf18 float}  *InBuf;        \par
00078   {\cf18 float}  *OutBuf;       \par
00079   {\cf18 float}  *CosSinBuf;    \par
00080   {\cf18 float}  *MagBuf;       \par
00081   {\cf18 float}  *PhaseBuf;     \par
00082   uint16_t   FFTSize;   \par
00083   uint16_t   FFTStages; \par
00084 \} RFFT_F32_STRUCT;\par
00085 \par
00088 {\cf17 typedef} RFFT_F32_STRUCT* RFFT_F32_STRUCT_Handle;\par
00089 \par
00092 {\cf17 typedef} {\cf17 struct }\{\par
00093   uint16_t   *InBuf;    \par
00094   {\cf18 void}       *Tail;     \par
00095 \} RFFT_ADC_F32_STRUCT;\par
00096 \par
00099 {\cf17 typedef} RFFT_ADC_F32_STRUCT* RFFT_ADC_F32_STRUCT_Handle;\par
00100 \par
00101 {\cf20 //*****************************************************************************}\par
00102 {\cf20 // globals}\par
00103 {\cf20 //*****************************************************************************}\par
00104 {\cf20 //}\par
00113 {\cf20 //}\par
00114 {\cf20 //*****************************************************************************}\par
00115 {\cf17 extern} {\cf18 float} RFFT_f32_twiddleFactors[1020];\par
00116 {\cf17 extern} {\cf18 float} FPU32RFFTtwiddleFactors[1020];\par
00117 \par
00118 {\cf20 //*****************************************************************************}\par
00119 {\cf20 // 'inline' function}\par
00120 {\cf20 //*****************************************************************************}\par
00121 \par
00126 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_f32_setInputPtr(RFFT_F32_STRUCT_Handle fh,\par
00127         {\cf17 const} {\cf18 float} *pi)\par
00128 \{\par
00129     fh->InBuf = ({\cf18 float} *)pi;\par
00130 \}\par
00131 \par
00136 {\cf17 static} {\cf17 inline} {\cf18 float} * RFFT_f32_getInputPtr(RFFT_F32_STRUCT_Handle fh)\par
00137 \{\par
00138     {\cf19 return}(fh->InBuf);\par
00139 \}\par
00140 \par
00145 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_f32_setOutputPtr(RFFT_F32_STRUCT_Handle fh,\par
00146         {\cf17 const} {\cf18 float} *po)\par
00147 \{\par
00148     fh->OutBuf= ({\cf18 float} *)po;\par
00149 \}\par
00150 \par
00155 {\cf17 static} {\cf17 inline} {\cf18 float} * RFFT_f32_getOutputPtr(RFFT_F32_STRUCT_Handle fh)\par
00156 \{\par
00157     {\cf19 return}(fh->OutBuf);\par
00158 \}\par
00159 \par
00164 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_f32_setTwiddlesPtr(RFFT_F32_STRUCT_Handle fh,\par
00165         {\cf17 const} {\cf18 float} *pc)\par
00166 \{\par
00167     fh->CosSinBuf = ({\cf18 float} *)pc;\par
00168 \}\par
00169 \par
00174 {\cf17 static} {\cf17 inline} {\cf18 float} * RFFT_f32_getTwiddlesPtr(RFFT_F32_STRUCT_Handle fh)\par
00175 \{\par
00176     {\cf19 return}(fh->CosSinBuf);\par
00177 \}\par
00178 \par
00183 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_f32_setMagnitudePtr(RFFT_F32_STRUCT_Handle fh,\par
00184         {\cf17 const} {\cf18 float} *pm)\par
00185 \{\par
00186     fh->MagBuf = ({\cf18 float} *)pm;\par
00187 \}\par
00188 \par
00189 \par
00194 {\cf17 static} {\cf17 inline} {\cf18 float} * RFFT_f32_getMagnitudePtr(RFFT_F32_STRUCT_Handle fh)\par
00195 \{\par
00196     {\cf19 return}(fh->MagBuf);\par
00197 \}\par
00198 \par
00203 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_f32_setPhasePtr(RFFT_F32_STRUCT_Handle fh,\par
00204         {\cf17 const} {\cf18 float} *pp)\par
00205 \{\par
00206     fh->PhaseBuf = ({\cf18 float} *)pp;\par
00207 \}\par
00208 \par
00209 \par
00214 {\cf17 static} {\cf17 inline} {\cf18 float} * RFFT_f32_getPhasePtr(RFFT_F32_STRUCT_Handle fh)\par
00215 \{\par
00216     {\cf19 return}(fh->PhaseBuf);\par
00217 \}\par
00218 \par
00223 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_f32_setStages(RFFT_F32_STRUCT_Handle fh,\par
00224                       {\cf17 const} uint16_t st)\par
00225 \{\par
00226     fh->FFTStages = st;\par
00227 \}\par
00228 \par
00233 {\cf17 static} {\cf17 inline} uint16_t RFFT_f32_getStages(RFFT_F32_STRUCT_Handle fh)\par
00234 \{\par
00235     {\cf19 return}(fh->FFTStages);\par
00236 \}\par
00237 \par
00242 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_f32_setFFTSize(RFFT_F32_STRUCT_Handle fh,\par
00243                       {\cf17 const} uint16_t sz)\par
00244 \{\par
00245     fh->FFTSize = sz;\par
00246 \}\par
00247 \par
00252 {\cf17 static} {\cf17 inline} uint16_t RFFT_f32_getFFTSize(RFFT_F32_STRUCT_Handle fh)\par
00253 \{\par
00254     {\cf19 return}(fh->FFTSize);\par
00255 \}\par
00256 \par
00261 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_ADC_f32_setInBufPtr(RFFT_ADC_F32_STRUCT_Handle fh,\par
00262                       {\cf17 const} uint16_t * pi)\par
00263 \{\par
00264     fh->InBuf = (uint16_t *)pi;\par
00265 \}\par
00266 \par
00271 {\cf17 static} {\cf17 inline} uint16_t *RFFT_ADC_f32_getInBufPtr(RFFT_ADC_F32_STRUCT_Handle fh)\par
00272 \{\par
00273     {\cf19 return}(fh->InBuf);\par
00274 \}\par
00275 \par
00280 {\cf17 static} {\cf17 inline} {\cf18 void} RFFT_ADC_f32_setTailPtr(RFFT_ADC_F32_STRUCT_Handle fh,\par
00281                       {\cf17 const} {\cf18 void} * pt)\par
00282 \{\par
00283     fh->Tail = ({\cf18 void} *)pt;\par
00284 \}\par
00285 \par
00290 {\cf17 static} {\cf17 inline} {\cf18 void} *RFFT_ADC_f32_getTailPtr(RFFT_ADC_F32_STRUCT_Handle fh)\par
00291 \{\par
00292     {\cf19 return}(fh->Tail);\par
00293 \}\par
00294 \par
00295 {\cf20 //*****************************************************************************}\par
00296 {\cf20 // function prototypes}\par
00297 {\cf20 //*****************************************************************************}\par
00337 {\cf20 //}\par
00338 {\cf17 extern} {\cf18 void} RFFT_f32(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00339 \par
00375 {\cf20 //}\par
00376 {\cf17 extern} {\cf18 void} RFFT_f32u(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00377 \par
00415 {\cf20 //}\par
00416 {\cf17 extern} {\cf18 void} RFFT_adc_f32(RFFT_ADC_F32_STRUCT_Handle hndRFFT_ADC_F32);\par
00417 \par
00453 {\cf20 //}\par
00454 {\cf17 extern} {\cf18 void} RFFT_adc_f32u(RFFT_ADC_F32_STRUCT_Handle hndRFFT_ADC_F32);\par
00455 \par
00472 {\cf20 //}\par
00473 {\cf17 extern} {\cf18 void} RFFT_f32_win({\cf18 float} *pBuffer, {\cf17 const} {\cf18 float} *pWindow, \par
00474                          {\cf17 const} uint16_t size);\par
00475 \par
00498 {\cf20 //}\par
00499 {\cf17 extern} {\cf18 void} RFFT_adc_f32_win(uint16_t *pBuffer, {\cf17 const} uint16_t *pWindow,\par
00500                              {\cf17 const} uint16_t size);\par
00501 \par
00528 {\cf20 //}\par
00529 {\cf17 extern} {\cf18 void} RFFT_f32_mag(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00530 \par
00556 {\cf20 //}\par
00557 {\cf17 extern} {\cf18 void} RFFT_f32s_mag(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00558 \par
00576 {\cf20 //}\par
00577 {\cf17 extern} {\cf18 void} RFFT_f32_phase(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00578 \par
00579 {\cf21 #if defined(__TMS320C28XX_TMU__)}\par
00606 {\cf20 //}\par
00607 {\cf17 extern} {\cf18 void} RFFT_f32_mag_TMU0(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00608 \par
00634 {\cf20 //}\par
00635 {\cf17 extern} {\cf18 void} RFFT_f32s_mag_TMU0(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00636 \par
00654 {\cf20 //}\par
00655 {\cf17 extern} {\cf18 void} RFFT_f32_phase_TMU0(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00656 {\cf21 #endif }{\cf20 //__TMS320C28XX_TMU__}\par
00657 \par
00663 {\cf20 //}\par
00664 {\cf17 extern} {\cf18 void} RFFT_f32_sincostable(RFFT_F32_STRUCT_Handle hndRFFT_F32);\par
00665 \par
00666 {\cf20 // @\} //addtogroup}\par
00667 \par
00668 {\cf21 #ifdef __cplusplus}\par
00669 \}\par
00670 {\cf21 #endif }{\cf20 /* extern "C" */}{\cf21 }\par
00671 \par
00672 {\cf21 #endif   }{\cf20 // - end of _FPU_RFFT_H_}\par
00673 \par
00674 {\cf20 // End of File}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LEDPatterns.c File Reference\par \pard\plain 
{\tc\tcl2 \v LEDPatterns.c}
{\xe \v LEDPatterns.c}
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLEDLetter} (uint16_t *letter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b displayLEDletter} (uint16_t num)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_0} [15] = \{1,1,1,1,1,1,0,0,0,1,1,1,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_1} [15] = \{0,1,0,0,1,1,1,1,1,1,0,0,0,0,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_2} [15] = \{1,0,1,1,1,1,0,1,0,1,1,1,1,0,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_3} [15] = \{1,0,1,0,1,1,0,1,0,1,1,1,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_4} [15] = \{1,1,1,0,0,0,0,1,0,0,1,1,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_5} [15] = \{1,1,1,0,1,1,0,1,0,1,1,0,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_6} [15] = \{1,1,1,1,1,1,0,1,0,1,1,0,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_7} [15] = \{1,0,0,0,0,1,0,0,0,0,1,1,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_8} [15] = \{1,1,1,1,1,1,0,1,0,1,1,1,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_9} [15] = \{1,1,1,0,1,1,0,1,0,1,1,1,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_A} [15] = \{1,1,1,1,1,1,0,1,0,0,1,1,1,1,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_B} [15] = \{1,1,1,1,1,1,0,1,0,1,0,1,0,1,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_C} [15] = \{1,1,1,1,1,1,0,0,0,1,1,0,0,0,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_D} [15] = \{1,1,1,1,1,1,0,0,0,1,0,1,1,1,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_E} [15] = \{1,1,1,1,1,1,0,1,0,1,1,0,1,0,1\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LED_F} [15] = \{1,1,1,1,1,1,0,1,0,0,1,0,1,0,0\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v displayLEDletter\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:displayLEDletter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void displayLEDletter (uint16_t num)}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 356} of file {\b LEDPatterns.c}.}\par
}
{\xe \v setLEDLetter\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:setLEDLetter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setLEDLetter (uint16_t * letter)}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b LEDPatterns.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v LED_0\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_0[15] = \{1,1,1,1,1,1,0,0,0,1,1,1,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_1\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_1[15] = \{0,1,0,0,1,1,1,1,1,1,0,0,0,0,1\}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_2\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_2[15] = \{1,0,1,1,1,1,0,1,0,1,1,1,1,0,1\}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_3\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_3[15] = \{1,0,1,0,1,1,0,1,0,1,1,1,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_4\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_4[15] = \{1,1,1,0,0,0,0,1,0,0,1,1,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_5\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_5[15] = \{1,1,1,0,1,1,0,1,0,1,1,0,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_6\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_6[15] = \{1,1,1,1,1,1,0,1,0,1,1,0,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 176} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_7\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_7[15] = \{1,0,0,0,0,1,0,0,0,0,1,1,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_8\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_8[15] = \{1,1,1,1,1,1,0,1,0,1,1,1,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_9\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_9[15] = \{1,1,1,0,1,1,0,1,0,1,1,1,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 203} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_A\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_A[15] = \{1,1,1,1,1,1,0,1,0,0,1,1,1,1,1\}}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_B\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_B[15] = \{1,1,1,1,1,1,0,1,0,1,0,1,0,1,0\}}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_C\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_C[15] = \{1,1,1,1,1,1,0,0,0,1,1,0,0,0,1\}}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_D\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_D[15] = \{1,1,1,1,1,1,0,0,0,1,0,1,1,1,0\}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_E\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_E}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_E[15] = \{1,1,1,1,1,1,0,1,0,1,1,0,1,0,1\}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 248} of file {\b LEDPatterns.c}.}\par
}
{\xe \v LED_F\:LEDPatterns.c}
{\xe \v LEDPatterns.c\:LED_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LED_F[15] = \{1,1,1,1,1,1,0,1,0,0,1,0,1,0,0\}}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 257} of file {\b LEDPatterns.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LEDPatterns.c\par \pard\plain 
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <stdio.h>}\par
00002 {\cf21 #include <stdlib.h>}\par
00003 {\cf21 #include <stdarg.h>}\par
00004 {\cf21 #include <string.h>}\par
00005 {\cf21 #include <math.h>}\par
00006 {\cf21 #include <limits.h>}\par
00007 \par
00008 {\cf21 #include "F28x_Project.h"}     {\cf20 // Device Headerfile and Examples Include File}\par
00009 \par
00010 {\cf20 //LED Code Fragments}\par
00011 \par
00012 {\cf20 //LED1 Off use SET.bit to turn on LED}\par
00013 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;}\par
00014 \par
00015 {\cf20 //LED2 Off use SET.bit to turn on LED}\par
00016 {\cf20 //GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;}\par
00017 \par
00018 {\cf20 //LED3 Off use SET.bit to turn on LED}\par
00019 {\cf20 //GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;}\par
00020 \par
00021 {\cf20 //LED4 Off use SET.bit to turn on LED}\par
00022 {\cf20 //GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;}\par
00023 \par
00024 {\cf20 //LED5 Off use SET.bit to turn on LED}\par
00025 {\cf20 //GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;}\par
00026 \par
00027 {\cf20 //LED6 Off use SET.bit to turn on LED}\par
00028 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;}\par
00029 \par
00030 {\cf20 //LED7 Off use SET.bit to turn on LED}\par
00031 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;}\par
00032 \par
00033 {\cf20 //LED8 Off use SET.bit to turn on LED}\par
00034 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;}\par
00035 \par
00036 {\cf20 //LED9 Off use SET.bit to turn on LED}\par
00037 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;}\par
00038 \par
00039 {\cf20 //LED10 Off use SET.bit to turn on LED}\par
00040 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;}\par
00041 \par
00042 {\cf20 //LED11 Off use SET.bit to turn on LED}\par
00043 {\cf20 //GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;}\par
00044 \par
00045 {\cf20 //LED12 Off use SET.bit to turn on LED}\par
00046 {\cf20 //GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;}\par
00047 \par
00048 {\cf20 //LED13 Off use SET.bit to turn on LED}\par
00049 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;}\par
00050 \par
00051 {\cf20 //LED14 Off use SET.bit to turn on LED}\par
00052 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;}\par
00053 \par
00054 {\cf20 //LED15 Off use SET.bit to turn on LED}\par
00055 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;}\par
00056 \par
00057 {\cf20 //LED16 Off use SET.bit to turn on LED}\par
00058 {\cf20 //GpioDataRegs.GPFCLEAR.bit.GPIO160 = 1;}\par
00059 \par
00060 {\cf20 // Column 1 Off  Use SET.bit for On and TOGGLE.bit to toggle On/Off}\par
00061 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;}\par
00062 {\cf20 //GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;}\par
00063 {\cf20 //GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;}\par
00064 {\cf20 //GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;}\par
00065 {\cf20 //GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;}\par
00066 \par
00067 {\cf20 // Column 2 Off  Use SET.bit for On and TOGGLE.bit to toggle On/Off}\par
00068 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;}\par
00069 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;}\par
00070 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;}\par
00071 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;}\par
00072 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;}\par
00073 \par
00074 {\cf20 // Column 3 Off  Use SET.bit for On and TOGGLE.bit to toggle On/Off}\par
00075 {\cf20 //GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;}\par
00076 {\cf20 //GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;}\par
00077 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;}\par
00078 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;}\par
00079 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;}\par
00080 \par
00081 {\cf20 // ROW 1 Off Use SET.bit for On and TOGGLE.bit fto toggle On/Off}\par
00082 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;}\par
00083 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;}\par
00084 {\cf20 //GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;}\par
00085 \par
00086 {\cf20 // ROW 2 Off Use SET.bit for On and TOGGLE.bit fto toggle On/Off}\par
00087 {\cf20 //GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;}\par
00088 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;}\par
00089 {\cf20 //GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;}\par
00090 \par
00091 {\cf20 // ROW 3 Off Use SET.bit for On and TOGGLE.bit fto toggle On/Off}\par
00092 {\cf20 //GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;}\par
00093 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;}\par
00094 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;}\par
00095 \par
00096 {\cf20 // ROW 4 Off Use SET.bit for On and TOGGLE.bit fto toggle On/Off}\par
00097 {\cf20 //GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;}\par
00098 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;}\par
00099 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;}\par
00100 \par
00101 {\cf20 // ROW 5 Off Use SET.bit for On and TOGGLE.bit fto toggle On/Off}\par
00102 {\cf20 //GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;}\par
00103 {\cf20 //GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;}\par
00104 {\cf20 //GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;}\par
00105 \par
00106 {\cf20 //}\par
00107 {\cf20 // XXX      16B }\par
00108 {\cf20 // XXX      27C}\par
00109 {\cf20 // XXX      38D}\par
00110 {\cf20 // XXX      49E}\par
00111 {\cf20 // XXXX     5AF}\par
00112 {\cf20 //                      1 2 3 4 5 6 7 8 9 A B C D E F}\par
00113 {\cf20 //uint16_t LED_ [15] = \{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\};}\par
00114 \par
00115 {\cf20 // 0}\par
00116 {\cf20 // 000      000 }\par
00117 {\cf20 // 0X0      070}\par
00118 {\cf20 // 0X0      080}\par
00119 {\cf20 // 0X0      090}\par
00120 {\cf20 // 000X     000}\par
00121 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00122 uint16_t LED_0[15] = \{1,1,1,1,1,1,0,0,0,1,1,1,1,1,1\};\par
00123 \par
00124 {\cf20 // 1}\par
00125 {\cf20 // X0X      10B }\par
00126 {\cf20 // 00X      00C}\par
00127 {\cf20 // X0X      30D}\par
00128 {\cf20 // X0X      40E}\par
00129 {\cf20 // 000X     000}\par
00130 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00131 uint16_t LED_1[15] = \{0,1,0,0,1,1,1,1,1,1,0,0,0,0,1\};\par
00132 \par
00133 {\cf20 // 2}\par
00134 {\cf20 // 000      000 }\par
00135 {\cf20 // XX0      270}\par
00136 {\cf20 // 000      000}\par
00137 {\cf20 // 0XX      09E}\par
00138 {\cf20 // 000X     000}\par
00139 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00140 uint16_t LED_2[15] = \{1,0,1,1,1,1,0,1,0,1,1,1,1,0,1\};\par
00141 \par
00142 {\cf20 // 3}\par
00143 {\cf20 // 000      000 }\par
00144 {\cf20 // XX0      270}\par
00145 {\cf20 // 000      000}\par
00146 {\cf20 // XX0      490}\par
00147 {\cf20 // 000X     000}\par
00148 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00149 uint16_t LED_3[15] = \{1,0,1,0,1,1,0,1,0,1,1,1,1,1,1\};\par
00150 \par
00151 {\cf20 // 4}\par
00152 {\cf20 // 0X0      060 }\par
00153 {\cf20 // 0X0      070}\par
00154 {\cf20 // 000      000}\par
00155 {\cf20 // XX0      490}\par
00156 {\cf20 // XX0X     5A0}\par
00157 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00158 uint16_t LED_4[15] = \{1,1,1,0,0,0,0,1,0,0,1,1,1,1,1\};\par
00159 \par
00160 {\cf20 // 5}\par
00161 {\cf20 // 000      000 }\par
00162 {\cf20 // 0XX      07C}\par
00163 {\cf20 // 000      000}\par
00164 {\cf20 // XX0      490}\par
00165 {\cf20 // 000X     000}\par
00166 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00167 uint16_t LED_5[15] = \{1,1,1,0,1,1,0,1,0,1,1,0,1,1,1\};\par
00168 \par
00169 {\cf20 // 6}\par
00170 {\cf20 // 000      000 }\par
00171 {\cf20 // 0XX      07C}\par
00172 {\cf20 // 000      000}\par
00173 {\cf20 // 0X0      090}\par
00174 {\cf20 // 000X     000}\par
00175 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00176 uint16_t LED_6[15] = \{1,1,1,1,1,1,0,1,0,1,1,0,1,1,1\};\par
00177 \par
00178 {\cf20 // 7}\par
00179 {\cf20 // 000      000 }\par
00180 {\cf20 // XX0      270}\par
00181 {\cf20 // XX0      380}\par
00182 {\cf20 // XX0      490}\par
00183 {\cf20 // XX0X     5A0}\par
00184 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00185 uint16_t LED_7[15] = \{1,0,0,0,0,1,0,0,0,0,1,1,1,1,1\};\par
00186 \par
00187 {\cf20 // 8}\par
00188 {\cf20 // 000      000 }\par
00189 {\cf20 // 0X0      070}\par
00190 {\cf20 // 000      000}\par
00191 {\cf20 // 0X0      090}\par
00192 {\cf20 // 000X     000}\par
00193 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00194 uint16_t LED_8[15] = \{1,1,1,1,1,1,0,1,0,1,1,1,1,1,1\};\par
00195 \par
00196 {\cf20 // 9}\par
00197 {\cf20 // 000      000 }\par
00198 {\cf20 // 0X0      070}\par
00199 {\cf20 // 000      000}\par
00200 {\cf20 // XX0      490}\par
00201 {\cf20 // 000X     000}\par
00202 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00203 uint16_t LED_9[15] = \{1,1,1,0,1,1,0,1,0,1,1,1,1,1,1\};\par
00204 \par
00205 {\cf20 // A}\par
00206 {\cf20 // 000      000 }\par
00207 {\cf20 // 0X0      070}\par
00208 {\cf20 // 000      000}\par
00209 {\cf20 // 0X0      090}\par
00210 {\cf20 // 0X0X     0A0}\par
00211 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00212 uint16_t LED_A[15] = \{1,1,1,1,1,1,0,1,0,0,1,1,1,1,1\};\par
00213 \par
00214 {\cf20 // B}\par
00215 {\cf20 // 00X      00B }\par
00216 {\cf20 // 0X0      070}\par
00217 {\cf20 // 00X      00D}\par
00218 {\cf20 // 0X0      090}\par
00219 {\cf20 // 00XX     00F}\par
00220 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00221 uint16_t LED_B[15] = \{1,1,1,1,1,1,0,1,0,1,0,1,0,1,0\};\par
00222 \par
00223 {\cf20 // C}\par
00224 {\cf20 // 000      000 }\par
00225 {\cf20 // 0XX      07C}\par
00226 {\cf20 // 0XX      08D}\par
00227 {\cf20 // 0XX      09E}\par
00228 {\cf20 // 000X     000}\par
00229 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00230 uint16_t LED_C[15] = \{1,1,1,1,1,1,0,0,0,1,1,0,0,0,1\};\par
00231 \par
00232 {\cf20 // D}\par
00233 {\cf20 // 00X      00B }\par
00234 {\cf20 // 0X0      070}\par
00235 {\cf20 // 0X0      080}\par
00236 {\cf20 // 0X0      090}\par
00237 {\cf20 // 00XX     00F}\par
00238 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00239 uint16_t LED_D[15] = \{1,1,1,1,1,1,0,0,0,1,0,1,1,1,0\};\par
00240 \par
00241 {\cf20 // E}\par
00242 {\cf20 // 000      000 }\par
00243 {\cf20 // 0XX      07C}\par
00244 {\cf20 // 000      000}\par
00245 {\cf20 // 0XX      09E}\par
00246 {\cf20 // 000X     000}\par
00247 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00248 uint16_t LED_E[15] = \{1,1,1,1,1,1,0,1,0,1,1,0,1,0,1\};\par
00249 \par
00250 {\cf20 // F}\par
00251 {\cf20 // 000      000 }\par
00252 {\cf20 // 0XX      07C}\par
00253 {\cf20 // 000      000}\par
00254 {\cf20 // 0XX      09E}\par
00255 {\cf20 // 0XXX     0AF}\par
00256 {\cf20 //                    1 2 3 4 5 6 7 8 9 A B C D E F }\par
00257 uint16_t LED_F[15] = \{1,1,1,1,1,1,0,1,0,0,1,0,1,0,0\};\par
00258 \par
00259 \par
00260 \par
00261 {\cf18 void} setLEDLetter(uint16_t * letter) \{\par
00262 \par
00263     {\cf19 if} (letter[0] == 0) \{\par
00264         GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;\par
00265     \} {\cf19 else} \{\par
00266         GpioDataRegs.GPASET.bit.GPIO22 = 1;     \par
00267     \}\par
00268 \par
00269     {\cf19 if} (letter[1] == 0) \{\par
00270         GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;\par
00271     \} {\cf19 else} \{\par
00272         GpioDataRegs.GPCSET.bit.GPIO94 = 1;     \par
00273     \}\par
00274 \par
00275     {\cf19 if} (letter[2] == 0) \{\par
00276         GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;\par
00277     \} {\cf19 else} \{\par
00278         GpioDataRegs.GPCSET.bit.GPIO95 = 1;\par
00279     \}\par
00280 \par
00281     {\cf19 if} (letter[3] == 0) \{\par
00282         GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;\par
00283     \} {\cf19 else} \{\par
00284         GpioDataRegs.GPDSET.bit.GPIO97 = 1;\par
00285     \}\par
00286 \par
00287     {\cf19 if} (letter[4] == 0) \{\par
00288         GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;\par
00289     \} {\cf19 else} \{\par
00290         GpioDataRegs.GPDSET.bit.GPIO111 = 1;\par
00291     \}\par
00292 \par
00293     {\cf19 if} (letter[5] == 0) \{\par
00294         GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;\par
00295     \} {\cf19 else} \{\par
00296         GpioDataRegs.GPESET.bit.GPIO130 = 1;\par
00297     \}\par
00298 \par
00299     {\cf19 if} (letter[6] == 0) \{\par
00300         GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;\par
00301     \} {\cf19 else} \{\par
00302         GpioDataRegs.GPESET.bit.GPIO131 = 1;\par
00303     \}\par
00304 \par
00305     {\cf19 if} (letter[7] == 0) \{\par
00306         GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;\par
00307     \} {\cf19 else} \{\par
00308         GpioDataRegs.GPASET.bit.GPIO25 = 1;\par
00309     \}\par
00310 \par
00311     {\cf19 if} (letter[8] == 0) \{\par
00312         GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;\par
00313     \} {\cf19 else} \{\par
00314         GpioDataRegs.GPASET.bit.GPIO26 = 1;\par
00315     \}\par
00316 \par
00317     {\cf19 if} (letter[9] == 0) \{\par
00318         GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;\par
00319     \} {\cf19 else} \{\par
00320         GpioDataRegs.GPASET.bit.GPIO27 = 1;\par
00321     \}\par
00322 \par
00323     {\cf19 if} (letter[10] == 0) \{\par
00324         GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;\par
00325     \} {\cf19 else} \{\par
00326         GpioDataRegs.GPBSET.bit.GPIO60 = 1;\par
00327     \}\par
00328 \par
00329     {\cf19 if} (letter[11] == 0) \{\par
00330         GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;\par
00331     \} {\cf19 else} \{\par
00332         GpioDataRegs.GPBSET.bit.GPIO61 = 1;\par
00333     \}\par
00334 \par
00335     {\cf19 if} (letter[12] == 0) \{\par
00336         GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;\par
00337     \} {\cf19 else} \{\par
00338         GpioDataRegs.GPESET.bit.GPIO157 = 1;\par
00339     \}\par
00340 \par
00341     {\cf19 if} (letter[13] == 0) \{\par
00342         GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;\par
00343     \} {\cf19 else} \{\par
00344         GpioDataRegs.GPESET.bit.GPIO158 = 1;\par
00345     \}\par
00346 \par
00347     {\cf19 if} (letter[14] == 0) \{\par
00348         GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;\par
00349     \} {\cf19 else} \{\par
00350         GpioDataRegs.GPESET.bit.GPIO159 = 1;\par
00351     \}\par
00352 \par
00353 \}\par
00354 \par
00355 \par
00356 {\cf18 void} displayLEDletter(uint16_t num) \{\par
00357     num = num&0xF;  {\cf20 // only look at bottom 4 bits so number between 0 and 15 or 0x0 and 0xF}\par
00358     {\cf19 if} (num == 0) \{\par
00359         setLEDLetter(LED_0);\par
00360     \} {\cf19 else} {\cf19 if} (num == 1) \{\par
00361         setLEDLetter(LED_1);\par
00362     \} {\cf19 else} {\cf19 if} (num == 2) \{\par
00363         setLEDLetter(LED_2);\par
00364     \} {\cf19 else} {\cf19 if} (num == 3) \{\par
00365         setLEDLetter(LED_3);\par
00366     \} {\cf19 else} {\cf19 if} (num == 4) \{\par
00367         setLEDLetter(LED_4);\par
00368     \} {\cf19 else} {\cf19 if} (num == 5) \{\par
00369         setLEDLetter(LED_5);\par
00370     \} {\cf19 else} {\cf19 if} (num == 6) \{\par
00371         setLEDLetter(LED_6);\par
00372     \} {\cf19 else} {\cf19 if} (num == 7) \{\par
00373         setLEDLetter(LED_7);\par
00374     \} {\cf19 else} {\cf19 if} (num == 8) \{\par
00375         setLEDLetter(LED_8);\par
00376     \} {\cf19 else} {\cf19 if} (num == 9) \{\par
00377         setLEDLetter(LED_9);\par
00378     \} {\cf19 else} {\cf19 if} (num == 10) \{\par
00379         setLEDLetter(LED_A);\par
00380     \} {\cf19 else} {\cf19 if} (num == 11) \{\par
00381         setLEDLetter(LED_B);\par
00382     \} {\cf19 else} {\cf19 if} (num == 12) \{\par
00383         setLEDLetter(LED_C);\par
00384     \} {\cf19 else} {\cf19 if} (num == 13) \{\par
00385         setLEDLetter(LED_D);\par
00386     \} {\cf19 else} {\cf19 if} (num == 14) \{\par
00387         setLEDLetter(LED_E);\par
00388     \} {\cf19 else} {\cf19 if} (num == 15) \{\par
00389         setLEDLetter(LED_F);\par
00390     \}\par
00391 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LEDPatterns.h File Reference\par \pard\plain 
{\tc\tcl2 \v LEDPatterns.h}
{\xe \v LEDPatterns.h}
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLEDLetter} (uint16_t *letter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b displayLEDletter} (uint16_t num)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v displayLEDletter\:LEDPatterns.h}
{\xe \v LEDPatterns.h\:displayLEDletter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void displayLEDletter (uint16_t num)}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 356} of file {\b LEDPatterns.c}.}\par
}
{\xe \v setLEDLetter\:LEDPatterns.h}
{\xe \v LEDPatterns.h\:setLEDLetter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setLEDLetter (uint16_t * letter)}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b LEDPatterns.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LEDPatterns.h\par \pard\plain 
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf18 void} setLEDLetter(uint16_t * letter);\par
00002 {\cf18 void} displayLEDletter(uint16_t num);\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Segbot_Steer_and_Celebrate.c File Reference\par \pard\plain 
{\tc\tcl2 \v Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
{\f2 #include "driverlib.h"}\par
{\f2 #include "device.h"}\par
{\f2 #include "f28379dSerial.h"}\par
{\f2 #include "LEDPatterns.h"}\par
{\f2 #include "song.h"}\par
{\f2 #include "dsp.h"}\par
{\f2 #include "fpu32/fpu_rfft.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union {\b phonedata_s}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PI}\~ 3.1415926535897932384626433832795\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWOPI}\~ 6.283185307179586476925286766559\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HALFPI}\~ 1.5707963267948966192313216916398\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b songsize}\~ 14\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b sampling_rate}\~ 10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NOTE}\~ 625\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b n_samples}\~ 1000\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef union {\b phonedata_s} {\b phonedata_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer0_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer1_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer2_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SWI_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SPIB_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b ADCA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b ADCB_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupSpib} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXA} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXC} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_eQEPs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncLeft} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncRight} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2A} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2B} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b goertzel_mag} (int numSamples, int TARGET_FREQUENCY, int SAMPLING_RATE, float *data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b main} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b phonedata_t} {\b phoneaccel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b song} [{\b songsize}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b dance} [{\b songsize}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b pwm12prd} = 50000000/{\b sampling_rate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b note_detected} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b thresh} = 150\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adcb_arrayPing} [{\b n_samples}] = \{0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adcb_arrayPong} [{\b n_samples}] = \{0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adcb0result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b adcbcount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b PingPong} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b RunPong} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b RunPing} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b goer_result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b steeroff} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numTimer0calls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numSWIcalls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numRXA} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint2} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LEDdisplaynum} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b Junk} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelzraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyrozraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ubal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K1} = -60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K2} = -7.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K3} = -1.1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uLeft} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uRight} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turn} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kp} = 3.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Ki} = 20.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kd} = .01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b FwdBackOffset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca0_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca1_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca0result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca1result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelzBalancePoint} = -.73\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16 {\b IMU_data} [9]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b temp} =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b doneCal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b T} = 0.001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Q} = 0.01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b R} = 25000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_tilt} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_P} = 22.365\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b SpibNumCalls} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pred_P} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_K} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b timecount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b calibration_state} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b calibration_count} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_x} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_y} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_z} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sendback} [10]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b past} [14]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HALFPI\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:HALFPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HALFPI\~ 1.5707963267948966192313216916398}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v n_samples\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:n_samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define n_samples\~ 1000}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v NOTE\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NOTE\~ 625}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v PI\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PI\~ 3.1415926535897932384626433832795}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v sampling_rate\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:sampling_rate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define sampling_rate\~ 10000}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v songsize\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:songsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define songsize\~ 14}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v TWOPI\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:TWOPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWOPI\~ 6.283185307179586476925286766559}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v phonedata_t\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:phonedata_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef union {\b phonedata_s} {\b phonedata_t}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ADCA_ISR\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:ADCA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void ADCA_ISR (void )}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 776} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v ADCB_ISR\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:ADCB_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void ADCB_ISR (void )}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 911} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v cpu_timer0_isr\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:cpu_timer0_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer0_isr (void )}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 645} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v cpu_timer1_isr\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:cpu_timer1_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer1_isr (void )}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 675} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v cpu_timer2_isr\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:cpu_timer2_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer2_isr (void )}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 682} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v goertzel_mag\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:goertzel_mag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float goertzel_mag (int numSamples, int TARGET_FREQUENCY, int SAMPLING_RATE, float * data)}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1243} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v init_eQEPs\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:init_eQEPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_eQEPs (void )}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 968} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v main\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void main (void )}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v readEncLeft\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:readEncLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncLeft (void )}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 941} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v readEncRight\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:readEncRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncRight (void )}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 954} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v serialRXA\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:serialRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXA ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 692} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v serialRXC\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:serialRXC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXC ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 698} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v setEPWM2A\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:setEPWM2A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2A (float controleffort)}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 862} of file {\b UART_Segbot..c}.}\par
}
{\xe \v setEPWM2B\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:setEPWM2B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2B (float controleffort)}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 873} of file {\b UART_Segbot..c}.}\par
}
{\xe \v setupSpib\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:setupSpib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setupSpib (void )}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 883} of file {\b UART_Segbot..c}.}\par
}
{\xe \v SPIB_isr\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:SPIB_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SPIB_isr (void )}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 803} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v SWI_isr\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:SWI_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SWI_isr (void )}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 582} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v accelx\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx = 0}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accelx_offset\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelx_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx_offset = 0}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accelxraw\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelxraw = 0}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accely\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely = 0}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accely_offset\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accely_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely_offset = 0}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accelyraw\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelyraw = 0}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accelz\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz = 0}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accelz_offset\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz_offset = 0}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accelzBalancePoint\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelzBalancePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelzBalancePoint = -.73}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v accelzraw\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:accelzraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelzraw = 0}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adca0_volts\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adca0_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca0_volts = 0}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adca0result\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adca0result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca0result = 0}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adca1_volts\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adca1_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca1_volts = 0}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adca1result\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adca1result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca1result = 0}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adcb0result\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adcb0result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adcb0result = 0}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adcb_arrayPing\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adcb_arrayPing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adcb_arrayPing[{\b n_samples}] = \{0\}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adcb_arrayPong\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adcb_arrayPong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adcb_arrayPong[{\b n_samples}] = \{0\}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v adcbcount\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:adcbcount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t adcbcount = 0}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v ble_x\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:ble_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_x = 0}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v ble_y\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:ble_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_y = 0}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v ble_z\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:ble_z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_z = 0}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v calibration_count\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:calibration_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t calibration_count = 0}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 175} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v calibration_state\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:calibration_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t calibration_state = 0}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v dance\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:dance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float dance[{\b songsize}]}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{-6,6,-6,6,\par
                         -6,6,-6,6,\par
                         -6,6,-6,6,\par
                         -6,6\par
                        \}\par
}
{
Definition at line {\b 63} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v doneCal\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:doneCal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t doneCal = 0}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v eDif\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:eDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif = 0}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v eDif_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:eDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif_1 = 0}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v FwdBackOffset\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:FwdBackOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float FwdBackOffset = 0}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v goer_result\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:goer_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float goer_result = 0}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyro_array\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyro_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyro_value\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyro_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_value = 0}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyrox\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyrox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox = 0}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyrox_offset\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyrox_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox_offset = 0}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyroxraw\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyroxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroxraw = 0}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyroy\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy = 0}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyroy_offset\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyroy_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy_offset = 0}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyroyraw\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyroyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroyraw = 0}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyroz\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyroz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz = 0}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyroz_offset\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyroz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz_offset = 0}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v gyrozraw\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:gyrozraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyrozraw = 0}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v iDif\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:iDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif = 0}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v iDif_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:iDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif_1 = 0}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v IMU_data\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:IMU_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16 IMU_data[9]}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v Junk\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:Junk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Junk = 0}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v K1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:K1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K1 = -60}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v K2\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:K2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K2 = -7.0}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v K3\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:K3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K3 = -1.1}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v kalman_K\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:kalman_K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_K = 0}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v kalman_P\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:kalman_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_P = 22.365}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v kalman_tilt\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:kalman_tilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_tilt = 0}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v Kd\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:Kd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kd = .01}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v Ki\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:Ki}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Ki = 20.0}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v Kp\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:Kp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kp = 3.0}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v LEDdisplaynum\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:LEDdisplaynum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LEDdisplaynum = 0}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v LeftVel\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:LeftVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel = 0}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v LeftVel_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:LeftVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel_1 = 0}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v LeftWheel\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:LeftWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel = 0}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v LeftWheel_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:LeftWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel_1 = 0}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v LeftWheelArray\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:LeftWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v note_detected\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:note_detected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t note_detected = 0}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v numRXA\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:numRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numRXA = 0}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v numSWIcalls\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:numSWIcalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numSWIcalls = 0}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v numTimer0calls\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:numTimer0calls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numTimer0calls = 0}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v past\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:past}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char past[14]}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 697} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v phoneaccel\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:phoneaccel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b phonedata_t} phoneaccel}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v PingPong\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:PingPong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t PingPong = 0}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v pred_P\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:pred_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float pred_P = 0}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v pwm12prd\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:pwm12prd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t pwm12prd = 50000000/{\b sampling_rate}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v Q\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:Q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Q = 0.01}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v R\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:R}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float R = 25000}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v RightVel\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:RightVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel = 0}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v RightVel_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:RightVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel_1 = 0}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v RightWheel\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:RightWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel = 0}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v RightWheel_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:RightWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel_1 = 0}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v RightWheelArray\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:RightWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v RunPing\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:RunPing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t RunPing = 0}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v RunPong\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:RunPong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t RunPong = 0}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v sendback\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:sendback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char sendback[10]}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 696} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v song\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:song}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float song[{\b songsize}]}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{F5NOTE,F5NOTE,F5NOTE,F5NOTE,\par
                        E5NOTE,E5NOTE,F5NOTE,F5NOTE,\par
                        E5NOTE,E5NOTE,D5NOTE,D5NOTE,\par
                        G5NOTE,G5NOTE\par
                        \}\par
}
{
Definition at line {\b 58} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v SpibNumCalls\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:SpibNumCalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SpibNumCalls = -1}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v steeroff\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:steeroff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t steeroff = 0}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v T\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float T = 0.001}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v temp\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t temp =0}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v thresh\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:thresh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t thresh = 150}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v tilt_array\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:tilt_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v tilt_value\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:tilt_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_value = 0}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v timecount\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:timecount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t timecount = 0}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 173} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v turn\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turn = 0}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v turnrate\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:turnrate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate = 0}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v turnrate_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:turnrate_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate_1 = 0}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v turnref\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:turnref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref = 0}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v turnref_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:turnref_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref_1 = 0}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v UARTPrint\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:UARTPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint = 0}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v UARTPrint2\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:UARTPrint2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint2 = 0}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v ubal\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:ubal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ubal = 0}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v uLeft\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:uLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uLeft = 5.0}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v uRight\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:uRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uRight = 5.0}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v velWheelDif\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:velWheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif = 0}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v velWheelDif_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:velWheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v WheelDif\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:WheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif = 0}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
{\xe \v WheelDif_1\:Segbot_Steer_and_Celebrate.c}
{\xe \v Segbot_Steer_and_Celebrate.c\:WheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b Segbot_Steer_and_Celebrate.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Segbot_Steer_and_Celebrate.c\par \pard\plain 
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //#############################################################################}\par
00002 {\cf20 //UART_Segbot Steer and Celebrate}\par
00003 {\cf20 //#############################################################################}\par
00004 \par
00005 {\cf20 // Included Files}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 {\cf21 #include <stdarg.h>}\par
00009 {\cf21 #include <string.h>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include <limits.h>}\par
00012 {\cf21 #include "F28x_Project.h"}\par
00013 {\cf21 #include "driverlib.h"}\par
00014 {\cf21 #include "device.h"}\par
00015 {\cf21 #include "f28379dSerial.h"}\par
00016 {\cf21 #include "LEDPatterns.h"}\par
00017 {\cf21 #include "song.h"}\par
00018 {\cf21 #include "dsp.h"}\par
00019 {\cf21 #include "fpu32/fpu_rfft.h"}\par
00020 \par
00021 {\cf21 #define PI          3.1415926535897932384626433832795}\par
00022 {\cf21 #define TWOPI       6.283185307179586476925286766559}\par
00023 {\cf21 #define HALFPI      1.5707963267948966192313216916398}\par
00024 \par
00025 {\cf20 //NOTES DEFINED IN song.h}\par
00026 {\cf21 #define songsize    14}\par
00027 {\cf21 #define sampling_rate 10000 }{\cf20 // 10 kHz}\par
00028 {\cf21 #define NOTE    625 }{\cf20 // Cheer}\par
00029 {\cf21 #define n_samples   1000 }{\cf20 // with a sampling frequency of 10kHz, this runs Goertzl 10x per second with 1000 ADC samples}\par
00030 \par
00031 {\cf20 // Interrupt Service Routines predefinition}\par
00032 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void});\par
00033 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void});\par
00034 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void});\par
00035 __interrupt {\cf18 void} SWI_isr({\cf18 void});\par
00036 __interrupt {\cf18 void} SPIB_isr({\cf18 void});\par
00037 __interrupt {\cf18 void} ADCA_ISR({\cf18 void});\par
00038 __interrupt {\cf18 void} ADCB_ISR({\cf18 void});\par
00039 \par
00040 {\cf18 void} setupSpib({\cf18 void});\par
00041 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data);\par
00042 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data);\par
00043 {\cf18 void} init_eQEPs({\cf18 void});\par
00044 {\cf18 float} readEncLeft({\cf18 void});\par
00045 {\cf18 float} readEncRight({\cf18 void});\par
00046 {\cf18 void} setEPWM2A({\cf18 float});\par
00047 {\cf18 void} setEPWM2B({\cf18 float});\par
00048 {\cf18 float} goertzel_mag({\cf18 int} numSamples,{\cf18 int} TARGET_FREQUENCY,{\cf18 int} SAMPLING_RATE, {\cf18 float}* data);\par
00049 \par
00050 {\cf17 typedef} {\cf17 union }phonedata_s\{\par
00051     uint16_t rawdata[6];\par
00052     {\cf18 float} fltdata[3];\par
00053 \par
00054 \}phonedata_t;\par
00055 phonedata_t phoneaccel; {\cf20 //use new data type defined in union}\par
00056 \par
00057 {\cf20 //Song}\par
00058 {\cf18 float} song[songsize] = \{F5NOTE,F5NOTE,F5NOTE,F5NOTE,\par
00059                         E5NOTE,E5NOTE,F5NOTE,F5NOTE,\par
00060                         E5NOTE,E5NOTE,D5NOTE,D5NOTE,\par
00061                         G5NOTE,G5NOTE\par
00062                         \};\par
00063 {\cf18 float} dance[songsize] = \{-6,6,-6,6,\par
00064                          -6,6,-6,6,\par
00065                          -6,6,-6,6,\par
00066                          -6,6\par
00067                         \};\par
00068 \par
00069 int16_t pwm12prd = 50000000/sampling_rate;\par
00070 int16_t note_detected = 0;\par
00071 int16_t thresh = 150; {\cf20 //tune this value}\par
00072 {\cf18 float} adcb_arrayPing[n_samples]= \{0\};\par
00073 {\cf18 float} adcb_arrayPong[n_samples]= \{0\};\par
00074 int16_t adcb0result = 0;\par
00075 int32_t adcbcount = 0;\par
00076 int16_t PingPong = 0;\par
00077 int16_t RunPong = 0;\par
00078 int16_t RunPing = 0;\par
00079 {\cf18 float} goer_result = 0;\par
00080 int16_t steeroff = 0;\par
00081 \par
00082 {\cf20 // Count variables}\par
00083 uint32_t numTimer0calls = 0;\par
00084 uint32_t numSWIcalls = 0;\par
00085 uint32_t numRXA = 0;\par
00086 uint16_t UARTPrint = 0;\par
00087 uint16_t UARTPrint2 = 0;\par
00088 uint16_t LEDdisplaynum = 0;\par
00089 \par
00090 int16_t Junk = 0;\par
00091 \par
00092 int16_t accelxraw = 0;\par
00093 int16_t accelyraw = 0;\par
00094 int16_t accelzraw = 0;\par
00095 int16_t gyroxraw = 0;\par
00096 int16_t gyroyraw = 0;\par
00097 int16_t gyrozraw = 0;\par
00098 \par
00099 {\cf18 float} accelx = 0;\par
00100 {\cf18 float} accely = 0;\par
00101 {\cf18 float} accelz = 0;\par
00102 {\cf18 float} gyrox = 0;\par
00103 {\cf18 float} gyroy = 0;\par
00104 {\cf18 float} gyroz = 0;\par
00105 {\cf18 float} LeftWheel = 0;\par
00106 {\cf18 float} RightWheel = 0;\par
00107 {\cf18 float} LeftWheel_1 = 0;\par
00108 {\cf18 float} RightWheel_1 = 0;\par
00109 {\cf18 float} LeftVel = 0;\par
00110 {\cf18 float} RightVel = 0;\par
00111 {\cf18 float} LeftVel_1 = 0;\par
00112 {\cf18 float} RightVel_1 = 0;\par
00113 {\cf18 float} ubal = 0;\par
00114 {\cf18 float} K1 = -60;\par
00115 {\cf20 //float K2 = -4.5;}\par
00116 {\cf18 float} K2 = -7.0;\par
00117 {\cf18 float} K3 = -1.1;\par
00118 {\cf18 float} WheelDif = 0;\par
00119 {\cf18 float} velWheelDif = 0;\par
00120 {\cf18 float} WheelDif_1 = 0;\par
00121 {\cf18 float} velWheelDif_1 = 0;\par
00122 {\cf18 float} turnref = 0;\par
00123 {\cf18 float} turnref_1 = 0;\par
00124 {\cf18 float} uLeft = 5.0;\par
00125 {\cf18 float} uRight = 5.0;\par
00126 {\cf18 float} eDif = 0;\par
00127 {\cf18 float} iDif = 0;\par
00128 {\cf18 float} eDif_1 = 0;\par
00129 {\cf18 float} iDif_1 = 0;\par
00130 {\cf18 float} turn = 0; {\cf20 //turn setpoint}\par
00131 {\cf18 float} Kp = 3.0;\par
00132 {\cf18 float} Ki = 20.0;\par
00133 {\cf20 //float Kd = .08;}\par
00134 {\cf18 float} Kd = .01;\par
00135 {\cf18 float} FwdBackOffset = 0;\par
00136 {\cf18 float} turnrate = 0;\par
00137 {\cf18 float} turnrate_1 = 0;\par
00138 \par
00139 \par
00140 {\cf20 //lab4 variables}\par
00141 {\cf18 float} adca0_volts = 0;\par
00142 {\cf18 float} adca1_volts = 0;\par
00143 int16_t adca0result = 0;\par
00144 int16_t adca1result = 0;\par
00145 \par
00146 {\cf20 // Needed global Variables}\par
00147 {\cf18 float} accelx_offset = 0;\par
00148 {\cf18 float} accely_offset = 0;\par
00149 {\cf18 float} accelz_offset = 0;\par
00150 {\cf18 float} gyrox_offset  = 0;\par
00151 {\cf18 float} gyroy_offset  = 0;\par
00152 {\cf18 float} gyroz_offset  = 0;\par
00153 {\cf20 //float accelzBalancePoint = -.76; // tune this}\par
00154 {\cf18 float} accelzBalancePoint = -.73;\par
00155 int16 IMU_data[9];\par
00156 uint16_t temp=0;\par
00157 int16_t doneCal = 0;\par
00158 {\cf18 float} tilt_value    = 0;\par
00159 {\cf18 float} tilt_array[4] = \{0, 0, 0, 0\};\par
00160 {\cf18 float} gyro_value    = 0;\par
00161 {\cf18 float} gyro_array[4] = \{0, 0, 0, 0\};\par
00162 {\cf18 float} LeftWheelArray[4] = \{0,0,0,0\};\par
00163 {\cf18 float} RightWheelArray[4] = \{0,0,0,0\};\par
00164 {\cf20 // Kalman Filter vars}\par
00165 {\cf18 float} T = 0.001;        {\cf20 //sample rate, 1ms}\par
00166 {\cf18 float} Q = 0.01; {\cf20 // made global to enable changing in runtime}\par
00167 {\cf18 float} R = 25000;{\cf20 //50000;}\par
00168 {\cf18 float} kalman_tilt = 0;\par
00169 {\cf18 float} kalman_P = 22.365;\par
00170 int16_t SpibNumCalls = -1;\par
00171 {\cf18 float} pred_P = 0;\par
00172 {\cf18 float} kalman_K = 0;\par
00173 int32_t timecount = 0;\par
00174 int16_t calibration_state = 0;\par
00175 int32_t calibration_count = 0;\par
00176 \par
00177 {\cf20 //BLE DATA}\par
00178 {\cf18 float} ble_x = 0;\par
00179 {\cf18 float} ble_y = 0;\par
00180 {\cf18 float} ble_z = 0;\par
00181 \par
00182 {\cf18 void} main({\cf18 void})\par
00183  \{\par
00184     {\cf20 // PLL, WatchDog, enable Peripheral Clocks}\par
00185     {\cf20 // This example function is found in the F2837xD_SysCtrl.c file.}\par
00186     InitSysCtrl();\par
00187 \par
00188     InitGpio();\par
00189 \par
00190     {\cf20 // Blue LED on LuanchPad}\par
00191     GPIO_SetupPinMux(31, GPIO_MUX_CPU1, 0);\par
00192     GPIO_SetupPinOptions(31, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00193     GpioDataRegs.GPASET.bit.GPIO31 = 1;\par
00194 \par
00195     {\cf20 // Red LED on LaunchPad}\par
00196     GPIO_SetupPinMux(34, GPIO_MUX_CPU1, 0);\par
00197     GPIO_SetupPinOptions(34, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00198     GpioDataRegs.GPBSET.bit.GPIO34 = 1;\par
00199 \par
00200     {\cf20 // LED1 and PWM Pin}\par
00201     GPIO_SetupPinMux(22, GPIO_MUX_CPU1, 0);\par
00202     GPIO_SetupPinOptions(22, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00203     GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;\par
00204 \par
00205     {\cf20 // LED2}\par
00206     GPIO_SetupPinMux(94, GPIO_MUX_CPU1, 0);\par
00207     GPIO_SetupPinOptions(94, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00208     GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;\par
00209 \par
00210     {\cf20 // LED3}\par
00211     GPIO_SetupPinMux(95, GPIO_MUX_CPU1, 0);\par
00212     GPIO_SetupPinOptions(95, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00213     GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;\par
00214 \par
00215     {\cf20 // LED4}\par
00216     GPIO_SetupPinMux(97, GPIO_MUX_CPU1, 0);\par
00217     GPIO_SetupPinOptions(97, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00218     GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;\par
00219 \par
00220     {\cf20 // LED5}\par
00221     GPIO_SetupPinMux(111, GPIO_MUX_CPU1, 0);\par
00222     GPIO_SetupPinOptions(111, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00223     GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;\par
00224 \par
00225     {\cf20 // LED6}\par
00226     GPIO_SetupPinMux(130, GPIO_MUX_CPU1, 0);\par
00227     GPIO_SetupPinOptions(130, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00228     GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;\par
00229 \par
00230     {\cf20 // LED7}\par
00231     GPIO_SetupPinMux(131, GPIO_MUX_CPU1, 0);\par
00232     GPIO_SetupPinOptions(131, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00233     GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;\par
00234 \par
00235     {\cf20 // LED8}\par
00236     GPIO_SetupPinMux(25, GPIO_MUX_CPU1, 0);\par
00237     GPIO_SetupPinOptions(25, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00238     GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;\par
00239 \par
00240     {\cf20 // LED9}\par
00241     GPIO_SetupPinMux(26, GPIO_MUX_CPU1, 0);\par
00242     GPIO_SetupPinOptions(26, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00243     GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;\par
00244 \par
00245     {\cf20 // LED10}\par
00246     GPIO_SetupPinMux(27, GPIO_MUX_CPU1, 0);\par
00247     GPIO_SetupPinOptions(27, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00248     GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;\par
00249 \par
00250     {\cf20 // LED11}\par
00251     GPIO_SetupPinMux(60, GPIO_MUX_CPU1, 0);\par
00252     GPIO_SetupPinOptions(60, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00253     GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;\par
00254 \par
00255     {\cf20 // LED12}\par
00256     GPIO_SetupPinMux(61, GPIO_MUX_CPU1, 0);\par
00257     GPIO_SetupPinOptions(61, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00258     GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;\par
00259 \par
00260     {\cf20 // LED13}\par
00261     GPIO_SetupPinMux(157, GPIO_MUX_CPU1, 0);\par
00262     GPIO_SetupPinOptions(157, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00263     GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;\par
00264 \par
00265     {\cf20 // LED14}\par
00266     GPIO_SetupPinMux(158, GPIO_MUX_CPU1, 0);\par
00267     GPIO_SetupPinOptions(158, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00268     GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;\par
00269 \par
00270     {\cf20 // LED15}\par
00271     GPIO_SetupPinMux(159, GPIO_MUX_CPU1, 0);\par
00272     GPIO_SetupPinOptions(159, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00273     GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;\par
00274 \par
00275     {\cf20 // LED16}\par
00276     GPIO_SetupPinMux(160, GPIO_MUX_CPU1, 0);\par
00277     GPIO_SetupPinOptions(160, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00278     GpioDataRegs.GPFCLEAR.bit.GPIO160 = 1;\par
00279 \par
00280     {\cf20 //WIZNET Reset}\par
00281     GPIO_SetupPinMux(0, GPIO_MUX_CPU1, 0);\par
00282     GPIO_SetupPinOptions(0, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00283     GpioDataRegs.GPASET.bit.GPIO0 = 1;\par
00284 \par
00285     {\cf20 //ESP8266 Reset}\par
00286     GPIO_SetupPinMux(1, GPIO_MUX_CPU1, 0);\par
00287     GPIO_SetupPinOptions(1, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00288     GpioDataRegs.GPASET.bit.GPIO1 = 1;\par
00289 \par
00290     {\cf20 //SPIRAM  CS  Chip Select}\par
00291     GPIO_SetupPinMux(19, GPIO_MUX_CPU1, 0);\par
00292     GPIO_SetupPinOptions(19, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00293     GpioDataRegs.GPASET.bit.GPIO19 = 1;\par
00294 \par
00295     {\cf20 //DRV8874 #1 DIR  Direction}\par
00296     GPIO_SetupPinMux(29, GPIO_MUX_CPU1, 0);\par
00297     GPIO_SetupPinOptions(29, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00298     GpioDataRegs.GPASET.bit.GPIO29 = 1;\par
00299 \par
00300     {\cf20 //DRV8874 #2 DIR  Direction}\par
00301     GPIO_SetupPinMux(32, GPIO_MUX_CPU1, 0);\par
00302     GPIO_SetupPinOptions(32, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00303     GpioDataRegs.GPBSET.bit.GPIO32 = 1;\par
00304 \par
00305     {\cf20 //DAN28027  CS  Chip Select}\par
00306     GPIO_SetupPinMux(9, GPIO_MUX_CPU1, 0);\par
00307     GPIO_SetupPinOptions(9, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00308     GpioDataRegs.GPASET.bit.GPIO9 = 1;\par
00309 \par
00310     {\cf20 //MPU9250  CS  Chip Select}\par
00311     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0);\par
00312     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00313     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
00314 \par
00315     {\cf20 //WIZNET  CS  Chip Select}\par
00316     GPIO_SetupPinMux(125, GPIO_MUX_CPU1, 0);\par
00317     GPIO_SetupPinOptions(125, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00318     GpioDataRegs.GPDSET.bit.GPIO125 = 1;\par
00319 \par
00320     {\cf20 //PushButton 1}\par
00321     GPIO_SetupPinMux(4, GPIO_MUX_CPU1, 0);\par
00322     GPIO_SetupPinOptions(4, GPIO_INPUT, GPIO_PULLUP);\par
00323 \par
00324     {\cf20 //PushButton 2}\par
00325     GPIO_SetupPinMux(5, GPIO_MUX_CPU1, 0);\par
00326     GPIO_SetupPinOptions(5, GPIO_INPUT, GPIO_PULLUP);\par
00327 \par
00328     {\cf20 //PushButton 3}\par
00329     GPIO_SetupPinMux(6, GPIO_MUX_CPU1, 0);\par
00330     GPIO_SetupPinOptions(6, GPIO_INPUT, GPIO_PULLUP);\par
00331 \par
00332     {\cf20 //PushButton 4}\par
00333     GPIO_SetupPinMux(7, GPIO_MUX_CPU1, 0);\par
00334     GPIO_SetupPinOptions(7, GPIO_INPUT, GPIO_PULLUP);\par
00335 \par
00336     {\cf20 //Joy Stick Pushbutton}\par
00337     GPIO_SetupPinMux(8, GPIO_MUX_CPU1, 0);\par
00338     GPIO_SetupPinOptions(8, GPIO_INPUT, GPIO_PULLUP);\par
00339 \par
00340     {\cf20 //Ground GPIO1 Connected to BT CTS Pin}\par
00341     GpioDataRegs.GPACLEAR.bit.GPIO1 = 1;\par
00342 \par
00343     {\cf20 // Clear all interrupts and initialize PIE vector table:}\par
00344     {\cf20 // Disable CPU interrupts}\par
00345     DINT;\par
00346 \par
00347     setupSpib();{\cf20 //run SPI setup code}\par
00348 \par
00349     {\cf20 // Initialize the PIE control registers to their default state.}\par
00350     {\cf20 // The default state is all PIE interrupts disabled and flags}\par
00351     {\cf20 // are cleared.}\par
00352     {\cf20 // This function is found in the F2837xD_PieCtrl.c file.}\par
00353     InitPieCtrl();\par
00354 \par
00355     {\cf20 // Disable CPU interrupts and clear all CPU interrupt flags:}\par
00356     IER = 0x0000;\par
00357     IFR = 0x0000;\par
00358 \par
00359     {\cf20 // Initialize the PIE vector table with pointers to the shell Interrupt}\par
00360     {\cf20 // Service Routines (ISR).}\par
00361     {\cf20 // This will populate the entire table, even if the interrupt}\par
00362     {\cf20 // is not used in this example.  This is useful for debug purposes.}\par
00363     {\cf20 // The shell ISR routines are found in F2837xD_DefaultIsr.c.}\par
00364     {\cf20 // This function is found in F2837xD_PieVect.c.}\par
00365     InitPieVectTable();\par
00366 \par
00367     {\cf20 // Interrupts that are used in this example are re-mapped to}\par
00368     {\cf20 // ISR functions found within this project}\par
00369     EALLOW;  {\cf20 // This is needed to write to EALLOW protected registers}\par
00370     PieVectTable.TIMER0_INT = &cpu_timer0_isr;\par
00371     PieVectTable.TIMER1_INT = &cpu_timer1_isr;\par
00372     PieVectTable.TIMER2_INT = &cpu_timer2_isr;\par
00373     PieVectTable.SCIA_RX_INT = &RXAINT_recv_ready;\par
00374     PieVectTable.SCIC_RX_INT = &RXCINT_recv_ready;\par
00375     PieVectTable.SCID_RX_INT = &RXDINT_recv_ready;\par
00376     PieVectTable.SCIA_TX_INT = &TXAINT_data_sent;\par
00377     PieVectTable.SCIC_TX_INT = &TXCINT_data_sent;\par
00378     PieVectTable.SCID_TX_INT = &TXDINT_data_sent;\par
00379     PieVectTable.SPIB_RX_INT = &SPIB_isr;\par
00380     PieVectTable.ADCA1_INT = &ADCA_ISR;\par
00381     PieVectTable.ADCB1_INT = &ADCB_ISR;\par
00382 \par
00383     PieVectTable.EMIF_ERROR_INT = &SWI_isr;\par
00384     EDIS;    {\cf20 // This is needed to disable write to EALLOW protected registers}\par
00385 \par
00386 \par
00387     {\cf20 // Initialize the CpuTimers Device Peripheral. This function can be}\par
00388     {\cf20 // found in F2837xD_CpuTimers.c}\par
00389     InitCpuTimers();\par
00390 \par
00391     {\cf20 // Configure CPU-Timer 0, 1, and 2 to interrupt every second:}\par
00392     {\cf20 // 200MHz CPU Freq, 1 second Period (in uSeconds)}\par
00393     ConfigCpuTimer(&CpuTimer0, 200, 243500); {\cf20 // 123 bpm}\par
00394     ConfigCpuTimer(&CpuTimer1, 200, 4000);\par
00395     ConfigCpuTimer(&CpuTimer2, 200, 200000);\par
00396 \par
00397     {\cf20 // Enable CpuTimer Interrupt bit TIE}\par
00398     CpuTimer0Regs.TCR.all = 0x4000;\par
00399     CpuTimer1Regs.TCR.all = 0x4000;\par
00400     CpuTimer2Regs.TCR.all = 0x4000;\par
00401 \par
00402     init_serial(&SerialA,115200,serialRXA);\par
00403     init_serial(&SerialC,9600,serialRXC); {\cf20 //set to 9600 for Bluetooth Chip, initializations and muxing done in Serial.c}\par
00404 {\cf20 //    init_serial(&SerialD,115200,serialRXD);}\par
00405 \par
00406     {\cf20 //Use as timer for ADCA}\par
00407     EALLOW;\par
00408     EPwm5Regs.ETSEL.bit.SOCAEN = 0; {\cf20 // Disable SOC on A group}\par
00409     EPwm5Regs.TBCTL.bit.CTRMODE = 3; {\cf20 // freeze counter}\par
00410     EPwm5Regs.ETSEL.bit.SOCASEL = 2; {\cf20 // Select Event when counter equal to PRD}\par
00411     EPwm5Regs.ETPS.bit.SOCAPRD = 1; {\cf20 // Generate pulse on 1st event (\'93pulse\'94 is the same as \'93trigger\'94)}\par
00412     EPwm5Regs.TBCTR = 0x0; {\cf20 // Clear counter}\par
00413     EPwm5Regs.TBPHS.bit.TBPHS = 0x0000; {\cf20 // Phase is 0}\par
00414     EPwm5Regs.TBCTL.bit.PHSEN = 0; {\cf20 // Disable phase loading}\par
00415     EPwm5Regs.TBCTL.bit.CLKDIV = 0; {\cf20 // divide by 1  50Mhz Clock}\par
00416     EPwm5Regs.TBPRD = 50000;  {\cf20 // Set Period to 1ms sample. Rampling rate: 1000 Hz}\par
00417     {\cf20 //(1/50MHz)*TBPRD = .001 s}\par
00418     {\cf20 // Notice here that we are not setting CMPA or CMPB because we are not using the PWM signal}\par
00419     EPwm5Regs.ETSEL.bit.SOCAEN = 1; {\cf20 //enable SOCA}\par
00420     EPwm5Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //unfreeze, and enter up count mode}\par
00421 \par
00422     {\cf20 //PWM9A - Buzzer (Change TBPRD to play song, tempo in Timer0)}\par
00423     EPwm9Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //count up mode}\par
00424     EPwm9Regs.TBCTL.bit.FREE_SOFT = 2; {\cf20 //free run}\par
00425     EPwm9Regs.TBCTL.bit.PHSEN = 0; {\cf20 //disable phase loading}\par
00426     EPwm9Regs.TBCTL.bit.CLKDIV = 1; {\cf20 //clock divide = 2}\par
00427     EPwm9Regs.TBCTR = 0; {\cf20 //start the timers at 0}\par
00428     EPwm9Regs.TBPRD = OFFNOTE;\par
00429 {\cf20 //    EPwm9Regs.CMPA.bit.CMPA = 0; //start duty cycle at 0%}\par
00430     {\cf20 // duty cycle = CMPA/TBPRD}\par
00431     EPwm9Regs.AQCTLA.bit.CAU = 0; {\cf20 //do nothing TBCTR = CMPA (not using compare register)}\par
00432     EPwm9Regs.AQCTLA.bit.ZRO = 3; {\cf20 //toggle when TBCTR resets}\par
00433     EPwm9Regs.TBPHS.bit.TBPHS = 0; {\cf20 //set phase to 0}\par
00434     GPIO_SetupPinMux(16, GPIO_MUX_CPU1, 5); {\cf20 //Buzzer}\par
00435 \par
00436     {\cf20 //use as timer for ADCB}\par
00437     EPwm12Regs.ETSEL.bit.SOCAEN = 0; {\cf20 // Disable SOC on A group}\par
00438     EPwm12Regs.TBCTL.bit.CTRMODE = 3; {\cf20 // freeze counter}\par
00439     EPwm12Regs.ETSEL.bit.SOCASEL = 2; {\cf20 // Select Event when counter equal to PRD}\par
00440     EPwm12Regs.ETPS.bit.SOCAPRD = 1; {\cf20 // Generate pulse on 1st event (\'93pulse\'94 is the same as \'93trigger\'94)}\par
00441     EPwm12Regs.TBCTR = 0x0; {\cf20 // Clear counter}\par
00442     EPwm12Regs.TBPHS.bit.TBPHS = 0x0000; {\cf20 // Phase is 0}\par
00443     EPwm12Regs.TBCTL.bit.PHSEN = 0; {\cf20 // Disable phase loading}\par
00444     EPwm12Regs.TBCTL.bit.CLKDIV = 0; {\cf20 // divide by 1  50Mhz Clock}\par
00445     EPwm12Regs.TBPRD = pwm12prd;  {\cf20 // Set Period to 1 ms sample. fs = 1000 Hz  Input clock is 50MHz.}\par
00446     {\cf20 // Notice here that we are not setting CMPA or CMPB because we are not using the PWM signal}\par
00447     EPwm12Regs.ETSEL.bit.SOCAEN = 1; {\cf20 //enable SOCA}\par
00448     EPwm12Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //unfreeze, and enter up count mode}\par
00449     EDIS;\par
00450 \par
00451     EALLOW;\par
00452     {\cf20 //write configurations for all ADCs  ADCA, ADCB, ADCC, ADCD}\par
00453     AdcaRegs.ADCCTL2.bit.PRESCALE = 6; {\cf20 //set ADCCLK divider to /4}\par
00454     AdcbRegs.ADCCTL2.bit.PRESCALE = 6; {\cf20 //set ADCCLK divider to /4}\par
00455     {\cf20 //        AdccRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00456     {\cf20 //        AdcdRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00457     AdcSetMode(ADC_ADCA, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  {\cf20 //read calibration settings}\par
00458     AdcSetMode(ADC_ADCB, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  {\cf20 //read calibration settings}\par
00459     {\cf20 //        AdcSetMode(ADC_ADCC, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00460     {\cf20 //        AdcSetMode(ADC_ADCD, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00461     {\cf20 //Set pulse positions to late}\par
00462     AdcaRegs.ADCCTL1.bit.INTPULSEPOS = 1;\par
00463     AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1;\par
00464     {\cf20 //        AdccRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00465     {\cf20 //        AdcdRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00466     {\cf20 //power up the ADCs}\par
00467     AdcaRegs.ADCCTL1.bit.ADCPWDNZ = 1;\par
00468     AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1;\par
00469     {\cf20 //        AdccRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00470     {\cf20 //        AdcdRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00471     {\cf20 //delay for 1ms to allow ADC time to power up}\par
00472     DELAY_US(1000);\par
00473 \par
00474 \par
00475     {\cf20 //Select the channels to convert and end of conversion flag}\par
00476     {\cf20 //Many statements commented out,  To be used when using ADCA or ADCB}\par
00477     {\cf20 //ADCA}\par
00478     AdcaRegs.ADCSOC0CTL.bit.CHSEL = 2;  {\cf20 //SOC0 will convert Channel you choose Does not have to be A0}\par
00479     AdcaRegs.ADCSOC0CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00480     AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA will trigger SOC0}\par
00481     AdcaRegs.ADCSOC1CTL.bit.CHSEL = 3;  {\cf20 //SOC1 will convert Channel you choose Does not have to be A1}\par
00482     AdcaRegs.ADCSOC1CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00483     AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC1}\par
00484     AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = 1; {\cf20 //set to last SOC that is converted and it will set INT1 flag ADCA1}\par
00485     AdcaRegs.ADCINTSEL1N2.bit.INT1E = 1;   {\cf20 //enable INT1 flag}\par
00486     AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; {\cf20 //make sure INT1 flag is cleared}\par
00487 \par
00488     {\cf20 //ADCB}\par
00489     AdcbRegs.ADCSOC0CTL.bit.CHSEL = 4;  {\cf20 //SOC0 will convert Channel B4}\par
00490     AdcbRegs.ADCSOC0CTL.bit.ACQPS = 14; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 75ns}\par
00491     AdcbRegs.ADCSOC0CTL.bit.TRIGSEL = 0x1B; {\cf20 // EPWM12 ADCSOCA will trigger SOC0}\par
00492     AdcbRegs.ADCINTSEL1N2.bit.INT1SEL = 0; {\cf20 //set to last SOC that is converted and it will set INT1 flag ADCB1}\par
00493     AdcbRegs.ADCINTSEL1N2.bit.INT1E = 1;   {\cf20 //enable INT1 flag}\par
00494     AdcbRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; {\cf20 //make sure INT1 flag is cleared}\par
00495     EDIS;\par
00496 \par
00497     {\cf20 //2A and 2B - Motors}\par
00498     EPwm2Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //count up mode}\par
00499     EPwm2Regs.TBCTL.bit.FREE_SOFT = 2; {\cf20 //free run}\par
00500     EPwm2Regs.TBCTL.bit.PHSEN = 0; {\cf20 //disable phase loading}\par
00501     EPwm2Regs.TBCTL.bit.CLKDIV = 0; {\cf20 //clock divide = 1}\par
00502     EPwm2Regs.TBCTR = 0; {\cf20 //start the timers at 0}\par
00503     EPwm2Regs.TBPRD = 2500; {\cf20 //set period to 50 microseconds (20 kHz)}\par
00504     {\cf20 // (1/50MHz)*TBPRD = 50 us}\par
00505     EPwm2Regs.CMPA.bit.CMPA = 0; {\cf20 //start duty cycle at 0%}\par
00506     EPwm2Regs.CMPB.bit.CMPB = 0; {\cf20 //start duty cycle at 0%}\par
00507     {\cf20 // duty cycle = CMPA/TBPRD}\par
00508     EPwm2Regs.AQCTLA.bit.CAU = 1; {\cf20 //clear signal when TBCTR = CMPA}\par
00509     EPwm2Regs.AQCTLB.bit.CBU = 1; {\cf20 //clear signal when TBCTR = CMPB}\par
00510     EPwm2Regs.AQCTLA.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00511     EPwm2Regs.AQCTLB.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00512     EPwm2Regs.TBPHS.bit.TBPHS = 0; {\cf20 //set phase to 0}\par
00513     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2A}\par
00514     GPIO_SetupPinMux(3, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2B}\par
00515 \par
00516     init_eQEPs(); {\cf20 //call eQEP setup function}\par
00517 \par
00518     {\cf20 // Enable CPU int1 which is connected to CPU-Timer 0, CPU int13}\par
00519     {\cf20 // which is connected to CPU-Timer 1, and CPU int 14, which is connected}\par
00520     {\cf20 // to CPU-Timer 2:  int 12 is for the SWI.  }\par
00521     IER |= M_INT1;\par
00522     IER |= M_INT8;  {\cf20 // SCIC SCID}\par
00523     IER |= M_INT9;  {\cf20 // SCIA}\par
00524     IER |= M_INT12;\par
00525     IER |= M_INT13;\par
00526     IER |= M_INT14;\par
00527     IER |= M_INT6; {\cf20 //SPI}\par
00528 \par
00529     {\cf20 // Enable TINT0 in the PIE: Group 1 interrupt 7}\par
00530     PieCtrlRegs.PIEIER1.bit.INTx7 = 1;\par
00531     {\cf20 // Enable SWI in the PIE: Group 12 interrupt 9}\par
00532     PieCtrlRegs.PIEIER12.bit.INTx9 = 1;\par
00533     {\cf20 //Enable SPI}\par
00534     PieCtrlRegs.PIEIER6.bit.INTx3 = 1;\par
00535     {\cf20 //Enable ADCA1}\par
00536     PieCtrlRegs.PIEIER1.bit.INTx1 = 1;\par
00537     {\cf20 //Enable ADCB1}\par
00538     PieCtrlRegs.PIEIER1.bit.INTx2 = 1;\par
00539 \par
00540     {\cf20 // Enable global Interrupts and higher priority real-time debug events}\par
00541     EINT;  {\cf20 // Enable Global interrupt INTM}\par
00542     ERTM;  {\cf20 // Enable Global realtime interrupt DBGM}\par
00543 \par
00544 \par
00545     {\cf20 // IDLE loop. Just sit and loop forever (optional):}\par
00546     {\cf19 while}(1)\par
00547     \{\par
00548         {\cf19 if} (UARTPrint == 1 ) \{\par
00549 {\cf20 //            serial_printf(&SerialC,"Num Timer2:%ld Num SerialRX: %ld\\r\\n",CpuTimer2.InterruptCount,numRXA); //prints to BT app}\par
00550 {\cf20 //            serial_printf(&SerialC,"FwdBackOffset: %.2f TurnRate: %.2f\\r\\n",FwdBackOffset, turnrate); //prints to BT app}\par
00551             serial_printf(&SerialA,{\cf22 "X: %.2f Y: %.2f Z: %.2f\\r\\n"},ble_x, ble_y, ble_z);{\cf20 //print acceleration data from phone to tera term}\par
00552             UARTPrint = 0;\par
00553         \}\par
00554        {\cf19 if}(UARTPrint2 == 1)\{\par
00555            serial_printf(&SerialC,{\cf22 "LeftVel: %.2f RightVel: %.2f\\r\\n"},LeftVel, RightVel); {\cf20 //prints to BT app}\par
00556            UARTPrint2 = 0;\par
00557        \}\par
00558 \par
00559        {\cf20 //after n samples, pass data through Goertzel fxn}\par
00560        {\cf20 // use Ping Pong buffer}\par
00561 \par
00562        {\cf19 if}(RunPing == 1)\{\par
00563            goer_result = goertzel_mag(n_samples,NOTE,sampling_rate, adcb_arrayPing);\par
00564            RunPing = 0;\par
00565            {\cf19 if}(goer_result > thresh)\{\par
00566                note_detected = 1;\par
00567            \}\par
00568        \}\par
00569        {\cf19 if}(RunPong == 1)\{\par
00570            goer_result = goertzel_mag(n_samples,NOTE,sampling_rate, adcb_arrayPong);\par
00571            RunPong = 0;\par
00572            {\cf19 if}(goer_result > thresh)\{\par
00573                note_detected = 1;\par
00574            \}\par
00575        \}\par
00576 \par
00577     \}\par
00578 \}\par
00579 \par
00580 \par
00581 {\cf20 // SWI_isr,  Using this interrupt as a Software started interrupt}\par
00582 __interrupt {\cf18 void} SWI_isr({\cf18 void}) \{\par
00583 \par
00584     {\cf20 // These three lines of code allow SWI_isr, to be interrupted by other interrupt functions}\par
00585     {\cf20 // making it lower priority than all other Hardware interrupts.}\par
00586     PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\par
00587     {\cf17 asm}({\cf22 "       NOP"});                    {\cf20 // Wait one cycle}\par
00588     EINT;                                 {\cf20 // Clear INTM to enable interrupts}\par
00589 \par
00590 \par
00591 \par
00592     {\cf20 // Insert SWI ISR Code here.......}\par
00593     {\cf20 //solve for filtered velocity in rads/s}\par
00594     LeftVel = .6*LeftVel_1 + 100*(LeftWheel-LeftWheel_1);\par
00595     RightVel = .6*RightVel_1 + 100*(RightWheel-RightWheel_1);\par
00596 \par
00597     {\cf20 //Turning}\par
00598     WheelDif = LeftWheel - RightWheel;\par
00599     velWheelDif = .33*velWheelDif_1 + .67*(WheelDif-WheelDif_1)/.004;\par
00600     eDif = turnref - WheelDif;\par
00601     {\cf20 //calculate iDif without integral windup}\par
00602     {\cf19 if}(fabs(turn)>3)\{\par
00603         iDif = iDif_1;\par
00604     \}{\cf19 else}\{\par
00605         iDif = iDif_1 + .004*(eDif+eDif_1)/2;\par
00606     \}\par
00607 \par
00608     {\cf20 //Calculate Balance and Turn COntrols}\par
00609     ubal = -K1*tilt_value -K2*gyro_value - K3*(LeftVel+RightVel)/2.0;\par
00610     turn = Kp*eDif + Ki*iDif - Kd*velWheelDif;\par
00611     {\cf20 //saturate turn so balance control dominates (controllefford between +-10)}\par
00612     {\cf19 if}(turn>4)\{\par
00613         turn = 4;\par
00614     \}{\cf19 else} {\cf19 if}(turn<-4)\{\par
00615         turn = -4;\par
00616     \}\par
00617 \par
00618     turnref = turnref_1 + (turnrate + turnrate_1)*.004/2.0;\par
00619 \par
00620     {\cf20 //Calculate controleffort for each motor}\par
00621     uRight = ubal/2.0 - turn + FwdBackOffset;\par
00622     uLeft = ubal/2.0 + turn + FwdBackOffset;\par
00623 \par
00624     {\cf20 //Send ControlEffort to PWM Motor Command}\par
00625     setEPWM2A(uRight);\par
00626     setEPWM2B(-uLeft);\par
00627 \par
00628     {\cf20 //Save Past States}\par
00629     LeftVel_1 = LeftVel;\par
00630     RightVel_1 = RightVel;\par
00631     LeftWheel_1 = LeftWheel;\par
00632     RightWheel_1 = RightWheel;\par
00633     eDif_1 = eDif;\par
00634     iDif_1 = iDif;\par
00635     turnrate_1 = turnrate;\par
00636     turnref_1 = turnref;\par
00637 \par
00638     numSWIcalls++;\par
00639     \par
00640     DINT;\par
00641 \par
00642 \}\par
00643 \par
00644 {\cf20 // cpu_timer0_isr - CPU Timer0 ISR}\par
00645 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void})\par
00646 \{\par
00647     {\cf19 if}(note_detected == 1)\{\par
00648         steeroff = 1; {\cf20 //when the note is detected, stop accepting accelerometer data as steering commands}\par
00649 \par
00650         {\cf20 // Blink a number of LEDS if the Goertzel value exceeds the threshold}\par
00651         GpioDataRegs.GPBTOGGLE.bit.GPIO52 = 1;\par
00652         GpioDataRegs.GPCTOGGLE.bit.GPIO94 = 1;\par
00653         GpioDataRegs.GPDTOGGLE.bit.GPIO97 = 1;\par
00654 \par
00655         {\cf19 if}(numTimer0calls <= songsize)\{\par
00656             {\cf20 //play the song}\par
00657             EPwm9Regs.TBPRD = song[numTimer0calls];\par
00658             {\cf20 //do the dance}\par
00659             FwdBackOffset = 0;\par
00660             turnrate = dance[numTimer0calls];\par
00661             numTimer0calls++; {\cf20 // only increment after note is detected}\par
00662         \}{\cf19 else} {\cf19 if} (numTimer0calls > songsize)\{\par
00663             note_detected = 0;\par
00664             numTimer0calls = 0;\par
00665             turnrate = 0;\par
00666             steeroff = 0; {\cf20 //can now control again with phone}\par
00667         \}\par
00668     \}\par
00669     CpuTimer0.InterruptCount++;\par
00670     {\cf20 // Acknowledge this interrupt to receive more interrupts from group 1}\par
00671     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00672 \}\par
00673 \par
00674 {\cf20 // cpu_timer1_isr - CPU Timer1 ISR}\par
00675 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void})\par
00676 \{\par
00677 \par
00678     CpuTimer1.InterruptCount++;\par
00679 \}\par
00680 \par
00681 {\cf20 // cpu_timer2_isr CPU Timer2 ISR}\par
00682 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void})\par
00683 \{\par
00684 \par
00685     UARTPrint2 = 1; {\cf20 //every 200 ms}\par
00686 \par
00687     CpuTimer2.InterruptCount++;\par
00688 \par
00689 \}\par
00690 \par
00691 {\cf20 // This function is called each time a char is recieved over UARTA.}\par
00692 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data) \{\par
00693     numRXA ++;\par
00694 \}\par
00695 \par
00696 {\cf18 char} sendback[10];\par
00697 {\cf18 char} past[14];\par
00698 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data) \{\par
00699 {\cf20 //    sendback[0] = data;}\par
00700 {\cf20 //    serial_send(&SerialA, sendback, 1); //every character that comes into BT will be echoed to Tera Term}\par
00701 \par
00702     {\cf20 //save past states}\par
00703     past[0] = past[1];\par
00704     past[1] = past[2];\par
00705     past[2] = past[3];\par
00706     past[3] = past[4];\par
00707     past[4] = past[5];\par
00708     past[5] = past[6];\par
00709     past[6] = past[7];\par
00710     past[7] = past[8];\par
00711     past[8] = past[9];\par
00712     past[9] = past[10];\par
00713     past[10] = past[11];\par
00714     past[11] = past[12];\par
00715     past[12] = past[13];\par
00716     past[13] = data;\par
00717 \par
00718     {\cf19 if}(steeroff == 0)\{\par
00719         {\cf20 //use phone accelerometer data to steer}\par
00720         {\cf19 if}((past[0] == {\cf23 '!'})&&(past[1] == {\cf23 'A'}))\{\par
00721             {\cf20 //incoming accelerometer data (arbitrary start point 0)}\par
00722 \par
00723             {\cf20 //float is a 32-bit value (4x8-bit)}\par
00724             {\cf20 //mantissa*2^exp where mantissa takes ~upper 21 bits and ~lower 10 is exponent}\par
00725             {\cf20 //meaning it is not a standard ascii}\par
00726             {\cf20 //create a union}\par
00727             {\cf20 //there will be six 16-bit ints that make up 3 floats}\par
00728             {\cf20 //for a union, takes up same place in memory}\par
00729             {\cf20 //float comes over in 4 8 bit chunks}\par
00730 \par
00731             {\cf20 //X}\par
00732             phoneaccel.rawdata[0] = (past[3]<<8)|past[2];\par
00733             phoneaccel.rawdata[1] = (past[5]<<8)|past[4];\par
00734             {\cf20 //Y}\par
00735             phoneaccel.rawdata[2] = (past[7]<<8)|past[6];\par
00736             phoneaccel.rawdata[3] = (past[9]<<8)|past[8];\par
00737             {\cf20 //Z}\par
00738             phoneaccel.rawdata[4] = (past[11]<<8)|past[10];\par
00739             phoneaccel.rawdata[5] = (past[13]<<8)|past[12];\par
00740 \par
00741             ble_x = phoneaccel.fltdata[0];\par
00742             ble_y = phoneaccel.fltdata[1];\par
00743             ble_z = phoneaccel.fltdata[2];\par
00744 \par
00745             {\cf20 //Interpret phone accel data as steering instructions}\par
00746             {\cf19 if}(ble_y >= 0.3)\{\par
00747                 {\cf20 //turn left}\par
00748     {\cf20 //            turnrate = -2.0;}\par
00749                 turnrate = -4.0;\par
00750             \}{\cf19 else} {\cf19 if}(ble_y <= -0.3)\{\par
00751                 {\cf20 //turn right}\par
00752     {\cf20 //            turnrate = 2.0;}\par
00753                 turnrate = 4.0;\par
00754             \}{\cf19 else} {\cf19 if}(fabs(ble_y) < 0.3)\{\par
00755                 {\cf20 //don't turn}\par
00756                 turnrate = 0;\par
00757             \}\par
00758 \par
00759             {\cf19 if}(ble_z <= -0.3)\{\par
00760                 {\cf20 //go forward}\par
00761                 FwdBackOffset = -1.0;\par
00762             \}{\cf19 else} {\cf19 if}(ble_z >= 0.3)\{\par
00763                 {\cf20 //go backward}\par
00764                 FwdBackOffset = 1.0;\par
00765             \}{\cf19 else} {\cf19 if}(fabs(ble_z) < 0.3)\{\par
00766                 {\cf20 //don't go forward or backward}\par
00767                 FwdBackOffset = 0;\par
00768             \}\par
00769 \par
00770             UARTPrint = 1;\par
00771         \}\par
00772     \}\par
00773 \par
00774 \}\par
00775 \par
00776 __interrupt {\cf18 void} ADCA_ISR({\cf18 void})\{\par
00777         adca0result = AdcaResultRegs.ADCRESULT0; {\cf20 //read ADC values}\par
00778         adca1result = AdcaResultRegs.ADCRESULT1;\par
00779 \par
00780         {\cf20 // Here covert ADCIND0, ADCIND1 to volts}\par
00781         adca0_volts = adca0result/1365.0;\par
00782         adca1_volts = adca1result/1365.0;\par
00783 \par
00784         {\cf20 //SPI Read Gyros and Accelerometers}\par
00785 \par
00786         GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00787         SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 // Issue the SPIB_RX_INT when two values are in the RX FIFO}\par
00788 \par
00789         {\cf20 //write to TXBUF}\par
00790         SpibRegs.SPITXBUF = 0x8000|0x3A00; {\cf20 //start address (one register before accel)}\par
00791         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_XOUT}\par
00792         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_YOUT}\par
00793         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_ZOUT}\par
00794         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read TEMP_OUT}\par
00795         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_XOUT}\par
00796         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_YOUT}\par
00797         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_ZOUT}\par
00798 \par
00799         AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;  {\cf20 //clear interrupt flag}\par
00800         PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00801 \}\par
00802 \par
00803 __interrupt {\cf18 void} SPIB_isr({\cf18 void})\{\par
00804 \par
00805     {\cf20 //read from RX FIFO}\par
00806     Junk = SpibRegs.SPIRXBUF; {\cf20 //garbage value read}\par
00807     accelxraw = SpibRegs.SPIRXBUF;\par
00808     accelyraw = SpibRegs.SPIRXBUF;\par
00809     accelzraw = SpibRegs.SPIRXBUF;\par
00810     Junk = SpibRegs.SPIRXBUF;\par
00811     gyroxraw = SpibRegs.SPIRXBUF;\par
00812     gyroyraw = SpibRegs.SPIRXBUF;\par
00813     gyrozraw = SpibRegs.SPIRXBUF;\par
00814 \par
00815     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00816 \par
00817     accelx = (float)(accelxraw*4.0/32767.0); {\cf20 // m/s2, this value is saturated due to offset}\par
00818     accely = (float)(accelyraw*4.0/32767.0); {\cf20 // m/s2}\par
00819     accelz = (float)(accelzraw*4.0/32767.0); {\cf20 // m/s2}\par
00820     gyrox = (float)(gyroxraw*250.0/32767.0); {\cf20 //deg per second}\par
00821     gyroy = (float)(gyroyraw*250.0/32767.0); {\cf20 //deg per second}\par
00822     gyroz = (float)(gyrozraw*250.0/32767.0); {\cf20 //deg per second}\par
00823 \par
00824     {\cf20 //Code to be copied into SPIB_ISR interrupt function after the IMU measurements have been collected.}\par
00825       {\cf19 if}(calibration_state == 0)\{\par
00826             calibration_count++;\par
00827             {\cf19 if} (calibration_count == 2000) \{\par
00828                 calibration_state = 1;\par
00829                 calibration_count = 0;\par
00830             \}\par
00831         \} {\cf19 else} {\cf19 if}(calibration_state == 1)\{\par
00832             accelx_offset+=accelx;\par
00833             accely_offset+=accely;\par
00834             accelz_offset+=accelz;\par
00835             gyrox_offset+=gyrox;\par
00836             gyroy_offset+=gyroy;\par
00837             gyroz_offset+=gyroz;\par
00838             calibration_count++;\par
00839             {\cf19 if} (calibration_count == 2000) \{\par
00840                 calibration_state = 2;\par
00841                 accelx_offset/=2000.0;\par
00842                 accely_offset/=2000.0;\par
00843                 accelz_offset/=2000.0;\par
00844                 gyrox_offset/=2000.0;\par
00845                 gyroy_offset/=2000.0;\par
00846                 gyroz_offset/=2000.0;\par
00847                 calibration_count = 0;\par
00848                 doneCal = 1;\par
00849             \}\par
00850 \par
00851         \} {\cf19 else} {\cf19 if}(calibration_state == 2)\{\par
00852 \par
00853             accelx -=(accelx_offset);\par
00854             accely -=(accely_offset);\par
00855             accelz -=(accelz_offset-accelzBalancePoint);\par
00856             gyrox -= gyrox_offset;\par
00857             gyroy -= gyroy_offset;\par
00858             gyroz -= gyroz_offset;\par
00859 \par
00860             {\cf20 /*--------------Kalman Filtering code start---------------------------------------------------------------------*/}\par
00861             {\cf18 float} tiltrate = (gyrox*PI)/180.0; {\cf20 // rad/s}\par
00862             {\cf18 float} pred_tilt, z, y, S;\par
00863 \par
00864             {\cf20 // Prediction Step}\par
00865             pred_tilt = kalman_tilt + T*tiltrate;\par
00866             pred_P = kalman_P + Q;\par
00867 \par
00868             {\cf20 // Update Step}\par
00869             z = -accelz;  {\cf20 // Note the negative here due to the polarity of AccelZ}\par
00870             y = z - pred_tilt;\par
00871             S = pred_P + R;\par
00872             kalman_K = pred_P/S;\par
00873             kalman_tilt = pred_tilt + kalman_K*y;\par
00874             kalman_P = (1 - kalman_K)*pred_P;\par
00875 \par
00876             SpibNumCalls++;\par
00877             {\cf20 // Kalman Filter used}\par
00878             tilt_array[SpibNumCalls] = kalman_tilt;\par
00879             gyro_array[SpibNumCalls] = tiltrate;\par
00880             LeftWheelArray[SpibNumCalls] = -readEncLeft();\par
00881             RightWheelArray[SpibNumCalls] = readEncRight();\par
00882 \par
00883             {\cf19 if} (SpibNumCalls >= 3) \{  {\cf20 // should never be greater than 3}\par
00884                 tilt_value = (tilt_array[0] + tilt_array[1] + tilt_array[2] + tilt_array[3])/4.0;\par
00885                 gyro_value = (gyro_array[0] + gyro_array[1] + gyro_array[2] + gyro_array[3])/4.0;\par
00886                 LeftWheel=(LeftWheelArray[0]+LeftWheelArray[1]+LeftWheelArray[2]+LeftWheelArray[3])/4.0;\par
00887                 RightWheel=(RightWheelArray[0]+RightWheelArray[1]+RightWheelArray[2]+RightWheelArray[3])/4.0;\par
00888                 SpibNumCalls = -1;\par
00889 \par
00890                 PieCtrlRegs.PIEIFR12.bit.INTx9 = 1;  {\cf20 // Manually cause the interrupt for the SWI}\par
00891             \}\par
00892         \}\par
00893 \par
00894         timecount++;\par
00895 \par
00896         {\cf19 if}((timecount%200) == 0)\par
00897         \{\par
00898             {\cf19 if}(doneCal == 0) \{\par
00899                 GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;  {\cf20 // Blink Blue LED while calibrating}\par
00900             \}\par
00901             GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;  {\cf20 // Always Block Red LED}\par
00902 \par
00903 {\cf20 //            UARTPrint = 1;  // Tell While loop to print}\par
00904         \}\par
00905 \par
00906         SpibRegs.SPIFFRX.bit.RXFFOVFCLR=1;  {\cf20 // Clear Overflow flag}\par
00907         SpibRegs.SPIFFRX.bit.RXFFINTCLR=1;  {\cf20 // Clear Interrupt flag}\par
00908         PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
00909 \}\par
00910 \par
00911 __interrupt {\cf18 void} ADCB_ISR ({\cf18 void})\par
00912 \{\par
00913     adcb0result = AdcbResultRegs.ADCRESULT0; {\cf20 //read value between 0 and 4095 from ADC}\par
00914     {\cf20 //MAX9814 sensitivity = -44 dBV meaning the signal corresponds to 6.3096mV/Pa of sound pressure}\par
00915     {\cf20 //ADC values 0 to 4095 correspond to voltages 0-3V, mic produces 0.5 to 2.5 V (values ~682 to ~3412)}\par
00916 \par
00917     {\cf20 //Ping}\par
00918     {\cf19 if}(PingPong == 0)\{\par
00919         adcb_arrayPing[adcbcount] = adcb0result; {\cf20 // add ADC reading to array}\par
00920         {\cf19 if}(adcbcount == (n_samples-1))\{\par
00921             adcbcount = -1; {\cf20 //incremented to 0 at end of interrupt}\par
00922             RunPing = 1; {\cf20 //check in while loop}\par
00923             PingPong = 1; {\cf20 //switch to Pong buffer}\par
00924         \}\par
00925     \}\par
00926     {\cf20 //Pong}\par
00927     {\cf19 if}(PingPong == 1)\{\par
00928         adcb_arrayPong[adcbcount] = adcb0result;\par
00929         {\cf19 if}(adcbcount == (n_samples-1))\{\par
00930             adcbcount = -1; {\cf20 //incremented to 0 at end of interrupt}\par
00931             RunPong = 1;\par
00932             PingPong = 0; {\cf20 //switch to Pong buffer}\par
00933         \}\par
00934     \}\par
00935 \par
00936     adcbcount++; {\cf20 //increment count}\par
00937     AdcbRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;  {\cf20 //clear interrupt flag}\par
00938     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; {\cf20 //clear PIE peripheral so processor waits until next interrupt flag}\par
00939 \}\par
00940 \par
00941 {\cf18 float} readEncLeft({\cf18 void}) \{\par
00942     int32_t raw = 0;\par
00943     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U}\par
00944 \par
00945     raw = EQep1Regs.QPOSCNT;\par
00946     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00947 \par
00948     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00949     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00950     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00951     {\cf19 return} (raw*(TWOPI/600.0)); {\cf20 //wheel rotation in radians}\par
00952 \}\par
00953 \par
00954 {\cf18 float} readEncRight({\cf18 void}) \{\par
00955 \par
00956     int32_t raw = 0;\par
00957     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U  -1 32bit signed int}\par
00958 \par
00959     raw = EQep2Regs.QPOSCNT;\par
00960     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00961 \par
00962     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00963     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00964     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00965     {\cf19 return} (raw*(TWOPI/600.0));\par
00966 \}\par
00967 \par
00968 {\cf18 void} init_eQEPs({\cf18 void}) \{\par
00969 \par
00970     {\cf20 // setup eQEP1 pins for input}\par
00971     EALLOW;\par
00972     {\cf20 //Disable internal pull-up for the selected output pins for reduced power consumption}\par
00973     GpioCtrlRegs.GPAPUD.bit.GPIO20 = 1;    {\cf20 // Disable pull-up on GPIO20 (EQEP1A)}\par
00974     GpioCtrlRegs.GPAPUD.bit.GPIO21 = 1;    {\cf20 // Disable pull-up on GPIO21 (EQEP1B)}\par
00975     GpioCtrlRegs.GPAQSEL2.bit.GPIO20 = 2;   {\cf20 // Qual every 6 samples}\par
00976     GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 2;   {\cf20 // Qual every 6 samples}\par
00977     EDIS;\par
00978     {\cf20 // This specifies which of the possible GPIO pins will be EQEP1 functional pins.}\par
00979     {\cf20 // Comment out other unwanted lines.}\par
00980     GPIO_SetupPinMux(20, GPIO_MUX_CPU1, 1);\par
00981     GPIO_SetupPinMux(21, GPIO_MUX_CPU1, 1);\par
00982     EQep1Regs.QEPCTL.bit.QPEN = 0;    {\cf20 // make sure eqep in reset}\par
00983     EQep1Regs.QDECCTL.bit.QSRC = 0;   {\cf20 // Quadrature count mode}\par
00984     EQep1Regs.QPOSCTL.all = 0x0;      {\cf20 // Disable eQep Position Compare}\par
00985     EQep1Regs.QCAPCTL.all = 0x0;      {\cf20 // Disable eQep Capture}\par
00986     EQep1Regs.QEINT.all = 0x0;        {\cf20 // Disable all eQep interrupts}\par
00987     EQep1Regs.QPOSMAX = 0xFFFFFFFF;   {\cf20 // use full range of the 32 bit count}\par
00988     EQep1Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend in Code Composer}\par
00989     EQep1Regs.QPOSCNT = 0;\par
00990     EQep1Regs.QEPCTL.bit.QPEN = 1;    {\cf20 // Enable EQep}\par
00991 \par
00992 \par
00993     {\cf20 // setup QEP2 pins for input}\par
00994     EALLOW;\par
00995     {\cf20 //Disable internal pull-up for the selected output pinsfor reduced power consumption}\par
00996     GpioCtrlRegs.GPBPUD.bit.GPIO54 = 1;    {\cf20 // Disable pull-up on GPIO54 (EQEP2A)}\par
00997     GpioCtrlRegs.GPBPUD.bit.GPIO55 = 1;    {\cf20 // Disable pull-up on GPIO55 (EQEP2B)}\par
00998     GpioCtrlRegs.GPBQSEL2.bit.GPIO54 = 2;   {\cf20 // Qual every 6 samples}\par
00999     GpioCtrlRegs.GPBQSEL2.bit.GPIO55 = 2;   {\cf20 // Qual every 6 samples}\par
01000     EDIS;\par
01001 ...\par
01002 \par
01003 This file has been truncated, please download it to see its full contents.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
song.h File Reference\par \pard\plain 
{\tc\tcl2 \v song.h}
{\xe \v song.h}
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FUDGEFACTORNOTE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b C4NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/261.63))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b D4NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/293.66))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b E4NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/329.63))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F4NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/349.23))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b G4NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/392.00))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b A4NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/440.00))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b B4NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/493.88))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b C5NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/523.25))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b D5NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/587.33))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b E5NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/659.25))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F5NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/698.46))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b G5NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/783.99))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b A5NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/880.00))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b B5NOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/987.77))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F4SHARPNOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/369.99))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b G4SHARPNOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/415.3))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b A4FLATNOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/415.3))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b C5SHARPNOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/554.37))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b A5FLATNOTE}\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/830.61))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OFFNOTE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SONG_LENGTH}\~ 516\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b songarray} [{\b SONG_LENGTH}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v A4FLATNOTE\:song.h}
{\xe \v song.h\:A4FLATNOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define A4FLATNOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/415.3))}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b song.h}.}\par
}
{\xe \v A4NOTE\:song.h}
{\xe \v song.h\:A4NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define A4NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/440.00))}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b song.h}.}\par
}
{\xe \v A5FLATNOTE\:song.h}
{\xe \v song.h\:A5FLATNOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define A5FLATNOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/830.61))}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b song.h}.}\par
}
{\xe \v A5NOTE\:song.h}
{\xe \v song.h\:A5NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define A5NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/880.00))}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b song.h}.}\par
}
{\xe \v B4NOTE\:song.h}
{\xe \v song.h\:B4NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define B4NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/493.88))}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b song.h}.}\par
}
{\xe \v B5NOTE\:song.h}
{\xe \v song.h\:B5NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define B5NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/987.77))}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b song.h}.}\par
}
{\xe \v C4NOTE\:song.h}
{\xe \v song.h\:C4NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define C4NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/261.63))}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b song.h}.}\par
}
{\xe \v C5NOTE\:song.h}
{\xe \v song.h\:C5NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define C5NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/523.25))}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b song.h}.}\par
}
{\xe \v C5SHARPNOTE\:song.h}
{\xe \v song.h\:C5SHARPNOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define C5SHARPNOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/554.37))}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b song.h}.}\par
}
{\xe \v D4NOTE\:song.h}
{\xe \v song.h\:D4NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define D4NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/293.66))}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b song.h}.}\par
}
{\xe \v D5NOTE\:song.h}
{\xe \v song.h\:D5NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define D5NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/587.33))}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b song.h}.}\par
}
{\xe \v E4NOTE\:song.h}
{\xe \v song.h\:E4NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define E4NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/329.63))}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b song.h}.}\par
}
{\xe \v E5NOTE\:song.h}
{\xe \v song.h\:E5NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define E5NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/659.25))}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b song.h}.}\par
}
{\xe \v F4NOTE\:song.h}
{\xe \v song.h\:F4NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F4NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/349.23))}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b song.h}.}\par
}
{\xe \v F4SHARPNOTE\:song.h}
{\xe \v song.h\:F4SHARPNOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F4SHARPNOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/369.99))}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b song.h}.}\par
}
{\xe \v F5NOTE\:song.h}
{\xe \v song.h\:F5NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F5NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/698.46))}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b song.h}.}\par
}
{\xe \v FUDGEFACTORNOTE\:song.h}
{\xe \v song.h\:FUDGEFACTORNOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FUDGEFACTORNOTE\~ 1}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b song.h}.}\par
}
{\xe \v G4NOTE\:song.h}
{\xe \v song.h\:G4NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define G4NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/392.00))}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b song.h}.}\par
}
{\xe \v G4SHARPNOTE\:song.h}
{\xe \v song.h\:G4SHARPNOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define G4SHARPNOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/415.3))}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b song.h}.}\par
}
{\xe \v G5NOTE\:song.h}
{\xe \v song.h\:G5NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define G5NOTE\~ ((uint16_t)((({\b FUDGEFACTORNOTE}*50000000/2)/2)/783.99))}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b song.h}.}\par
}
{\xe \v OFFNOTE\:song.h}
{\xe \v song.h\:OFFNOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OFFNOTE\~ 1}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b song.h}.}\par
}
{\xe \v SONG_LENGTH\:song.h}
{\xe \v song.h\:SONG_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SONG_LENGTH\~ 516}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b song.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v songarray\:song.h}
{\xe \v song.h\:songarray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t songarray[{\b SONG_LENGTH}]}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b song.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
song.h\par \pard\plain 
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #define FUDGEFACTORNOTE 1}\par
00002 {\cf21 #define C4NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/261.63))}\par
00003 {\cf21 #define D4NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/293.66))}\par
00004 {\cf21 #define E4NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/329.63))}\par
00005 {\cf21 #define F4NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/349.23))}\par
00006 {\cf21 #define G4NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/392.00))}\par
00007 {\cf21 #define A4NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/440.00))}\par
00008 {\cf21 #define B4NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/493.88))}\par
00009 {\cf21 #define C5NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/523.25))}\par
00010 {\cf21 #define D5NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/587.33))}\par
00011 {\cf21 #define E5NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/659.25))}\par
00012 {\cf21 #define F5NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/698.46))}\par
00013 {\cf21 #define G5NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/783.99))}\par
00014 {\cf21 #define A5NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/880.00))}\par
00015 {\cf21 #define B5NOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/987.77))}\par
00016 {\cf21 #define F4SHARPNOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/369.99))}\par
00017 {\cf21 #define G4SHARPNOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/415.3))}\par
00018 {\cf21 #define A4FLATNOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/415.3))}\par
00019 {\cf21 #define C5SHARPNOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/554.37))}\par
00020 {\cf21 #define A5FLATNOTE ((uint16_t)(((FUDGEFACTORNOTE*50000000/2)/2)/830.61))}\par
00021 \par
00022 \par
00023 {\cf21 #define OFFNOTE 1}\par
00024 \par
00025 {\cf21 #define SONG_LENGTH 516}\par
00026 uint16_t songarray[SONG_LENGTH] = \{\par
00027 A4NOTE,\par
00028 A4NOTE,\par
00029 G4NOTE,\par
00030 A4NOTE,\par
00031 A4NOTE,\par
00032 C5NOTE,\par
00033 B4NOTE,\par
00034 B4NOTE,\par
00035 E4NOTE,\par
00036 F4NOTE,\par
00037 F4NOTE,\par
00038 E4NOTE,\par
00039 A4NOTE,\par
00040 A4NOTE,\par
00041 C5NOTE,\par
00042 B4NOTE,\par
00043 B4NOTE,\par
00044 G4NOTE,\par
00045 A4NOTE,\par
00046 A4NOTE,\par
00047 B4NOTE,\par
00048 B4NOTE,\par
00049 C5NOTE,\par
00050 C5NOTE,\par
00051 A4NOTE,\par
00052 A4NOTE,\par
00053 G4NOTE,\par
00054 A4NOTE,\par
00055 A4NOTE,\par
00056 C5NOTE,\par
00057 B4NOTE,\par
00058 B4NOTE,\par
00059 E4NOTE,\par
00060 F4NOTE,\par
00061 F4NOTE,\par
00062 E4NOTE,\par
00063 A4NOTE,\par
00064 A4NOTE,\par
00065 C5NOTE,\par
00066 C5NOTE,\par
00067 B4NOTE,\par
00068 B4NOTE,\par
00069 A4NOTE,\par
00070 A4NOTE,\par
00071 F4NOTE,\par
00072 F4NOTE,\par
00073 E4NOTE,\par
00074 E4NOTE,\par
00075 F4NOTE,\par
00076 F4NOTE,\par
00077 D4NOTE,\par
00078 F4NOTE,\par
00079 F4NOTE,\par
00080 A4NOTE,\par
00081 G4SHARPNOTE,\par
00082 G4SHARPNOTE,\par
00083 E4NOTE,\par
00084 F4NOTE,\par
00085 F4NOTE,\par
00086 E4NOTE,\par
00087 F4NOTE,\par
00088 F4NOTE,\par
00089 C5NOTE,\par
00090 C5NOTE,\par
00091 B4NOTE,\par
00092 B4NOTE,\par
00093 E4NOTE,\par
00094 E4NOTE,\par
00095 F4NOTE,\par
00096 E4NOTE,\par
00097 E4NOTE,\par
00098 G4SHARPNOTE,\par
00099 A4NOTE,\par
00100 A4NOTE,\par
00101 G4NOTE,\par
00102 A4NOTE,\par
00103 A4NOTE,\par
00104 C5NOTE,\par
00105 B4NOTE,\par
00106 B4NOTE,\par
00107 E4NOTE,\par
00108 F4NOTE,\par
00109 F4NOTE,\par
00110 E4NOTE,\par
00111 A4NOTE,\par
00112 A4NOTE,\par
00113 C5NOTE,\par
00114 B4NOTE,\par
00115 B4NOTE,\par
00116 G4NOTE,\par
00117 A4NOTE,\par
00118 A4NOTE,\par
00119 B4NOTE,\par
00120 B4NOTE,\par
00121 C5NOTE,\par
00122 C5NOTE,\par
00123 A4NOTE,\par
00124 A4NOTE,\par
00125 G4NOTE,\par
00126 A4NOTE,\par
00127 A4NOTE,\par
00128 C5NOTE,\par
00129 B4NOTE,\par
00130 B4NOTE,\par
00131 E4NOTE,\par
00132 F4NOTE,\par
00133 F4NOTE,\par
00134 E4NOTE,\par
00135 A4NOTE,\par
00136 A4NOTE,\par
00137 C5NOTE,\par
00138 C5NOTE,\par
00139 B4NOTE,\par
00140 B4NOTE,\par
00141 A4NOTE,\par
00142 A4NOTE,\par
00143 F4NOTE,\par
00144 F4NOTE,\par
00145 E4NOTE,\par
00146 E4NOTE,\par
00147 F4NOTE,\par
00148 F4NOTE,\par
00149 D4NOTE,\par
00150 F4NOTE,\par
00151 F4NOTE,\par
00152 A4NOTE,\par
00153 G4SHARPNOTE,\par
00154 G4SHARPNOTE,\par
00155 E4NOTE,\par
00156 F4NOTE,\par
00157 F4NOTE,\par
00158 E4NOTE,\par
00159 F4NOTE,\par
00160 F4NOTE,\par
00161 C5NOTE,\par
00162 C5NOTE,\par
00163 B4NOTE,\par
00164 B4NOTE,\par
00165 E4NOTE,\par
00166 E4NOTE,\par
00167 F4NOTE,\par
00168 E4NOTE,\par
00169 E4NOTE,\par
00170 G4SHARPNOTE,\par
00171 A4NOTE,\par
00172 A4NOTE,\par
00173 A4NOTE,\par
00174 A4NOTE,\par
00175 A4NOTE,\par
00176 A4NOTE,\par
00177 A5NOTE,\par
00178 A5NOTE,\par
00179 A5NOTE,\par
00180 A5NOTE,\par
00181 A5NOTE,\par
00182 A5NOTE,\par
00183 A5FLATNOTE,\par
00184 A5FLATNOTE,\par
00185 E5NOTE,\par
00186 F5NOTE,\par
00187 F5NOTE,\par
00188 D5NOTE,\par
00189 E5NOTE,\par
00190 E5NOTE,\par
00191 C5NOTE,\par
00192 D5NOTE,\par
00193 D5NOTE,\par
00194 B4NOTE,\par
00195 A4NOTE,\par
00196 A4NOTE,\par
00197 A4NOTE,\par
00198 A4NOTE,\par
00199 A4NOTE,\par
00200 A4NOTE,\par
00201 A5NOTE,\par
00202 A5NOTE,\par
00203 A5NOTE,\par
00204 A5NOTE,\par
00205 A5NOTE,\par
00206 A5NOTE,\par
00207 A5FLATNOTE,\par
00208 A5FLATNOTE,\par
00209 E5NOTE,\par
00210 F5NOTE,\par
00211 F5NOTE,\par
00212 A5NOTE,\par
00213 A5FLATNOTE,\par
00214 A5FLATNOTE,\par
00215 E5NOTE,\par
00216 D5NOTE,\par
00217 C5NOTE,\par
00218 B4NOTE,\par
00219 A4NOTE,\par
00220 A4NOTE,\par
00221 A4NOTE,\par
00222 A4NOTE,\par
00223 A4NOTE,\par
00224 A4NOTE,\par
00225 C5NOTE,\par
00226 C5NOTE,\par
00227 C5NOTE,\par
00228 C5NOTE,\par
00229 C5NOTE,\par
00230 C5NOTE,\par
00231 B4NOTE,\par
00232 B4NOTE,\par
00233 B4NOTE,\par
00234 B4NOTE,\par
00235 B4NOTE,\par
00236 B4NOTE,\par
00237 E4NOTE,\par
00238 E4NOTE,\par
00239 E4NOTE,\par
00240 E4NOTE,\par
00241 E4NOTE,\par
00242 E4NOTE,\par
00243 F4NOTE,\par
00244 F4NOTE,\par
00245 F4NOTE,\par
00246 F4NOTE,\par
00247 F4NOTE,\par
00248 F4NOTE,\par
00249 A4NOTE,\par
00250 A4NOTE,\par
00251 A4NOTE,\par
00252 C5NOTE,\par
00253 C5NOTE,\par
00254 C5NOTE,\par
00255 B4NOTE,\par
00256 B4NOTE,\par
00257 B4NOTE,\par
00258 A4NOTE,\par
00259 A4NOTE,\par
00260 A4NOTE,\par
00261 A4FLATNOTE,\par
00262 A4FLATNOTE,\par
00263 A4FLATNOTE,\par
00264 E4NOTE,\par
00265 E4NOTE,\par
00266 E4NOTE,\par
00267 A4NOTE,\par
00268 A4NOTE,\par
00269 A4NOTE,\par
00270 OFFNOTE,\par
00271 OFFNOTE,\par
00272 OFFNOTE,\par
00273 A4FLATNOTE,\par
00274 A4FLATNOTE,\par
00275 A4FLATNOTE,\par
00276 OFFNOTE,\par
00277 A4NOTE,\par
00278 A4NOTE,\par
00279 A4NOTE,\par
00280 A4NOTE,\par
00281 A4NOTE,\par
00282 OFFNOTE,\par
00283 OFFNOTE,\par
00284 OFFNOTE,\par
00285 A4FLATNOTE,\par
00286 A4FLATNOTE,\par
00287 A4FLATNOTE,\par
00288 OFFNOTE,\par
00289 A4NOTE,\par
00290 A4NOTE,\par
00291 A4NOTE,\par
00292 A4NOTE,\par
00293 A4NOTE,\par
00294 A4FLATNOTE,\par
00295 A4FLATNOTE,\par
00296 A4NOTE,\par
00297 A4NOTE,\par
00298 A4NOTE,\par
00299 A4NOTE,\par
00300 A4FLATNOTE,\par
00301 A4FLATNOTE,\par
00302 A4NOTE,\par
00303 A4NOTE,\par
00304 A4NOTE,\par
00305 A4NOTE,\par
00306 A4NOTE,\par
00307 A4NOTE,\par
00308 A4NOTE,\par
00309 E5NOTE,\par
00310 E5NOTE,\par
00311 E5NOTE,\par
00312 E5NOTE,\par
00313 E5NOTE,\par
00314 E5NOTE,\par
00315 A5NOTE,\par
00316 A5NOTE,\par
00317 A5NOTE,\par
00318 A5NOTE,\par
00319 A5NOTE,\par
00320 A5NOTE,\par
00321 A5NOTE,\par
00322 A5NOTE,\par
00323 A5NOTE,\par
00324 OFFNOTE,\par
00325 OFFNOTE,\par
00326 OFFNOTE,\par
00327 OFFNOTE,\par
00328 OFFNOTE,\par
00329 OFFNOTE,\par
00330 OFFNOTE,\par
00331 OFFNOTE,\par
00332 OFFNOTE,\par
00333 OFFNOTE,\par
00334 OFFNOTE,\par
00335 E4NOTE,\par
00336 OFFNOTE,\par
00337 E4NOTE,\par
00338 OFFNOTE,\par
00339 F4SHARPNOTE,\par
00340 F4SHARPNOTE,\par
00341 F4SHARPNOTE,\par
00342 F4SHARPNOTE,\par
00343 E4NOTE,\par
00344 E4NOTE,\par
00345 E4NOTE,\par
00346 E4NOTE,\par
00347 A4NOTE,\par
00348 A4NOTE,\par
00349 A4NOTE,\par
00350 A4NOTE,\par
00351 G4SHARPNOTE,\par
00352 G4SHARPNOTE,\par
00353 G4SHARPNOTE,\par
00354 G4SHARPNOTE,\par
00355 G4SHARPNOTE,\par
00356 G4SHARPNOTE,\par
00357 G4SHARPNOTE,\par
00358 G4SHARPNOTE,\par
00359 E4NOTE,\par
00360 OFFNOTE,\par
00361 E4NOTE,\par
00362 OFFNOTE,\par
00363 F4SHARPNOTE,\par
00364 F4SHARPNOTE,\par
00365 F4SHARPNOTE,\par
00366 F4SHARPNOTE,\par
00367 E4NOTE,\par
00368 E4NOTE,\par
00369 E4NOTE,\par
00370 E4NOTE,\par
00371 B4NOTE,\par
00372 B4NOTE,\par
00373 B4NOTE,\par
00374 B4NOTE,\par
00375 A4NOTE,\par
00376 A4NOTE,\par
00377 A4NOTE,\par
00378 A4NOTE,\par
00379 A4NOTE,\par
00380 A4NOTE,\par
00381 A4NOTE,\par
00382 A4NOTE,\par
00383 E4NOTE,\par
00384 OFFNOTE,\par
00385 E4NOTE,\par
00386 OFFNOTE,\par
00387 E5NOTE,\par
00388 E5NOTE,\par
00389 E5NOTE,\par
00390 E5NOTE,\par
00391 C5SHARPNOTE,\par
00392 C5SHARPNOTE,\par
00393 C5SHARPNOTE,\par
00394 C5SHARPNOTE,\par
00395 A4NOTE,\par
00396 A4NOTE,\par
00397 A4NOTE,\par
00398 A4NOTE,\par
00399 G4SHARPNOTE,\par
00400 G4SHARPNOTE,\par
00401 G4SHARPNOTE,\par
00402 G4SHARPNOTE,\par
00403 F4SHARPNOTE,\par
00404 F4SHARPNOTE,\par
00405 F4SHARPNOTE,\par
00406 F4SHARPNOTE,\par
00407 D5NOTE,\par
00408 OFFNOTE,\par
00409 D5NOTE,\par
00410 OFFNOTE,\par
00411 C5SHARPNOTE,\par
00412 C5SHARPNOTE,\par
00413 C5SHARPNOTE,\par
00414 C5SHARPNOTE,\par
00415 A4NOTE,\par
00416 A4NOTE,\par
00417 A4NOTE,\par
00418 A4NOTE,\par
00419 B4NOTE,\par
00420 B4NOTE,\par
00421 B4NOTE,\par
00422 B4NOTE,\par
00423 A4NOTE,\par
00424 A4NOTE,\par
00425 A4NOTE,\par
00426 A4NOTE,\par
00427 A4NOTE,\par
00428 A4NOTE,\par
00429 A4NOTE,\par
00430 A4NOTE,\par
00431 E4NOTE,\par
00432 OFFNOTE,\par
00433 E4NOTE,\par
00434 OFFNOTE,\par
00435 F4SHARPNOTE,\par
00436 F4SHARPNOTE,\par
00437 F4SHARPNOTE,\par
00438 F4SHARPNOTE,\par
00439 E4NOTE,\par
00440 E4NOTE,\par
00441 E4NOTE,\par
00442 E4NOTE,\par
00443 A4NOTE,\par
00444 A4NOTE,\par
00445 A4NOTE,\par
00446 A4NOTE,\par
00447 G4SHARPNOTE,\par
00448 G4SHARPNOTE,\par
00449 G4SHARPNOTE,\par
00450 G4SHARPNOTE,\par
00451 G4SHARPNOTE,\par
00452 G4SHARPNOTE,\par
00453 G4SHARPNOTE,\par
00454 G4SHARPNOTE,\par
00455 E4NOTE,\par
00456 OFFNOTE,\par
00457 E4NOTE,\par
00458 OFFNOTE,\par
00459 F4SHARPNOTE,\par
00460 F4SHARPNOTE,\par
00461 F4SHARPNOTE,\par
00462 F4SHARPNOTE,\par
00463 E4NOTE,\par
00464 E4NOTE,\par
00465 E4NOTE,\par
00466 E4NOTE,\par
00467 B4NOTE,\par
00468 B4NOTE,\par
00469 B4NOTE,\par
00470 B4NOTE,\par
00471 A4NOTE,\par
00472 A4NOTE,\par
00473 A4NOTE,\par
00474 A4NOTE,\par
00475 A4NOTE,\par
00476 A4NOTE,\par
00477 A4NOTE,\par
00478 A4NOTE,\par
00479 E4NOTE,\par
00480 OFFNOTE,\par
00481 E4NOTE,\par
00482 OFFNOTE,\par
00483 E5NOTE,\par
00484 E5NOTE,\par
00485 E5NOTE,\par
00486 E5NOTE,\par
00487 C5SHARPNOTE,\par
00488 C5SHARPNOTE,\par
00489 C5SHARPNOTE,\par
00490 C5SHARPNOTE,\par
00491 A4NOTE,\par
00492 A4NOTE,\par
00493 A4NOTE,\par
00494 A4NOTE,\par
00495 G4SHARPNOTE,\par
00496 G4SHARPNOTE,\par
00497 G4SHARPNOTE,\par
00498 G4SHARPNOTE,\par
00499 F4SHARPNOTE,\par
00500 F4SHARPNOTE,\par
00501 F4SHARPNOTE,\par
00502 F4SHARPNOTE,\par
00503 D5NOTE,\par
00504 OFFNOTE,\par
00505 D5NOTE,\par
00506 OFFNOTE,\par
00507 C5SHARPNOTE,\par
00508 C5SHARPNOTE,\par
00509 C5SHARPNOTE,\par
00510 C5SHARPNOTE,\par
00511 A4NOTE,\par
00512 A4NOTE,\par
00513 A4NOTE,\par
00514 A4NOTE,\par
00515 B4NOTE,\par
00516 B4NOTE,\par
00517 B4NOTE,\par
00518 B4NOTE,\par
00519 A4NOTE,\par
00520 A4NOTE,\par
00521 A4NOTE,\par
00522 A4NOTE,\par
00523 A4NOTE,\par
00524 A4NOTE,\par
00525 A4NOTE,\par
00526 A4NOTE,\par
00527 A4NOTE,\par
00528 A4NOTE,\par
00529 A4NOTE,\par
00530 A4NOTE,\par
00531 OFFNOTE,\par
00532 OFFNOTE,\par
00533 OFFNOTE,\par
00534 OFFNOTE,\par
00535 OFFNOTE,\par
00536 OFFNOTE,\par
00537 OFFNOTE,\par
00538 OFFNOTE,\par
00539 OFFNOTE,\par
00540 OFFNOTE,\par
00541 OFFNOTE,\par
00542 OFFNOTE,\par
00543 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Chip_Main.c File Reference\par \pard\plain 
{\tc\tcl2 \v UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c}
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
{\f2 #include "driverlib.h"}\par
{\f2 #include "device.h"}\par
{\f2 #include "f28379dSerial.h"}\par
{\f2 #include "LEDPatterns.h"}\par
{\f2 #include "song.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PI}\~ 3.1415926535897932384626433832795\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWOPI}\~ 6.283185307179586476925286766559\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HALFPI}\~ 1.5707963267948966192313216916398\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer0_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer1_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer2_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SWI_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXA} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXC} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b main} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numTimer0calls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numSWIcalls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numRXA} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LEDdisplaynum} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sendback} [10]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b past} [10]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HALFPI\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:HALFPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HALFPI\~ 1.5707963267948966192313216916398}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v PI\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PI\~ 3.1415926535897932384626433832795}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v TWOPI\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:TWOPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWOPI\~ 6.283185307179586476925286766559}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b UART_Chip_Main.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v cpu_timer0_isr\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:cpu_timer0_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer0_isr (void )}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v cpu_timer1_isr\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:cpu_timer1_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer1_isr (void )}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 340} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v cpu_timer2_isr\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:cpu_timer2_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer2_isr (void )}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 348} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v main\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void main (void )}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v serialRXA\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:serialRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXA ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 364} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v serialRXC\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:serialRXC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXC ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 371} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v SWI_isr\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:SWI_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SWI_isr (void )}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 294} of file {\b UART_Chip_Main.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v LEDdisplaynum\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:LEDdisplaynum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LEDdisplaynum = 0}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v numRXA\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:numRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numRXA = 0}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v numSWIcalls\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:numSWIcalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numSWIcalls = 0}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v numTimer0calls\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:numTimer0calls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numTimer0calls = 0}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v past\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:past}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char past[10]}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 370} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v sendback\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:sendback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char sendback[10]}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 369} of file {\b UART_Chip_Main.c}.}\par
}
{\xe \v UARTPrint\:UART_Chip_Main.c}
{\xe \v UART_Chip_Main.c\:UARTPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint = 0}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b UART_Chip_Main.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Chip_Main.c\par \pard\plain 
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //#############################################################################}\par
00002 {\cf20 // UART_Chip_Main}\par
00003 {\cf20 //#############################################################################}\par
00004 \par
00005 {\cf20 // Included Files}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 {\cf21 #include <stdarg.h>}\par
00009 {\cf21 #include <string.h>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include <limits.h>}\par
00012 {\cf21 #include "F28x_Project.h"}\par
00013 {\cf21 #include "driverlib.h"}\par
00014 {\cf21 #include "device.h"}\par
00015 {\cf21 #include "f28379dSerial.h"}\par
00016 {\cf21 #include "LEDPatterns.h"}\par
00017 {\cf21 #include "song.h"}\par
00018 {\cf20 // #include "dsp.h"}\par
00019 {\cf20 //#include "fpu32/fpu_rfft.h"}\par
00020 \par
00021 {\cf21 #define PI          3.1415926535897932384626433832795}\par
00022 {\cf21 #define TWOPI       6.283185307179586476925286766559}\par
00023 {\cf21 #define HALFPI      1.5707963267948966192313216916398}\par
00024 \par
00025 \par
00026 {\cf20 // Interrupt Service Routines predefinition}\par
00027 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void});\par
00028 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void});\par
00029 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void});\par
00030 __interrupt {\cf18 void} SWI_isr({\cf18 void});\par
00031 \par
00032 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data);\par
00033 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data);\par
00034 \par
00035 {\cf20 // Count variables}\par
00036 uint32_t numTimer0calls = 0;\par
00037 uint32_t numSWIcalls = 0;\par
00038 uint32_t numRXA = 0;\par
00039 uint16_t UARTPrint = 0;\par
00040 uint16_t LEDdisplaynum = 0;\par
00041 \par
00042 \par
00043 {\cf18 void} main({\cf18 void})\par
00044 \{\par
00045     {\cf20 // PLL, WatchDog, enable Peripheral Clocks}\par
00046     {\cf20 // This example function is found in the F2837xD_SysCtrl.c file.}\par
00047     InitSysCtrl();\par
00048 \par
00049     InitGpio();\par
00050     \par
00051     {\cf20 // Blue LED on LuanchPad}\par
00052     GPIO_SetupPinMux(31, GPIO_MUX_CPU1, 0);\par
00053     GPIO_SetupPinOptions(31, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00054     GpioDataRegs.GPASET.bit.GPIO31 = 1;\par
00055 \par
00056     {\cf20 // Red LED on LaunchPad}\par
00057     GPIO_SetupPinMux(34, GPIO_MUX_CPU1, 0);\par
00058     GPIO_SetupPinOptions(34, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00059     GpioDataRegs.GPBSET.bit.GPIO34 = 1;\par
00060 \par
00061     {\cf20 // LED1 and PWM Pin}\par
00062     GPIO_SetupPinMux(22, GPIO_MUX_CPU1, 0);\par
00063     GPIO_SetupPinOptions(22, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00064     GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;\par
00065     \par
00066     {\cf20 // LED2}\par
00067     GPIO_SetupPinMux(94, GPIO_MUX_CPU1, 0);\par
00068     GPIO_SetupPinOptions(94, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00069     GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;\par
00070 \par
00071     {\cf20 // LED3}\par
00072     GPIO_SetupPinMux(95, GPIO_MUX_CPU1, 0);\par
00073     GPIO_SetupPinOptions(95, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00074     GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;\par
00075 \par
00076     {\cf20 // LED4}\par
00077     GPIO_SetupPinMux(97, GPIO_MUX_CPU1, 0);\par
00078     GPIO_SetupPinOptions(97, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00079     GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;\par
00080 \par
00081     {\cf20 // LED5}\par
00082     GPIO_SetupPinMux(111, GPIO_MUX_CPU1, 0);\par
00083     GPIO_SetupPinOptions(111, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00084     GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;\par
00085 \par
00086     {\cf20 // LED6}\par
00087     GPIO_SetupPinMux(130, GPIO_MUX_CPU1, 0);\par
00088     GPIO_SetupPinOptions(130, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00089     GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;\par
00090 \par
00091     {\cf20 // LED7 }\par
00092     GPIO_SetupPinMux(131, GPIO_MUX_CPU1, 0);\par
00093     GPIO_SetupPinOptions(131, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00094     GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;\par
00095 \par
00096     {\cf20 // LED8}\par
00097     GPIO_SetupPinMux(25, GPIO_MUX_CPU1, 0);\par
00098     GPIO_SetupPinOptions(25, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00099     GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;\par
00100 \par
00101     {\cf20 // LED9}\par
00102     GPIO_SetupPinMux(26, GPIO_MUX_CPU1, 0);\par
00103     GPIO_SetupPinOptions(26, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00104     GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;\par
00105 \par
00106     {\cf20 // LED10}\par
00107     GPIO_SetupPinMux(27, GPIO_MUX_CPU1, 0);\par
00108     GPIO_SetupPinOptions(27, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00109     GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;\par
00110 \par
00111     {\cf20 // LED11    }\par
00112     GPIO_SetupPinMux(60, GPIO_MUX_CPU1, 0);\par
00113     GPIO_SetupPinOptions(60, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00114     GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;\par
00115 \par
00116     {\cf20 // LED12    }\par
00117     GPIO_SetupPinMux(61, GPIO_MUX_CPU1, 0);\par
00118     GPIO_SetupPinOptions(61, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00119     GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;\par
00120 \par
00121     {\cf20 // LED13}\par
00122     GPIO_SetupPinMux(157, GPIO_MUX_CPU1, 0);\par
00123     GPIO_SetupPinOptions(157, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00124     GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;\par
00125 \par
00126     {\cf20 // LED14}\par
00127     GPIO_SetupPinMux(158, GPIO_MUX_CPU1, 0);\par
00128     GPIO_SetupPinOptions(158, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00129     GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;\par
00130     \par
00131     {\cf20 // LED15}\par
00132     GPIO_SetupPinMux(159, GPIO_MUX_CPU1, 0);\par
00133     GPIO_SetupPinOptions(159, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00134     GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;\par
00135 \par
00136     {\cf20 // LED16}\par
00137     GPIO_SetupPinMux(160, GPIO_MUX_CPU1, 0);\par
00138     GPIO_SetupPinOptions(160, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00139     GpioDataRegs.GPFCLEAR.bit.GPIO160 = 1;\par
00140 \par
00141     {\cf20 //WIZNET Reset}\par
00142     GPIO_SetupPinMux(0, GPIO_MUX_CPU1, 0);\par
00143     GPIO_SetupPinOptions(0, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00144     GpioDataRegs.GPASET.bit.GPIO0 = 1;\par
00145 \par
00146     {\cf20 //ESP8266 Reset}\par
00147     GPIO_SetupPinMux(1, GPIO_MUX_CPU1, 0);\par
00148     GPIO_SetupPinOptions(1, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00149     GpioDataRegs.GPASET.bit.GPIO1 = 1;\par
00150 \par
00151     {\cf20 //SPIRAM  CS  Chip Select}\par
00152     GPIO_SetupPinMux(19, GPIO_MUX_CPU1, 0);\par
00153     GPIO_SetupPinOptions(19, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00154     GpioDataRegs.GPASET.bit.GPIO19 = 1;\par
00155 \par
00156     {\cf20 //DRV8874 #1 DIR  Direction}\par
00157     GPIO_SetupPinMux(29, GPIO_MUX_CPU1, 0);\par
00158     GPIO_SetupPinOptions(29, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00159     GpioDataRegs.GPASET.bit.GPIO29 = 1;\par
00160 \par
00161     {\cf20 //DRV8874 #2 DIR  Direction}\par
00162     GPIO_SetupPinMux(32, GPIO_MUX_CPU1, 0);\par
00163     GPIO_SetupPinOptions(32, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00164     GpioDataRegs.GPBSET.bit.GPIO32 = 1;\par
00165 \par
00166     {\cf20 //DAN28027  CS  Chip Select}\par
00167     GPIO_SetupPinMux(9, GPIO_MUX_CPU1, 0);\par
00168     GPIO_SetupPinOptions(9, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00169     GpioDataRegs.GPASET.bit.GPIO9 = 1;\par
00170     \par
00171     {\cf20 //MPU9250  CS  Chip Select}\par
00172     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0);\par
00173     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00174     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
00175     \par
00176     {\cf20 //WIZNET  CS  Chip Select}\par
00177     GPIO_SetupPinMux(125, GPIO_MUX_CPU1, 0);\par
00178     GPIO_SetupPinOptions(125, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00179     GpioDataRegs.GPDSET.bit.GPIO125 = 1;\par
00180     \par
00181     {\cf20 //PushButton 1}\par
00182     GPIO_SetupPinMux(4, GPIO_MUX_CPU1, 0);\par
00183     GPIO_SetupPinOptions(4, GPIO_INPUT, GPIO_PULLUP);\par
00184 \par
00185     {\cf20 //PushButton 2}\par
00186     GPIO_SetupPinMux(5, GPIO_MUX_CPU1, 0);\par
00187     GPIO_SetupPinOptions(5, GPIO_INPUT, GPIO_PULLUP);\par
00188 \par
00189     {\cf20 //PushButton 3}\par
00190     GPIO_SetupPinMux(6, GPIO_MUX_CPU1, 0);\par
00191     GPIO_SetupPinOptions(6, GPIO_INPUT, GPIO_PULLUP);\par
00192 \par
00193     {\cf20 //PushButton 4}\par
00194     GPIO_SetupPinMux(7, GPIO_MUX_CPU1, 0);\par
00195     GPIO_SetupPinOptions(7, GPIO_INPUT, GPIO_PULLUP);\par
00196     \par
00197     {\cf20 //Joy Stick Pushbutton}\par
00198     GPIO_SetupPinMux(8, GPIO_MUX_CPU1, 0);\par
00199     GPIO_SetupPinOptions(8, GPIO_INPUT, GPIO_PULLUP);\par
00200 \par
00201     {\cf20 //Ground GPIO1 Connected to BT CTS Pin}\par
00202     GpioDataRegs.GPACLEAR.bit.GPIO1 = 1;\par
00203 \par
00204     {\cf20 // Clear all interrupts and initialize PIE vector table:}\par
00205     {\cf20 // Disable CPU interrupts}\par
00206     DINT;\par
00207 \par
00208     {\cf20 // Initialize the PIE control registers to their default state.}\par
00209     {\cf20 // The default state is all PIE interrupts disabled and flags}\par
00210     {\cf20 // are cleared.}\par
00211     {\cf20 // This function is found in the F2837xD_PieCtrl.c file.}\par
00212     InitPieCtrl();\par
00213 \par
00214     {\cf20 // Disable CPU interrupts and clear all CPU interrupt flags:}\par
00215     IER = 0x0000;\par
00216     IFR = 0x0000;\par
00217 \par
00218     {\cf20 // Initialize the PIE vector table with pointers to the shell Interrupt}\par
00219     {\cf20 // Service Routines (ISR).}\par
00220     {\cf20 // This will populate the entire table, even if the interrupt}\par
00221     {\cf20 // is not used in this example.  This is useful for debug purposes.}\par
00222     {\cf20 // The shell ISR routines are found in F2837xD_DefaultIsr.c.}\par
00223     {\cf20 // This function is found in F2837xD_PieVect.c.}\par
00224     InitPieVectTable();\par
00225 \par
00226     {\cf20 // Interrupts that are used in this example are re-mapped to}\par
00227     {\cf20 // ISR functions found within this project}\par
00228     EALLOW;  {\cf20 // This is needed to write to EALLOW protected registers}\par
00229     PieVectTable.TIMER0_INT = &cpu_timer0_isr;\par
00230     PieVectTable.TIMER1_INT = &cpu_timer1_isr;\par
00231     PieVectTable.TIMER2_INT = &cpu_timer2_isr;\par
00232     PieVectTable.SCIA_RX_INT = &RXAINT_recv_ready;\par
00233     PieVectTable.SCIC_RX_INT = &RXCINT_recv_ready;\par
00234     PieVectTable.SCID_RX_INT = &RXDINT_recv_ready;\par
00235     PieVectTable.SCIA_TX_INT = &TXAINT_data_sent;\par
00236     PieVectTable.SCIC_TX_INT = &TXCINT_data_sent;\par
00237     PieVectTable.SCID_TX_INT = &TXDINT_data_sent;\par
00238 \par
00239     PieVectTable.EMIF_ERROR_INT = &SWI_isr;\par
00240     EDIS;    {\cf20 // This is needed to disable write to EALLOW protected registers}\par
00241 \par
00242 \par
00243     {\cf20 // Initialize the CpuTimers Device Peripheral. This function can be}\par
00244     {\cf20 // found in F2837xD_CpuTimers.c}\par
00245     InitCpuTimers();\par
00246 \par
00247     {\cf20 // Configure CPU-Timer 0, 1, and 2 to interrupt every second:}\par
00248     {\cf20 // 200MHz CPU Freq, 1 second Period (in uSeconds)}\par
00249     ConfigCpuTimer(&CpuTimer0, 200, 10000);\par
00250     ConfigCpuTimer(&CpuTimer1, 200, 20000);\par
00251     ConfigCpuTimer(&CpuTimer2, 200, 40000);\par
00252 \par
00253     {\cf20 // Enable CpuTimer Interrupt bit TIE}\par
00254     CpuTimer0Regs.TCR.all = 0x4000;\par
00255     CpuTimer1Regs.TCR.all = 0x4000;\par
00256     CpuTimer2Regs.TCR.all = 0x4000;\par
00257 \par
00258     init_serial(&SerialA,115200,serialRXA);\par
00259     init_serial(&SerialC,9600,serialRXC); {\cf20 //set to 9600 for Bluetooth Chip, initializations and muxing done in Serial.c}\par
00260 {\cf20 //    init_serial(&SerialD,115200,serialRXD);}\par
00261 \par
00262     {\cf20 // Enable CPU int1 which is connected to CPU-Timer 0, CPU int13}\par
00263     {\cf20 // which is connected to CPU-Timer 1, and CPU int 14, which is connected}\par
00264     {\cf20 // to CPU-Timer 2:  int 12 is for the SWI.  }\par
00265     IER |= M_INT1;\par
00266     IER |= M_INT8;  {\cf20 // SCIC SCID}\par
00267     IER |= M_INT9;  {\cf20 // SCIA}\par
00268     IER |= M_INT12;\par
00269     IER |= M_INT13;\par
00270     IER |= M_INT14;\par
00271 \par
00272     {\cf20 // Enable TINT0 in the PIE: Group 1 interrupt 7}\par
00273     PieCtrlRegs.PIEIER1.bit.INTx7 = 1;\par
00274     {\cf20 // Enable SWI in the PIE: Group 12 interrupt 9}\par
00275     PieCtrlRegs.PIEIER12.bit.INTx9 = 1;\par
00276     \par
00277     {\cf20 // Enable global Interrupts and higher priority real-time debug events}\par
00278     EINT;  {\cf20 // Enable Global interrupt INTM}\par
00279     ERTM;  {\cf20 // Enable Global realtime interrupt DBGM}\par
00280 \par
00281     \par
00282     {\cf20 // IDLE loop. Just sit and loop forever (optional):}\par
00283     {\cf19 while}(1)\par
00284     \{\par
00285         {\cf19 if} (UARTPrint == 1 ) \{\par
00286                 serial_printf(&SerialC,{\cf22 "Num Timer2:%ld Num SerialRX: %ld\\r\\n"},CpuTimer2.InterruptCount,numRXA);\par
00287             UARTPrint = 0;\par
00288         \}\par
00289     \}\par
00290 \}\par
00291 \par
00292 \par
00293 {\cf20 // SWI_isr,  Using this interrupt as a Software started interrupt}\par
00294 __interrupt {\cf18 void} SWI_isr({\cf18 void}) \{\par
00295 \par
00296     {\cf20 // These three lines of code allow SWI_isr, to be interrupted by other interrupt functions}\par
00297     {\cf20 // making it lower priority than all other Hardware interrupts.  }\par
00298     PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\par
00299     {\cf17 asm}({\cf22 "       NOP"});                    {\cf20 // Wait one cycle}\par
00300     EINT;                                 {\cf20 // Clear INTM to enable interrupts}\par
00301     \par
00302     \par
00303     \par
00304     {\cf20 // Insert SWI ISR Code here.......}\par
00305     \par
00306     \par
00307     numSWIcalls++;\par
00308     \par
00309     DINT;\par
00310 \par
00311 \}\par
00312 \par
00313 {\cf20 // cpu_timer0_isr - CPU Timer0 ISR}\par
00314 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void})\par
00315 \{\par
00316     CpuTimer0.InterruptCount++;\par
00317 \par
00318     numTimer0calls++;\par
00319 \par
00320 {\cf20 //    if ((numTimer0calls%50) == 0) \{}\par
00321 {\cf20 //        PieCtrlRegs.PIEIFR12.bit.INTx9 = 1;  // Manually cause the interrupt for the SWI}\par
00322 {\cf20 //    \}}\par
00323 \par
00324     {\cf19 if} ((numTimer0calls%250) == 0) \{\par
00325         displayLEDletter(LEDdisplaynum);\par
00326         LEDdisplaynum++;\par
00327         {\cf19 if} (LEDdisplaynum == 0xFFFF) \{  {\cf20 // prevent roll over exception}\par
00328             LEDdisplaynum = 0;\par
00329         \}\par
00330     \}\par
00331 \par
00332     {\cf20 // Blink LaunchPad Red LED}\par
00333     GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;\par
00334 \par
00335     {\cf20 // Acknowledge this interrupt to receive more interrupts from group 1}\par
00336     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00337 \}\par
00338 \par
00339 {\cf20 // cpu_timer1_isr - CPU Timer1 ISR}\par
00340 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void})\par
00341 \{\par
00342     \par
00343     \par
00344     CpuTimer1.InterruptCount++;\par
00345 \}\par
00346 \par
00347 {\cf20 // cpu_timer2_isr CPU Timer2 ISR}\par
00348 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void})\par
00349 \{\par
00350     \par
00351     \par
00352     {\cf20 // Blink LaunchPad Blue LED}\par
00353     GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;\par
00354 \par
00355     CpuTimer2.InterruptCount++;\par
00356     \par
00357     {\cf19 if} ((CpuTimer2.InterruptCount % 50) == 0) \{\par
00358         UARTPrint = 1;\par
00359     \}\par
00360 \}\par
00361 \par
00362 \par
00363 {\cf20 // This function is called each time a char is recieved over UARTA.}\par
00364 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data) \{\par
00365     numRXA ++;\par
00366 \par
00367 \}\par
00368 \par
00369 {\cf18 char} sendback[10];\par
00370 {\cf18 char} past[10];\par
00371 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data) \{\par
00372 {\cf20 //    sendback[0] = data;}\par
00373 {\cf20 //    serial_send(&SerialA, sendback, 1); //every character that comes into BT will be echoed to Tera Term}\par
00374 \par
00375     {\cf20 //save past states}\par
00376     past[0] = past[1];\par
00377     past[1] = past[2];\par
00378     past[2] = past[3];\par
00379     past[3] = past[4];\par
00380     past[4] = past[5];\par
00381     past[5] = past[6];\par
00382     past[6] = past[7];\par
00383     past[7] = past[8];\par
00384     past[8] = past[9];\par
00385     past[9] = data;\par
00386 \par
00387     {\cf19 if}((past[4] == {\cf23 '6'})&&(past[9] == {\cf23 '7'}))\{\par
00388         {\cf20 //up arrow pressed, speed up '!B516!B507'}\par
00389 {\cf20 //        print to tera term if up arrow pressed}\par
00390             sendback[0] = data;\par
00391             serial_send(&SerialA, sendback, 1); {\cf20 //every character that comes into BT will be echoed to Tera Term}\par
00392     \}{\cf19 else} {\cf19 if}((past[4] == {\cf23 '5'})&&(past[9] == {\cf23 '6'}))\{\par
00393         {\cf20 //down arrow pressed, slow down '!B615!B606'}\par
00394     \}{\cf19 else} {\cf19 if}((past[4] == {\cf23 '4'})&&(past[9] == {\cf23 '5'}))\{\par
00395         {\cf20 //turn left '!B714!B705'}\par
00396     \}{\cf19 else} {\cf19 if}((past[4] == {\cf23 '3'})&&(past[9] == {\cf23 '4'}))\{\par
00397         {\cf20 //turn right '!B813!B804'}\par
00398     \}\par
00399 \}\par
00400 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot..c File Reference\par \pard\plain 
{\tc\tcl2 \v UART_Segbot..c}
{\xe \v UART_Segbot..c}
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
{\f2 #include "driverlib.h"}\par
{\f2 #include "device.h"}\par
{\f2 #include "f28379dSerial.h"}\par
{\f2 #include "LEDPatterns.h"}\par
{\f2 #include "song.h"}\par
{\f2 #include "dsp.h"}\par
{\f2 #include "fpu32/fpu_rfft.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PI}\~ 3.1415926535897932384626433832795\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWOPI}\~ 6.283185307179586476925286766559\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HALFPI}\~ 1.5707963267948966192313216916398\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer0_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer1_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer2_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SWI_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SPIB_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b ADCA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupSpib} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXA} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXC} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_eQEPs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncLeft} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncRight} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2A} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2B} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b main} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numTimer0calls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numSWIcalls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numRXA} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LEDdisplaynum} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b Junk} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelzraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyrozraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ubal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K1} = -60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K2} = -7.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K3} = -1.1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uLeft} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uRight} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turn} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kp} = 3.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Ki} = 20.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kd} = .01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b FwdBackOffset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca0_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca1_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca0result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca1result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelzBalancePoint} = -.73\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16 {\b IMU_data} [9]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b temp} =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b doneCal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b T} = 0.001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Q} = 0.01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b R} = 25000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_tilt} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_P} = 22.365\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b SpibNumCalls} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pred_P} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_K} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b timecount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b calibration_state} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b calibration_count} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sendback} [10]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b past} [10]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HALFPI\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:HALFPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HALFPI\~ 1.5707963267948966192313216916398}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b UART_Segbot..c}.}\par
}
{\xe \v PI\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PI\~ 3.1415926535897932384626433832795}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b UART_Segbot..c}.}\par
}
{\xe \v TWOPI\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:TWOPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWOPI\~ 6.283185307179586476925286766559}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b UART_Segbot..c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ADCA_ISR\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:ADCA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void ADCA_ISR (void )}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 647} of file {\b UART_Segbot..c}.}\par
}
{\xe \v cpu_timer0_isr\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:cpu_timer0_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer0_isr (void )}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 536} of file {\b UART_Segbot..c}.}\par
}
{\xe \v cpu_timer1_isr\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:cpu_timer1_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer1_isr (void )}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 554} of file {\b UART_Segbot..c}.}\par
}
{\xe \v cpu_timer2_isr\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:cpu_timer2_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer2_isr (void )}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 561} of file {\b UART_Segbot..c}.}\par
}
{\xe \v init_eQEPs\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:init_eQEPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_eQEPs (void )}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 816} of file {\b UART_Segbot..c}.}\par
}
{\xe \v main\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void main (void )}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b UART_Segbot..c}.}\par
}
{\xe \v readEncLeft\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:readEncLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncLeft (void )}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 789} of file {\b UART_Segbot..c}.}\par
}
{\xe \v readEncRight\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:readEncRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncRight (void )}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 802} of file {\b UART_Segbot..c}.}\par
}
{\xe \v serialRXA\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:serialRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXA ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 573} of file {\b UART_Segbot..c}.}\par
}
{\xe \v serialRXC\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:serialRXC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXC ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 591} of file {\b UART_Segbot..c}.}\par
}
{\xe \v setEPWM2A\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:setEPWM2A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2A (float controleffort)}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 862} of file {\b UART_Segbot..c}.}\par
}
{\xe \v setEPWM2B\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:setEPWM2B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2B (float controleffort)}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 873} of file {\b UART_Segbot..c}.}\par
}
{\xe \v setupSpib\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:setupSpib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setupSpib (void )}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 883} of file {\b UART_Segbot..c}.}\par
}
{\xe \v SPIB_isr\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:SPIB_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SPIB_isr (void )}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 674} of file {\b UART_Segbot..c}.}\par
}
{\xe \v SWI_isr\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:SWI_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SWI_isr (void )}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 473} of file {\b UART_Segbot..c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v accelx\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx = 0}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accelx_offset\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelx_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx_offset = 0}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accelxraw\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelxraw = 0}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accely\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely = 0}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accely_offset\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accely_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely_offset = 0}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accelyraw\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelyraw = 0}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accelz\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz = 0}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accelz_offset\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz_offset = 0}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accelzBalancePoint\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelzBalancePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelzBalancePoint = -.73}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b UART_Segbot..c}.}\par
}
{\xe \v accelzraw\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:accelzraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelzraw = 0}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b UART_Segbot..c}.}\par
}
{\xe \v adca0_volts\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:adca0_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca0_volts = 0}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b UART_Segbot..c}.}\par
}
{\xe \v adca0result\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:adca0result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca0result = 0}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b UART_Segbot..c}.}\par
}
{\xe \v adca1_volts\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:adca1_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca1_volts = 0}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b UART_Segbot..c}.}\par
}
{\xe \v adca1result\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:adca1result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca1result = 0}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b UART_Segbot..c}.}\par
}
{\xe \v calibration_count\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:calibration_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t calibration_count = 0}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b UART_Segbot..c}.}\par
}
{\xe \v calibration_state\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:calibration_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t calibration_state = 0}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b UART_Segbot..c}.}\par
}
{\xe \v doneCal\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:doneCal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t doneCal = 0}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UART_Segbot..c}.}\par
}
{\xe \v eDif\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:eDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif = 0}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b UART_Segbot..c}.}\par
}
{\xe \v eDif_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:eDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif_1 = 0}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b UART_Segbot..c}.}\par
}
{\xe \v FwdBackOffset\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:FwdBackOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float FwdBackOffset = 0}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyro_array\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyro_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyro_value\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyro_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_value = 0}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyrox\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyrox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox = 0}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyrox_offset\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyrox_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox_offset = 0}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyroxraw\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyroxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroxraw = 0}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyroy\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy = 0}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyroy_offset\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyroy_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy_offset = 0}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyroyraw\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyroyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroyraw = 0}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyroz\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyroz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz = 0}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyroz_offset\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyroz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz_offset = 0}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b UART_Segbot..c}.}\par
}
{\xe \v gyrozraw\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:gyrozraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyrozraw = 0}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b UART_Segbot..c}.}\par
}
{\xe \v iDif\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:iDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif = 0}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b UART_Segbot..c}.}\par
}
{\xe \v iDif_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:iDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif_1 = 0}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b UART_Segbot..c}.}\par
}
{\xe \v IMU_data\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:IMU_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16 IMU_data[9]}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b UART_Segbot..c}.}\par
}
{\xe \v Junk\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:Junk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Junk = 0}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b UART_Segbot..c}.}\par
}
{\xe \v K1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:K1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K1 = -60}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b UART_Segbot..c}.}\par
}
{\xe \v K2\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:K2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K2 = -7.0}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b UART_Segbot..c}.}\par
}
{\xe \v K3\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:K3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K3 = -1.1}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b UART_Segbot..c}.}\par
}
{\xe \v kalman_K\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:kalman_K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_K = 0}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b UART_Segbot..c}.}\par
}
{\xe \v kalman_P\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:kalman_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_P = 22.365}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b UART_Segbot..c}.}\par
}
{\xe \v kalman_tilt\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:kalman_tilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_tilt = 0}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b UART_Segbot..c}.}\par
}
{\xe \v Kd\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:Kd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kd = .01}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b UART_Segbot..c}.}\par
}
{\xe \v Ki\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:Ki}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Ki = 20.0}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b UART_Segbot..c}.}\par
}
{\xe \v Kp\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:Kp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kp = 3.0}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b UART_Segbot..c}.}\par
}
{\xe \v LEDdisplaynum\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:LEDdisplaynum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LEDdisplaynum = 0}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b UART_Segbot..c}.}\par
}
{\xe \v LeftVel\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:LeftVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel = 0}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b UART_Segbot..c}.}\par
}
{\xe \v LeftVel_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:LeftVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel_1 = 0}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b UART_Segbot..c}.}\par
}
{\xe \v LeftWheel\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:LeftWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel = 0}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b UART_Segbot..c}.}\par
}
{\xe \v LeftWheel_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:LeftWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel_1 = 0}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b UART_Segbot..c}.}\par
}
{\xe \v LeftWheelArray\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:LeftWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b UART_Segbot..c}.}\par
}
{\xe \v numRXA\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:numRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numRXA = 0}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b UART_Segbot..c}.}\par
}
{\xe \v numSWIcalls\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:numSWIcalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numSWIcalls = 0}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b UART_Segbot..c}.}\par
}
{\xe \v numTimer0calls\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:numTimer0calls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numTimer0calls = 0}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b UART_Segbot..c}.}\par
}
{\xe \v past\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:past}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char past[10]}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 590} of file {\b UART_Segbot..c}.}\par
}
{\xe \v pred_P\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:pred_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float pred_P = 0}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b UART_Segbot..c}.}\par
}
{\xe \v Q\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:Q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Q = 0.01}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b UART_Segbot..c}.}\par
}
{\xe \v R\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:R}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float R = 25000}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b UART_Segbot..c}.}\par
}
{\xe \v RightVel\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:RightVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel = 0}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b UART_Segbot..c}.}\par
}
{\xe \v RightVel_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:RightVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel_1 = 0}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b UART_Segbot..c}.}\par
}
{\xe \v RightWheel\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:RightWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel = 0}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b UART_Segbot..c}.}\par
}
{\xe \v RightWheel_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:RightWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel_1 = 0}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b UART_Segbot..c}.}\par
}
{\xe \v RightWheelArray\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:RightWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b UART_Segbot..c}.}\par
}
{\xe \v sendback\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:sendback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char sendback[10]}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 589} of file {\b UART_Segbot..c}.}\par
}
{\xe \v SpibNumCalls\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:SpibNumCalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SpibNumCalls = -1}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b UART_Segbot..c}.}\par
}
{\xe \v T\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float T = 0.001}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b UART_Segbot..c}.}\par
}
{\xe \v temp\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t temp =0}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b UART_Segbot..c}.}\par
}
{\xe \v tilt_array\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:tilt_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UART_Segbot..c}.}\par
}
{\xe \v tilt_value\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:tilt_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_value = 0}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b UART_Segbot..c}.}\par
}
{\xe \v timecount\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:timecount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t timecount = 0}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b UART_Segbot..c}.}\par
}
{\xe \v turn\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turn = 0}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b UART_Segbot..c}.}\par
}
{\xe \v turnrate\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:turnrate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate = 0}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b UART_Segbot..c}.}\par
}
{\xe \v turnrate_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:turnrate_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate_1 = 0}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b UART_Segbot..c}.}\par
}
{\xe \v turnref\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:turnref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref = 0}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b UART_Segbot..c}.}\par
}
{\xe \v turnref_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:turnref_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref_1 = 0}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b UART_Segbot..c}.}\par
}
{\xe \v UARTPrint\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:UARTPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint = 0}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b UART_Segbot..c}.}\par
}
{\xe \v ubal\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:ubal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ubal = 0}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b UART_Segbot..c}.}\par
}
{\xe \v uLeft\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:uLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uLeft = 5.0}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b UART_Segbot..c}.}\par
}
{\xe \v uRight\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:uRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uRight = 5.0}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b UART_Segbot..c}.}\par
}
{\xe \v velWheelDif\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:velWheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif = 0}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b UART_Segbot..c}.}\par
}
{\xe \v velWheelDif_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:velWheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b UART_Segbot..c}.}\par
}
{\xe \v WheelDif\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:WheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif = 0}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b UART_Segbot..c}.}\par
}
{\xe \v WheelDif_1\:UART_Segbot..c}
{\xe \v UART_Segbot..c\:WheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b UART_Segbot..c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot..c\par \pard\plain 
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //#############################################################################}\par
00002 {\cf20 //UART_Segbot use Control Pad}\par
00003 {\cf20 //#############################################################################}\par
00004 \par
00005 {\cf20 // Included Files}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 {\cf21 #include <stdarg.h>}\par
00009 {\cf21 #include <string.h>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include <limits.h>}\par
00012 {\cf21 #include "F28x_Project.h"}\par
00013 {\cf21 #include "driverlib.h"}\par
00014 {\cf21 #include "device.h"}\par
00015 {\cf21 #include "f28379dSerial.h"}\par
00016 {\cf21 #include "LEDPatterns.h"}\par
00017 {\cf21 #include "song.h"}\par
00018 {\cf21 #include "dsp.h"}\par
00019 {\cf21 #include "fpu32/fpu_rfft.h"}\par
00020 \par
00021 {\cf21 #define PI          3.1415926535897932384626433832795}\par
00022 {\cf21 #define TWOPI       6.283185307179586476925286766559}\par
00023 {\cf21 #define HALFPI      1.5707963267948966192313216916398}\par
00024 \par
00025 \par
00026 {\cf20 // Interrupt Service Routines predefinition}\par
00027 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void});\par
00028 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void});\par
00029 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void});\par
00030 __interrupt {\cf18 void} SWI_isr({\cf18 void});\par
00031 __interrupt {\cf18 void} SPIB_isr({\cf18 void});\par
00032 __interrupt {\cf18 void} ADCA_ISR({\cf18 void});\par
00033 \par
00034 {\cf18 void} setupSpib({\cf18 void});\par
00035 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data);\par
00036 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data);\par
00037 {\cf18 void} init_eQEPs({\cf18 void});\par
00038 {\cf18 float} readEncLeft({\cf18 void});\par
00039 {\cf18 float} readEncRight({\cf18 void});\par
00040 {\cf18 void} setEPWM2A({\cf18 float});\par
00041 {\cf18 void} setEPWM2B({\cf18 float});\par
00042 \par
00043 {\cf20 // Count variables}\par
00044 uint32_t numTimer0calls = 0;\par
00045 uint32_t numSWIcalls = 0;\par
00046 uint32_t numRXA = 0;\par
00047 uint16_t UARTPrint = 0;\par
00048 uint16_t LEDdisplaynum = 0;\par
00049 \par
00050 int16_t Junk = 0;\par
00051 \par
00052 int16_t accelxraw = 0;\par
00053 int16_t accelyraw = 0;\par
00054 int16_t accelzraw = 0;\par
00055 int16_t gyroxraw = 0;\par
00056 int16_t gyroyraw = 0;\par
00057 int16_t gyrozraw = 0;\par
00058 \par
00059 {\cf18 float} accelx = 0;\par
00060 {\cf18 float} accely = 0;\par
00061 {\cf18 float} accelz = 0;\par
00062 {\cf18 float} gyrox = 0;\par
00063 {\cf18 float} gyroy = 0;\par
00064 {\cf18 float} gyroz = 0;\par
00065 {\cf18 float} LeftWheel = 0;\par
00066 {\cf18 float} RightWheel = 0;\par
00067 {\cf18 float} LeftWheel_1 = 0;\par
00068 {\cf18 float} RightWheel_1 = 0;\par
00069 {\cf18 float} LeftVel = 0;\par
00070 {\cf18 float} RightVel = 0;\par
00071 {\cf18 float} LeftVel_1 = 0;\par
00072 {\cf18 float} RightVel_1 = 0;\par
00073 {\cf18 float} ubal = 0;\par
00074 {\cf18 float} K1 = -60;\par
00075 {\cf20 //float K2 = -4.5;}\par
00076 {\cf18 float} K2 = -7.0;\par
00077 {\cf18 float} K3 = -1.1;\par
00078 {\cf18 float} WheelDif = 0;\par
00079 {\cf18 float} velWheelDif = 0;\par
00080 {\cf18 float} WheelDif_1 = 0;\par
00081 {\cf18 float} velWheelDif_1 = 0;\par
00082 {\cf18 float} turnref = 0;\par
00083 {\cf18 float} turnref_1 = 0;\par
00084 {\cf18 float} uLeft = 5.0;\par
00085 {\cf18 float} uRight = 5.0;\par
00086 {\cf18 float} eDif = 0;\par
00087 {\cf18 float} iDif = 0;\par
00088 {\cf18 float} eDif_1 = 0;\par
00089 {\cf18 float} iDif_1 = 0;\par
00090 {\cf18 float} turn = 0; {\cf20 //turn setpoint}\par
00091 {\cf18 float} Kp = 3.0;\par
00092 {\cf18 float} Ki = 20.0;\par
00093 {\cf18 float} Kd = .01;\par
00094 {\cf18 float} FwdBackOffset = 0;\par
00095 {\cf18 float} turnrate = 0;\par
00096 {\cf18 float} turnrate_1 = 0;\par
00097 \par
00098 \par
00099 {\cf20 //lab4 variables}\par
00100 {\cf18 float} adca0_volts = 0;\par
00101 {\cf18 float} adca1_volts = 0;\par
00102 int16_t adca0result = 0;\par
00103 int16_t adca1result = 0;\par
00104 \par
00105 {\cf20 // Needed global Variables}\par
00106 {\cf18 float} accelx_offset = 0;\par
00107 {\cf18 float} accely_offset = 0;\par
00108 {\cf18 float} accelz_offset = 0;\par
00109 {\cf18 float} gyrox_offset  = 0;\par
00110 {\cf18 float} gyroy_offset  = 0;\par
00111 {\cf18 float} gyroz_offset  = 0;\par
00112 {\cf20 //float accelzBalancePoint = -.76; // tune this}\par
00113 {\cf18 float} accelzBalancePoint = -.73;\par
00114 int16 IMU_data[9];\par
00115 uint16_t temp=0;\par
00116 int16_t doneCal = 0;\par
00117 {\cf18 float} tilt_value    = 0;\par
00118 {\cf18 float} tilt_array[4] = \{0, 0, 0, 0\};\par
00119 {\cf18 float} gyro_value    = 0;\par
00120 {\cf18 float} gyro_array[4] = \{0, 0, 0, 0\};\par
00121 {\cf18 float} LeftWheelArray[4] = \{0,0,0,0\};\par
00122 {\cf18 float} RightWheelArray[4] = \{0,0,0,0\};\par
00123 {\cf20 // Kalman Filter vars}\par
00124 {\cf18 float} T = 0.001;        {\cf20 //sample rate, 1ms}\par
00125 {\cf18 float} Q = 0.01; {\cf20 // made global to enable changing in runtime}\par
00126 {\cf18 float} R = 25000;{\cf20 //50000;}\par
00127 {\cf18 float} kalman_tilt = 0;\par
00128 {\cf18 float} kalman_P = 22.365;\par
00129 int16_t SpibNumCalls = -1;\par
00130 {\cf18 float} pred_P = 0;\par
00131 {\cf18 float} kalman_K = 0;\par
00132 int32_t timecount = 0;\par
00133 int16_t calibration_state = 0;\par
00134 int32_t calibration_count = 0;\par
00135 \par
00136 {\cf18 void} main({\cf18 void})\par
00137  \{\par
00138     {\cf20 // PLL, WatchDog, enable Peripheral Clocks}\par
00139     {\cf20 // This example function is found in the F2837xD_SysCtrl.c file.}\par
00140     InitSysCtrl();\par
00141 \par
00142     InitGpio();\par
00143 \par
00144     {\cf20 // Blue LED on LuanchPad}\par
00145     GPIO_SetupPinMux(31, GPIO_MUX_CPU1, 0);\par
00146     GPIO_SetupPinOptions(31, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00147     GpioDataRegs.GPASET.bit.GPIO31 = 1;\par
00148 \par
00149     {\cf20 // Red LED on LaunchPad}\par
00150     GPIO_SetupPinMux(34, GPIO_MUX_CPU1, 0);\par
00151     GPIO_SetupPinOptions(34, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00152     GpioDataRegs.GPBSET.bit.GPIO34 = 1;\par
00153 \par
00154     {\cf20 // LED1 and PWM Pin}\par
00155     GPIO_SetupPinMux(22, GPIO_MUX_CPU1, 0);\par
00156     GPIO_SetupPinOptions(22, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00157     GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;\par
00158 \par
00159     {\cf20 // LED2}\par
00160     GPIO_SetupPinMux(94, GPIO_MUX_CPU1, 0);\par
00161     GPIO_SetupPinOptions(94, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00162     GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;\par
00163 \par
00164     {\cf20 // LED3}\par
00165     GPIO_SetupPinMux(95, GPIO_MUX_CPU1, 0);\par
00166     GPIO_SetupPinOptions(95, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00167     GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;\par
00168 \par
00169     {\cf20 // LED4}\par
00170     GPIO_SetupPinMux(97, GPIO_MUX_CPU1, 0);\par
00171     GPIO_SetupPinOptions(97, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00172     GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;\par
00173 \par
00174     {\cf20 // LED5}\par
00175     GPIO_SetupPinMux(111, GPIO_MUX_CPU1, 0);\par
00176     GPIO_SetupPinOptions(111, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00177     GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;\par
00178 \par
00179     {\cf20 // LED6}\par
00180     GPIO_SetupPinMux(130, GPIO_MUX_CPU1, 0);\par
00181     GPIO_SetupPinOptions(130, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00182     GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;\par
00183 \par
00184     {\cf20 // LED7}\par
00185     GPIO_SetupPinMux(131, GPIO_MUX_CPU1, 0);\par
00186     GPIO_SetupPinOptions(131, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00187     GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;\par
00188 \par
00189     {\cf20 // LED8}\par
00190     GPIO_SetupPinMux(25, GPIO_MUX_CPU1, 0);\par
00191     GPIO_SetupPinOptions(25, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00192     GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;\par
00193 \par
00194     {\cf20 // LED9}\par
00195     GPIO_SetupPinMux(26, GPIO_MUX_CPU1, 0);\par
00196     GPIO_SetupPinOptions(26, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00197     GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;\par
00198 \par
00199     {\cf20 // LED10}\par
00200     GPIO_SetupPinMux(27, GPIO_MUX_CPU1, 0);\par
00201     GPIO_SetupPinOptions(27, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00202     GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;\par
00203 \par
00204     {\cf20 // LED11}\par
00205     GPIO_SetupPinMux(60, GPIO_MUX_CPU1, 0);\par
00206     GPIO_SetupPinOptions(60, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00207     GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;\par
00208 \par
00209     {\cf20 // LED12}\par
00210     GPIO_SetupPinMux(61, GPIO_MUX_CPU1, 0);\par
00211     GPIO_SetupPinOptions(61, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00212     GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;\par
00213 \par
00214     {\cf20 // LED13}\par
00215     GPIO_SetupPinMux(157, GPIO_MUX_CPU1, 0);\par
00216     GPIO_SetupPinOptions(157, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00217     GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;\par
00218 \par
00219     {\cf20 // LED14}\par
00220     GPIO_SetupPinMux(158, GPIO_MUX_CPU1, 0);\par
00221     GPIO_SetupPinOptions(158, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00222     GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;\par
00223 \par
00224     {\cf20 // LED15}\par
00225     GPIO_SetupPinMux(159, GPIO_MUX_CPU1, 0);\par
00226     GPIO_SetupPinOptions(159, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00227     GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;\par
00228 \par
00229     {\cf20 // LED16}\par
00230     GPIO_SetupPinMux(160, GPIO_MUX_CPU1, 0);\par
00231     GPIO_SetupPinOptions(160, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00232     GpioDataRegs.GPFCLEAR.bit.GPIO160 = 1;\par
00233 \par
00234     {\cf20 //WIZNET Reset}\par
00235     GPIO_SetupPinMux(0, GPIO_MUX_CPU1, 0);\par
00236     GPIO_SetupPinOptions(0, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00237     GpioDataRegs.GPASET.bit.GPIO0 = 1;\par
00238 \par
00239     {\cf20 //ESP8266 Reset}\par
00240     GPIO_SetupPinMux(1, GPIO_MUX_CPU1, 0);\par
00241     GPIO_SetupPinOptions(1, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00242     GpioDataRegs.GPASET.bit.GPIO1 = 1;\par
00243 \par
00244     {\cf20 //SPIRAM  CS  Chip Select}\par
00245     GPIO_SetupPinMux(19, GPIO_MUX_CPU1, 0);\par
00246     GPIO_SetupPinOptions(19, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00247     GpioDataRegs.GPASET.bit.GPIO19 = 1;\par
00248 \par
00249     {\cf20 //DRV8874 #1 DIR  Direction}\par
00250     GPIO_SetupPinMux(29, GPIO_MUX_CPU1, 0);\par
00251     GPIO_SetupPinOptions(29, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00252     GpioDataRegs.GPASET.bit.GPIO29 = 1;\par
00253 \par
00254     {\cf20 //DRV8874 #2 DIR  Direction}\par
00255     GPIO_SetupPinMux(32, GPIO_MUX_CPU1, 0);\par
00256     GPIO_SetupPinOptions(32, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00257     GpioDataRegs.GPBSET.bit.GPIO32 = 1;\par
00258 \par
00259     {\cf20 //DAN28027  CS  Chip Select}\par
00260     GPIO_SetupPinMux(9, GPIO_MUX_CPU1, 0);\par
00261     GPIO_SetupPinOptions(9, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00262     GpioDataRegs.GPASET.bit.GPIO9 = 1;\par
00263 \par
00264     {\cf20 //MPU9250  CS  Chip Select}\par
00265     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0);\par
00266     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00267     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
00268 \par
00269     {\cf20 //WIZNET  CS  Chip Select}\par
00270     GPIO_SetupPinMux(125, GPIO_MUX_CPU1, 0);\par
00271     GPIO_SetupPinOptions(125, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00272     GpioDataRegs.GPDSET.bit.GPIO125 = 1;\par
00273 \par
00274     {\cf20 //PushButton 1}\par
00275     GPIO_SetupPinMux(4, GPIO_MUX_CPU1, 0);\par
00276     GPIO_SetupPinOptions(4, GPIO_INPUT, GPIO_PULLUP);\par
00277 \par
00278     {\cf20 //PushButton 2}\par
00279     GPIO_SetupPinMux(5, GPIO_MUX_CPU1, 0);\par
00280     GPIO_SetupPinOptions(5, GPIO_INPUT, GPIO_PULLUP);\par
00281 \par
00282     {\cf20 //PushButton 3}\par
00283     GPIO_SetupPinMux(6, GPIO_MUX_CPU1, 0);\par
00284     GPIO_SetupPinOptions(6, GPIO_INPUT, GPIO_PULLUP);\par
00285 \par
00286     {\cf20 //PushButton 4}\par
00287     GPIO_SetupPinMux(7, GPIO_MUX_CPU1, 0);\par
00288     GPIO_SetupPinOptions(7, GPIO_INPUT, GPIO_PULLUP);\par
00289 \par
00290     {\cf20 //Joy Stick Pushbutton}\par
00291     GPIO_SetupPinMux(8, GPIO_MUX_CPU1, 0);\par
00292     GPIO_SetupPinOptions(8, GPIO_INPUT, GPIO_PULLUP);\par
00293 \par
00294     {\cf20 //Ground GPIO1 Connected to BT CTS Pin}\par
00295     GpioDataRegs.GPACLEAR.bit.GPIO1 = 1;\par
00296 \par
00297     {\cf20 // Clear all interrupts and initialize PIE vector table:}\par
00298     {\cf20 // Disable CPU interrupts}\par
00299     DINT;\par
00300 \par
00301     setupSpib();{\cf20 //run SPI setup code}\par
00302 \par
00303     {\cf20 // Initialize the PIE control registers to their default state.}\par
00304     {\cf20 // The default state is all PIE interrupts disabled and flags}\par
00305     {\cf20 // are cleared.}\par
00306     {\cf20 // This function is found in the F2837xD_PieCtrl.c file.}\par
00307     InitPieCtrl();\par
00308 \par
00309     {\cf20 // Disable CPU interrupts and clear all CPU interrupt flags:}\par
00310     IER = 0x0000;\par
00311     IFR = 0x0000;\par
00312 \par
00313     {\cf20 // Initialize the PIE vector table with pointers to the shell Interrupt}\par
00314     {\cf20 // Service Routines (ISR).}\par
00315     {\cf20 // This will populate the entire table, even if the interrupt}\par
00316     {\cf20 // is not used in this example.  This is useful for debug purposes.}\par
00317     {\cf20 // The shell ISR routines are found in F2837xD_DefaultIsr.c.}\par
00318     {\cf20 // This function is found in F2837xD_PieVect.c.}\par
00319     InitPieVectTable();\par
00320 \par
00321     {\cf20 // Interrupts that are used in this example are re-mapped to}\par
00322     {\cf20 // ISR functions found within this project}\par
00323     EALLOW;  {\cf20 // This is needed to write to EALLOW protected registers}\par
00324     PieVectTable.TIMER0_INT = &cpu_timer0_isr;\par
00325     PieVectTable.TIMER1_INT = &cpu_timer1_isr;\par
00326     PieVectTable.TIMER2_INT = &cpu_timer2_isr;\par
00327     PieVectTable.SCIA_RX_INT = &RXAINT_recv_ready;\par
00328     PieVectTable.SCIC_RX_INT = &RXCINT_recv_ready;\par
00329     PieVectTable.SCID_RX_INT = &RXDINT_recv_ready;\par
00330     PieVectTable.SCIA_TX_INT = &TXAINT_data_sent;\par
00331     PieVectTable.SCIC_TX_INT = &TXCINT_data_sent;\par
00332     PieVectTable.SCID_TX_INT = &TXDINT_data_sent;\par
00333     PieVectTable.SPIB_RX_INT = &SPIB_isr;\par
00334     PieVectTable.ADCA1_INT = &ADCA_ISR;\par
00335 \par
00336     PieVectTable.EMIF_ERROR_INT = &SWI_isr;\par
00337     EDIS;    {\cf20 // This is needed to disable write to EALLOW protected registers}\par
00338 \par
00339 \par
00340     {\cf20 // Initialize the CpuTimers Device Peripheral. This function can be}\par
00341     {\cf20 // found in F2837xD_CpuTimers.c}\par
00342     InitCpuTimers();\par
00343 \par
00344     {\cf20 // Configure CPU-Timer 0, 1, and 2 to interrupt every second:}\par
00345     {\cf20 // 200MHz CPU Freq, 1 second Period (in uSeconds)}\par
00346     ConfigCpuTimer(&CpuTimer0, 200, 1000); {\cf20 //change to 1 ms}\par
00347     ConfigCpuTimer(&CpuTimer1, 200, 4000); {\cf20 //change to 4 ms}\par
00348     ConfigCpuTimer(&CpuTimer2, 200, 40000);\par
00349 \par
00350     {\cf20 // Enable CpuTimer Interrupt bit TIE}\par
00351     CpuTimer0Regs.TCR.all = 0x4000;\par
00352     CpuTimer1Regs.TCR.all = 0x4000;\par
00353     CpuTimer2Regs.TCR.all = 0x4000;\par
00354 \par
00355     init_serial(&SerialA,115200,serialRXA);\par
00356     init_serial(&SerialC,9600,serialRXC); {\cf20 //set to 9600 for Bluetooth Chip, initializations and muxing done in Serial.c}\par
00357 {\cf20 //    init_serial(&SerialD,115200,serialRXD);}\par
00358 \par
00359     {\cf20 //pwm no output}\par
00360     EALLOW;\par
00361     EPwm5Regs.ETSEL.bit.SOCAEN = 0; {\cf20 // Disable SOC on A group}\par
00362     EPwm5Regs.TBCTL.bit.CTRMODE = 3; {\cf20 // freeze counter}\par
00363     EPwm5Regs.ETSEL.bit.SOCASEL = 2; {\cf20 // Select Event when counter equal to PRD}\par
00364     EPwm5Regs.ETPS.bit.SOCAPRD = 1; {\cf20 // Generate pulse on 1st event (\'93pulse\'94 is the same as \'93trigger\'94)}\par
00365     EPwm5Regs.TBCTR = 0x0; {\cf20 // Clear counter}\par
00366     EPwm5Regs.TBPHS.bit.TBPHS = 0x0000; {\cf20 // Phase is 0}\par
00367     EPwm5Regs.TBCTL.bit.PHSEN = 0; {\cf20 // Disable phase loading}\par
00368     EPwm5Regs.TBCTL.bit.CLKDIV = 0; {\cf20 // divide by 1  50Mhz Clock}\par
00369     EPwm5Regs.TBPRD = 50000;  {\cf20 // Set Period to 1ms sample. Rampling rate: 1000 Hz}\par
00370     {\cf20 //(1/50MHz)*TBPRD = .001 s}\par
00371     {\cf20 // Notice here that we are not setting CMPA or CMPB because we are not using the PWM signal}\par
00372     EPwm5Regs.ETSEL.bit.SOCAEN = 1; {\cf20 //enable SOCA}\par
00373     EPwm5Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //unfreeze, and enter up count mode}\par
00374     EDIS;\par
00375 \par
00376     EALLOW;\par
00377     {\cf20 //write configurations for all ADCs  ADCA, ADCB, ADCC, ADCD}\par
00378     AdcaRegs.ADCCTL2.bit.PRESCALE = 6; {\cf20 //set ADCCLK divider to /4}\par
00379     {\cf20 //        AdcbRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00380     {\cf20 //        AdccRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00381     {\cf20 //        AdcdRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00382     AdcSetMode(ADC_ADCA, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  {\cf20 //read calibration settings}\par
00383     {\cf20 //        AdcSetMode(ADC_ADCB, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00384     {\cf20 //        AdcSetMode(ADC_ADCC, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00385     {\cf20 //        AdcSetMode(ADC_ADCD, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00386     {\cf20 //Set pulse positions to late}\par
00387     AdcaRegs.ADCCTL1.bit.INTPULSEPOS = 1;\par
00388     {\cf20 //        AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00389     {\cf20 //        AdccRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00390     {\cf20 //        AdcdRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00391     {\cf20 //power up the ADCs}\par
00392     AdcaRegs.ADCCTL1.bit.ADCPWDNZ = 1;\par
00393     {\cf20 //        AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00394     {\cf20 //        AdccRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00395     {\cf20 //        AdcdRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00396     {\cf20 //delay for 1ms to allow ADC time to power up}\par
00397     DELAY_US(1000);\par
00398 \par
00399 \par
00400     {\cf20 //Select the channels to convert and end of conversion flag}\par
00401     {\cf20 //Many statements commented out,  To be used when using ADCA or ADCB}\par
00402     {\cf20 //ADCA}\par
00403     AdcaRegs.ADCSOC0CTL.bit.CHSEL = 2;  {\cf20 //SOC0 will convert Channel you choose Does not have to be A0}\par
00404     AdcaRegs.ADCSOC0CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00405     AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC0}\par
00406     AdcaRegs.ADCSOC1CTL.bit.CHSEL = 3;  {\cf20 //SOC1 will convert Channel you choose Does not have to be A1}\par
00407     AdcaRegs.ADCSOC1CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00408     AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC1}\par
00409     AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = 1; {\cf20 //set to last SOC that is converted and it will set INT1 flag ADCA1}\par
00410     AdcaRegs.ADCINTSEL1N2.bit.INT1E = 1;   {\cf20 //enable INT1 flag}\par
00411     AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; {\cf20 //make sure INT1 flag is cleared}\par
00412     EDIS;\par
00413 \par
00414     {\cf20 //2A and 2B - Motors}\par
00415     EPwm2Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //count up mode}\par
00416     EPwm2Regs.TBCTL.bit.FREE_SOFT = 2; {\cf20 //free run}\par
00417     EPwm2Regs.TBCTL.bit.PHSEN = 0; {\cf20 //disable phase loading}\par
00418     EPwm2Regs.TBCTL.bit.CLKDIV = 0; {\cf20 //clock divide = 1}\par
00419     EPwm2Regs.TBCTR = 0; {\cf20 //start the timers at 0}\par
00420     EPwm2Regs.TBPRD = 2500; {\cf20 //set period to 50 microseconds (20 kHz)}\par
00421     {\cf20 // (1/50MHz)*TBPRD = 50 us}\par
00422     EPwm2Regs.CMPA.bit.CMPA = 0; {\cf20 //start duty cycle at 0%}\par
00423     EPwm2Regs.CMPB.bit.CMPB = 0; {\cf20 //start duty cycle at 0%}\par
00424     {\cf20 // duty cycle = CMPA/TBPRD}\par
00425     EPwm2Regs.AQCTLA.bit.CAU = 1; {\cf20 //clear signal when TBCTR = CMPA}\par
00426     EPwm2Regs.AQCTLB.bit.CBU = 1; {\cf20 //clear signal when TBCTR = CMPB}\par
00427     EPwm2Regs.AQCTLA.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00428     EPwm2Regs.AQCTLB.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00429     EPwm2Regs.TBPHS.bit.TBPHS = 0; {\cf20 //set phase to 0}\par
00430     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2A}\par
00431     GPIO_SetupPinMux(3, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2B}\par
00432 \par
00433     init_eQEPs(); {\cf20 //call eQEP setup function}\par
00434 \par
00435     {\cf20 // Enable CPU int1 which is connected to CPU-Timer 0, CPU int13}\par
00436     {\cf20 // which is connected to CPU-Timer 1, and CPU int 14, which is connected}\par
00437     {\cf20 // to CPU-Timer 2:  int 12 is for the SWI.  }\par
00438     IER |= M_INT1;\par
00439     IER |= M_INT8;  {\cf20 // SCIC SCID}\par
00440     IER |= M_INT9;  {\cf20 // SCIA}\par
00441     IER |= M_INT12;\par
00442     IER |= M_INT13;\par
00443     IER |= M_INT14;\par
00444     IER |= M_INT6; {\cf20 //SPI}\par
00445 \par
00446     {\cf20 // Enable TINT0 in the PIE: Group 1 interrupt 7}\par
00447     PieCtrlRegs.PIEIER1.bit.INTx7 = 1;\par
00448     {\cf20 // Enable SWI in the PIE: Group 12 interrupt 9}\par
00449     PieCtrlRegs.PIEIER12.bit.INTx9 = 1;\par
00450     {\cf20 //Enable SPI}\par
00451     PieCtrlRegs.PIEIER6.bit.INTx3 = 1;\par
00452     {\cf20 //Enable ADCA1}\par
00453     PieCtrlRegs.PIEIER1.bit.INTx1 = 1;\par
00454 \par
00455     {\cf20 // Enable global Interrupts and higher priority real-time debug events}\par
00456     EINT;  {\cf20 // Enable Global interrupt INTM}\par
00457     ERTM;  {\cf20 // Enable Global realtime interrupt DBGM}\par
00458 \par
00459 \par
00460     {\cf20 // IDLE loop. Just sit and loop forever (optional):}\par
00461     {\cf19 while}(1)\par
00462     \{\par
00463         {\cf19 if} (UARTPrint == 1 ) \{\par
00464 {\cf20 //            serial_printf(&SerialC,"Num Timer2:%ld Num SerialRX: %ld\\r\\n",CpuTimer2.InterruptCount,numRXA); //prints to BT app}\par
00465             serial_printf(&SerialC,{\cf22 "FwdBackOffset: %.2f TurnRate: %.2f\\r\\n"},FwdBackOffset, turnrate); {\cf20 //prints to BT app}\par
00466             UARTPrint = 0;\par
00467         \}\par
00468     \}\par
00469 \}\par
00470 \par
00471 \par
00472 {\cf20 // SWI_isr,  Using this interrupt as a Software started interrupt}\par
00473 __interrupt {\cf18 void} SWI_isr({\cf18 void}) \{\par
00474 \par
00475     {\cf20 // These three lines of code allow SWI_isr, to be interrupted by other interrupt functions}\par
00476     {\cf20 // making it lower priority than all other Hardware interrupts.}\par
00477     PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\par
00478     {\cf17 asm}({\cf22 "       NOP"});                    {\cf20 // Wait one cycle}\par
00479     EINT;                                 {\cf20 // Clear INTM to enable interrupts}\par
00480 \par
00481 \par
00482 \par
00483     {\cf20 // Insert SWI ISR Code here.......}\par
00484     {\cf20 //solve for filtered velocity in rads/s}\par
00485     LeftVel = .6*LeftVel_1 + 100*(LeftWheel-LeftWheel_1);\par
00486     RightVel = .6*RightVel_1 + 100*(RightWheel-RightWheel_1);\par
00487 \par
00488     {\cf20 //Turning}\par
00489     WheelDif = LeftWheel - RightWheel;\par
00490     velWheelDif = .33*velWheelDif_1 + .67*(WheelDif-WheelDif_1)/.004;\par
00491     eDif = turnref - WheelDif;\par
00492     {\cf20 //calculate iDif without integral windup}\par
00493     {\cf19 if}(fabs(turn)>3)\{\par
00494         iDif = iDif_1;\par
00495     \}{\cf19 else}\{\par
00496         iDif = iDif_1 + .004*(eDif+eDif_1)/2;\par
00497     \}\par
00498 \par
00499     {\cf20 //Calculate Balance and Turn COntrols}\par
00500     ubal = -K1*tilt_value -K2*gyro_value - K3*(LeftVel+RightVel)/2.0;\par
00501     turn = Kp*eDif + Ki*iDif - Kd*velWheelDif;\par
00502     {\cf20 //saturate turn so balance control dominates (controllefford between +-10)}\par
00503     {\cf19 if}(turn>4)\{\par
00504         turn = 4;\par
00505     \}{\cf19 else} {\cf19 if}(turn<-4)\{\par
00506         turn = -4;\par
00507     \}\par
00508 \par
00509     turnref = turnref_1 + (turnrate + turnrate_1)*.004/2.0;\par
00510 \par
00511     {\cf20 //Calculate controleffort for each motor}\par
00512     uRight = ubal/2.0 - turn + FwdBackOffset;\par
00513     uLeft = ubal/2.0 + turn + FwdBackOffset;\par
00514 \par
00515     {\cf20 //Send ControlEffort to PWM Motor Command}\par
00516     setEPWM2A(uRight);\par
00517     setEPWM2B(-uLeft);\par
00518 \par
00519     {\cf20 //Save Past States}\par
00520     LeftVel_1 = LeftVel;\par
00521     RightVel_1 = RightVel;\par
00522     LeftWheel_1 = LeftWheel;\par
00523     RightWheel_1 = RightWheel;\par
00524     eDif_1 = eDif;\par
00525     iDif_1 = iDif;\par
00526     turnrate_1 = turnrate;\par
00527     turnref_1 = turnref;\par
00528 \par
00529     numSWIcalls++;\par
00530     \par
00531     DINT;\par
00532 \par
00533 \}\par
00534 \par
00535 {\cf20 // cpu_timer0_isr - CPU Timer0 ISR}\par
00536 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void})\par
00537 \{\par
00538     CpuTimer0.InterruptCount++;\par
00539 \par
00540     numTimer0calls++;\par
00541 \par
00542 {\cf20 //    if ((numTimer0calls % 200) == 0) \{}\par
00543 {\cf20 //        UARTPrint = 1;}\par
00544 {\cf20 //    \}}\par
00545 \par
00546     {\cf20 // Blink LaunchPad Red LED}\par
00547 {\cf20 //    GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;}\par
00548 \par
00549     {\cf20 // Acknowledge this interrupt to receive more interrupts from group 1}\par
00550     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00551 \}\par
00552 \par
00553 {\cf20 // cpu_timer1_isr - CPU Timer1 ISR}\par
00554 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void})\par
00555 \{\par
00556 \par
00557     CpuTimer1.InterruptCount++;\par
00558 \}\par
00559 \par
00560 {\cf20 // cpu_timer2_isr CPU Timer2 ISR}\par
00561 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void})\par
00562 \{\par
00563 \par
00564 \par
00565     {\cf20 // Blink LaunchPad Blue LED}\par
00566 {\cf20 //    GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;}\par
00567 \par
00568     CpuTimer2.InterruptCount++;\par
00569 \par
00570 \}\par
00571 \par
00572 {\cf20 // This function is called each time a char is recieved over UARTA.}\par
00573 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data) \{\par
00574     numRXA ++;\par
00575 {\cf20 //    if (data == 'q') \{}\par
00576 {\cf20 //        turnrate = turnrate - 0.2;}\par
00577 {\cf20 //    \} else if (data == 'r') \{}\par
00578 {\cf20 //        turnrate = turnrate + 0.2;}\par
00579 {\cf20 //    \} else if (data == '3') \{}\par
00580 {\cf20 //        FwdBackOffset = FwdBackOffset - 0.2;}\par
00581 {\cf20 //    \} else if (data == 's') \{}\par
00582 {\cf20 //        FwdBackOffset = FwdBackOffset + 0.2;}\par
00583 {\cf20 //    \} else \{}\par
00584 {\cf20 //        turnrate = 0;}\par
00585 {\cf20 //        FwdBackOffset = 0;}\par
00586 {\cf20 //    \}}\par
00587 \}\par
00588 \par
00589 {\cf18 char} sendback[10];\par
00590 {\cf18 char} past[10];\par
00591 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data) \{\par
00592     sendback[0] = data;\par
00593     serial_send(&SerialA, sendback, 1); {\cf20 //every character that comes into BT will be echoed to Tera Term}\par
00594 \par
00595     {\cf20 //save past states}\par
00596     past[0] = past[1];\par
00597     past[1] = past[2];\par
00598     past[2] = past[3];\par
00599     past[3] = past[4];\par
00600     past[4] = past[5];\par
00601     past[5] = past[6];\par
00602     past[6] = past[7];\par
00603     past[7] = past[8];\par
00604     past[8] = past[9];\par
00605     past[9] = data;\par
00606 \par
00607     {\cf19 if}((past[4] == {\cf23 '6'})&&(past[9] == {\cf23 '7'}))\{\par
00608         {\cf20 //up arrow pressed, speed up '!B516!B507'}\par
00609         {\cf20 //saturate fwdbackoffset so segbot doesn't fall over}\par
00610         {\cf19 if}(FwdBackOffset <= -2)\{\par
00611             FwdBackOffset = -2;\par
00612         \}{\cf19 else}\{\par
00613             FwdBackOffset = FwdBackOffset - 0.2;\par
00614         \}\par
00615     \}{\cf19 else} {\cf19 if}((past[4] == {\cf23 '5'})&&(past[9] == {\cf23 '6'}))\{\par
00616         {\cf20 //down arrow pressed, slow down '!B615!B606'}\par
00617         {\cf20 //saturate fwdbackoffset so segbot doesn't fall over}\par
00618         {\cf19 if}(FwdBackOffset >= 2)\{\par
00619             FwdBackOffset = 2;\par
00620         \}{\cf19 else}\{\par
00621             FwdBackOffset = FwdBackOffset + 0.2;\par
00622         \}\par
00623     \}{\cf19 else} {\cf19 if}((past[4] == {\cf23 '4'})&&(past[9] == {\cf23 '5'}))\{\par
00624         {\cf20 //turn left '!B714!B705'}\par
00625         {\cf19 if}(turnrate > 0)\{\par
00626             {\cf20 //stop turning opposite direction}\par
00627             turnrate = 0;\par
00628         \}{\cf19 else}\{\par
00629             turnrate = turnrate - 0.2;\par
00630         \}\par
00631     \}{\cf19 else} {\cf19 if}((past[4] == {\cf23 '3'})&&(past[9] == {\cf23 '4'}))\{\par
00632         {\cf20 //turn right '!B813!B804'}\par
00633         {\cf19 if}(turnrate < 0)\{\par
00634             {\cf20 //stop turning opposite direction}\par
00635             turnrate = 0;\par
00636         \}{\cf19 else}\{\par
00637             turnrate = turnrate + 0.2;\par
00638         \}\par
00639     \}{\cf19 else} {\cf19 if}((past[4] == {\cf23 '9'})&&(past[9] == {\cf23 ':'}))\{\par
00640         {\cf20 //balance still if 2 is pressed}\par
00641         turnrate = 0;\par
00642         FwdBackOffset = 0;\par
00643     \}\par
00644 \}\par
00645 \par
00646 \par
00647 __interrupt {\cf18 void} ADCA_ISR({\cf18 void})\{\par
00648         adca0result = AdcaResultRegs.ADCRESULT0; {\cf20 //read ADC values}\par
00649         adca1result = AdcaResultRegs.ADCRESULT1;\par
00650 \par
00651         {\cf20 // Here covert ADCIND0, ADCIND1 to volts}\par
00652         adca0_volts = adca0result/1365.0;\par
00653         adca1_volts = adca1result/1365.0;\par
00654 \par
00655         {\cf20 //SPI Read Gyros and Accelerometers}\par
00656 \par
00657         GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00658         SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 // Issue the SPIB_RX_INT when two values are in the RX FIFO}\par
00659 \par
00660         {\cf20 //write to TXBUF}\par
00661         SpibRegs.SPITXBUF = 0x8000|0x3A00; {\cf20 //start address (one register before accel)}\par
00662         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_XOUT}\par
00663         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_YOUT}\par
00664         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_ZOUT}\par
00665         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read TEMP_OUT}\par
00666         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_XOUT}\par
00667         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_YOUT}\par
00668         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_ZOUT}\par
00669 \par
00670         AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;  {\cf20 //clear interrupt flag}\par
00671         PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00672 \}\par
00673 \par
00674 __interrupt {\cf18 void} SPIB_isr({\cf18 void})\{\par
00675 \par
00676     {\cf20 //read from RX FIFO}\par
00677     Junk = SpibRegs.SPIRXBUF; {\cf20 //garbage value read}\par
00678     accelxraw = SpibRegs.SPIRXBUF;\par
00679     accelyraw = SpibRegs.SPIRXBUF;\par
00680     accelzraw = SpibRegs.SPIRXBUF;\par
00681     Junk = SpibRegs.SPIRXBUF;\par
00682     gyroxraw = SpibRegs.SPIRXBUF;\par
00683     gyroyraw = SpibRegs.SPIRXBUF;\par
00684     gyrozraw = SpibRegs.SPIRXBUF;\par
00685 \par
00686     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00687 \par
00688     accelx = (float)(accelxraw*4.0/32767.0); {\cf20 // m/s2, this value is saturated due to offset}\par
00689     accely = (float)(accelyraw*4.0/32767.0); {\cf20 // m/s2}\par
00690     accelz = (float)(accelzraw*4.0/32767.0); {\cf20 // m/s2}\par
00691     gyrox = (float)(gyroxraw*250.0/32767.0); {\cf20 //deg per second}\par
00692     gyroy = (float)(gyroyraw*250.0/32767.0); {\cf20 //deg per second}\par
00693     gyroz = (float)(gyrozraw*250.0/32767.0); {\cf20 //deg per second}\par
00694 \par
00695 {\cf20 //    LeftWheel = -readEncLeft();}\par
00696 {\cf20 //    RightWheel = readEncRight();}\par
00697 \par
00698 {\cf20 //    //Send ControlEffort to PWM Motor Command}\par
00699 {\cf20 //    setEPWM2A(uRight);}\par
00700 {\cf20 //    setEPWM2B(-uLeft);}\par
00701 \par
00702     {\cf20 //Code to be copied into SPIB_ISR interrupt function after the IMU measurements have been collected.}\par
00703       {\cf19 if}(calibration_state == 0)\{\par
00704             calibration_count++;\par
00705             {\cf19 if} (calibration_count == 2000) \{\par
00706                 calibration_state = 1;\par
00707                 calibration_count = 0;\par
00708             \}\par
00709         \} {\cf19 else} {\cf19 if}(calibration_state == 1)\{\par
00710             accelx_offset+=accelx;\par
00711             accely_offset+=accely;\par
00712             accelz_offset+=accelz;\par
00713             gyrox_offset+=gyrox;\par
00714             gyroy_offset+=gyroy;\par
00715             gyroz_offset+=gyroz;\par
00716             calibration_count++;\par
00717             {\cf19 if} (calibration_count == 2000) \{\par
00718                 calibration_state = 2;\par
00719                 accelx_offset/=2000.0;\par
00720                 accely_offset/=2000.0;\par
00721                 accelz_offset/=2000.0;\par
00722                 gyrox_offset/=2000.0;\par
00723                 gyroy_offset/=2000.0;\par
00724                 gyroz_offset/=2000.0;\par
00725                 calibration_count = 0;\par
00726                 doneCal = 1;\par
00727             \}\par
00728 \par
00729         \} {\cf19 else} {\cf19 if}(calibration_state == 2)\{\par
00730 \par
00731             accelx -=(accelx_offset);\par
00732             accely -=(accely_offset);\par
00733             accelz -=(accelz_offset-accelzBalancePoint);\par
00734             gyrox -= gyrox_offset;\par
00735             gyroy -= gyroy_offset;\par
00736             gyroz -= gyroz_offset;\par
00737 \par
00738             {\cf20 /*--------------Kalman Filtering code start---------------------------------------------------------------------*/}\par
00739             {\cf18 float} tiltrate = (gyrox*PI)/180.0; {\cf20 // rad/s}\par
00740             {\cf18 float} pred_tilt, z, y, S;\par
00741 \par
00742             {\cf20 // Prediction Step}\par
00743             pred_tilt = kalman_tilt + T*tiltrate;\par
00744             pred_P = kalman_P + Q;\par
00745 \par
00746             {\cf20 // Update Step}\par
00747             z = -accelz;  {\cf20 // Note the negative here due to the polarity of AccelZ}\par
00748             y = z - pred_tilt;\par
00749             S = pred_P + R;\par
00750             kalman_K = pred_P/S;\par
00751             kalman_tilt = pred_tilt + kalman_K*y;\par
00752             kalman_P = (1 - kalman_K)*pred_P;\par
00753 \par
00754             SpibNumCalls++;\par
00755             {\cf20 // Kalman Filter used}\par
00756             tilt_array[SpibNumCalls] = kalman_tilt;\par
00757             gyro_array[SpibNumCalls] = tiltrate;\par
00758             LeftWheelArray[SpibNumCalls] = -readEncLeft();\par
00759             RightWheelArray[SpibNumCalls] = readEncRight();\par
00760 \par
00761             {\cf19 if} (SpibNumCalls >= 3) \{  {\cf20 // should never be greater than 3}\par
00762                 tilt_value = (tilt_array[0] + tilt_array[1] + tilt_array[2] + tilt_array[3])/4.0;\par
00763                 gyro_value = (gyro_array[0] + gyro_array[1] + gyro_array[2] + gyro_array[3])/4.0;\par
00764                 LeftWheel=(LeftWheelArray[0]+LeftWheelArray[1]+LeftWheelArray[2]+LeftWheelArray[3])/4.0;\par
00765                 RightWheel=(RightWheelArray[0]+RightWheelArray[1]+RightWheelArray[2]+RightWheelArray[3])/4.0;\par
00766                 SpibNumCalls = -1;\par
00767 \par
00768                 PieCtrlRegs.PIEIFR12.bit.INTx9 = 1;  {\cf20 // Manually cause the interrupt for the SWI}\par
00769             \}\par
00770         \}\par
00771 \par
00772         timecount++;\par
00773 \par
00774         {\cf19 if}((timecount%200) == 0)\par
00775         \{\par
00776             {\cf19 if}(doneCal == 0) \{\par
00777                 GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;  {\cf20 // Blink Blue LED while calibrating}\par
00778             \}\par
00779             GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;  {\cf20 // Always Block Red LED}\par
00780 \par
00781             UARTPrint = 1;  {\cf20 // Tell While loop to print}\par
00782         \}\par
00783 \par
00784         SpibRegs.SPIFFRX.bit.RXFFOVFCLR=1;  {\cf20 // Clear Overflow flag}\par
00785         SpibRegs.SPIFFRX.bit.RXFFINTCLR=1;  {\cf20 // Clear Interrupt flag}\par
00786         PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
00787 \}\par
00788 \par
00789 {\cf18 float} readEncLeft({\cf18 void}) \{\par
00790     int32_t raw = 0;\par
00791     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U}\par
00792 \par
00793     raw = EQep1Regs.QPOSCNT;\par
00794     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00795 \par
00796     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00797     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00798     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00799     {\cf19 return} (raw*(TWOPI/600.0)); {\cf20 //wheel rotation in radians}\par
00800 \}\par
00801 \par
00802 {\cf18 float} readEncRight({\cf18 void}) \{\par
00803 \par
00804     int32_t raw = 0;\par
00805     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U  -1 32bit signed int}\par
00806 \par
00807     raw = EQep2Regs.QPOSCNT;\par
00808     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00809 \par
00810     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00811     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00812     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00813     {\cf19 return} (raw*(TWOPI/600.0));\par
00814 \}\par
00815 \par
00816 {\cf18 void} init_eQEPs({\cf18 void}) \{\par
00817 \par
00818     {\cf20 // setup eQEP1 pins for input}\par
00819     EALLOW;\par
00820     {\cf20 //Disable internal pull-up for the selected output pins for reduced power consumption}\par
00821     GpioCtrlRegs.GPAPUD.bit.GPIO20 = 1;    {\cf20 // Disable pull-up on GPIO20 (EQEP1A)}\par
00822     GpioCtrlRegs.GPAPUD.bit.GPIO21 = 1;    {\cf20 // Disable pull-up on GPIO21 (EQEP1B)}\par
00823     GpioCtrlRegs.GPAQSEL2.bit.GPIO20 = 2;   {\cf20 // Qual every 6 samples}\par
00824     GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 2;   {\cf20 // Qual every 6 samples}\par
00825     EDIS;\par
00826     {\cf20 // This specifies which of the possible GPIO pins will be EQEP1 functional pins.}\par
00827     {\cf20 // Comment out other unwanted lines.}\par
00828     GPIO_SetupPinMux(20, GPIO_MUX_CPU1, 1);\par
00829     GPIO_SetupPinMux(21, GPIO_MUX_CPU1, 1);\par
00830     EQep1Regs.QEPCTL.bit.QPEN = 0;    {\cf20 // make sure eqep in reset}\par
00831     EQep1Regs.QDECCTL.bit.QSRC = 0;   {\cf20 // Quadrature count mode}\par
00832     EQep1Regs.QPOSCTL.all = 0x0;      {\cf20 // Disable eQep Position Compare}\par
00833     EQep1Regs.QCAPCTL.all = 0x0;      {\cf20 // Disable eQep Capture}\par
00834     EQep1Regs.QEINT.all = 0x0;        {\cf20 // Disable all eQep interrupts}\par
00835     EQep1Regs.QPOSMAX = 0xFFFFFFFF;   {\cf20 // use full range of the 32 bit count}\par
00836     EQep1Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend in Code Composer}\par
00837     EQep1Regs.QPOSCNT = 0;\par
00838     EQep1Regs.QEPCTL.bit.QPEN = 1;    {\cf20 // Enable EQep}\par
00839 \par
00840 \par
00841     {\cf20 // setup QEP2 pins for input}\par
00842     EALLOW;\par
00843     {\cf20 //Disable internal pull-up for the selected output pinsfor reduced power consumption}\par
00844     GpioCtrlRegs.GPBPUD.bit.GPIO54 = 1;    {\cf20 // Disable pull-up on GPIO54 (EQEP2A)}\par
00845     GpioCtrlRegs.GPBPUD.bit.GPIO55 = 1;    {\cf20 // Disable pull-up on GPIO55 (EQEP2B)}\par
00846     GpioCtrlRegs.GPBQSEL2.bit.GPIO54 = 2;   {\cf20 // Qual every 6 samples}\par
00847     GpioCtrlRegs.GPBQSEL2.bit.GPIO55 = 2;   {\cf20 // Qual every 6 samples}\par
00848     EDIS;\par
00849     GPIO_SetupPinMux(54, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2A}\par
00850     GPIO_SetupPinMux(55, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2B}\par
00851     EQep2Regs.QEPCTL.bit.QPEN = 0;   {\cf20 // make sure qep reset}\par
00852     EQep2Regs.QDECCTL.bit.QSRC = 0;  {\cf20 // Quadrature count mode}\par
00853     EQep2Regs.QPOSCTL.all = 0x0;     {\cf20 // Disable eQep Position Compare}\par
00854     EQep2Regs.QCAPCTL.all = 0x0;     {\cf20 // Disable eQep Capture}\par
00855     EQep2Regs.QEINT.all = 0x0;       {\cf20 // Disable all eQep interrupts}\par
00856     EQep2Regs.QPOSMAX = 0xFFFFFFFF;  {\cf20 // use full range of the 32 bit count.}\par
00857     EQep2Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend}\par
00858     EQep2Regs.QPOSCNT = 0;\par
00859     EQep2Regs.QEPCTL.bit.QPEN = 1;   {\cf20 // Enable EQep}\par
00860 \}\par
00861 \par
00862 {\cf18 void} setEPWM2A({\cf18 float} controleffort)\{\par
00863     {\cf20 //saturate value}\par
00864     {\cf19 if}(controleffort > 10)\{\par
00865         controleffort = 10;\par
00866     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
00867         controleffort = -10;\par
00868     \}\par
00869 \par
00870     EPwm2Regs.CMPA.bit.CMPA = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
00871 \}\par
00872 \par
00873 {\cf18 void} setEPWM2B({\cf18 float} controleffort)\{\par
00874     {\cf19 if}(controleffort > 10)\{\par
00875         controleffort = 10;\par
00876     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
00877         controleffort = -10;\par
00878     \}\par
00879 \par
00880     EPwm2Regs.CMPB.bit.CMPB = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
00881 \}\par
00882 \par
00883 {\cf18 void} setupSpib({\cf18 void}) {\cf20 //Call this function in main() somewhere after the DINT; line of code.}\par
00884 \{\par
00885     int16_t temp = 0; {\cf20 // for reading RXBUF}\par
00886     {\cf20 //Step 1.}\par
00887     {\cf20 // cut and paste here all the SpibRegs initializations you found for part 3. Change so that 16 bits are}\par
00888     {\cf20 //transmitted each TX FIFO write and change the delay in between each transfer to 0.}\par
00889 \par
00890     {\cf20 //lab4 setup Serial}\par
00891     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO2 and used as DAN777 SS}\par
00892     GPIO_SetupPinOptions(2, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO2 an Output Pin}\par
00893     GpioDataRegs.GPASET.bit.GPIO2 = 1; {\cf20 //Initially Set GPIO2/SS High so DAN777 is not selected}\par
00894     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO66 and used as MPU-9250 SS}\par
00895     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO66 an Output Pin}\par
00896     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 //Initially Set GPIO66/SS High so MPU-9250 is not selected}\par
00897     GPIO_SetupPinMux(63, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO63 pin to SPISIMOB}\par
00898     GPIO_SetupPinMux(64, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO64 pin to SPISOMIB}\par
00899     GPIO_SetupPinMux(65, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO65 pin to SPICLKB}\par
00900     EALLOW;\par
00901     GpioCtrlRegs.GPBPUD.bit.GPIO63 = 0; {\cf20 // Enable Pull-ups on SPI PINs Recommended by TI for SPI Pins}\par
00902     GpioCtrlRegs.GPCPUD.bit.GPIO64 = 0;\par
00903     GpioCtrlRegs.GPCPUD.bit.GPIO65 = 0;\par
00904     GpioCtrlRegs.GPBQSEL2.bit.GPIO63 = 3; {\cf20 // Set prequalifier for SPI PINS}\par
00905     GpioCtrlRegs.GPCQSEL1.bit.GPIO64 = 3; {\cf20 // The prequalifier eliminates short noise spikes}\par
00906     GpioCtrlRegs.GPCQSEL1.bit.GPIO65 = 3; {\cf20 // by making sure the serial pin stays low for 3 clock periods.}\par
00907     EDIS;\par
00908     {\cf20 // ---------------------------------------------------------------------------}\par
00909     SpibRegs.SPICCR.bit.SPISWRESET = 0; {\cf20 // Put SPI in Reset}\par
00910     SpibRegs.SPICTL.bit.CLK_PHASE = 1; {\cf20 //This happens to be the mode for both the DAN777 and}\par
00911     SpibRegs.SPICCR.bit.CLKPOLARITY = 0; {\cf20 //The MPU-9250, Mode 01.}\par
00912     SpibRegs.SPICTL.bit.MASTER_SLAVE = 1; {\cf20 // Set to SPI Master}\par
00913     SpibRegs.SPICCR.bit.SPICHAR = 15; {\cf20 // Set to transmit and receive 16 bits each write to SPITXBUF}\par
00914     SpibRegs.SPICTL.bit.TALK = 1; {\cf20 // Enable transmission}\par
00915     SpibRegs.SPIPRI.bit.FREE = 1; {\cf20 // Free run, continue SPI operation}\par
00916     SpibRegs.SPICTL.bit.SPIINTENA = 0; {\cf20 // Disables the SPI interrupt}\par
00917     SpibRegs.SPIPRI.bit.SOFT = 0; {\cf20 // This line may not be used}\par
00918     SpibRegs.SPIBRR.bit.SPI_BIT_RATE = 49; {\cf20 // Set SCLK bit rate to 1 MHz so 1us period. SPI base clock is}\par
00919     {\cf20 // 50MHZ. And this setting divides that base clock to create SCLK\'92s period, there is a +1}\par
00920     SpibRegs.SPISTS.all = 0x0000; {\cf20 // Clear status flags just in case they are set for some reason}\par
00921     SpibRegs.SPIFFTX.bit.SPIRST = 1;{\cf20 // Pull SPI FIFO out of reset, SPI FIFO can resume transmit or receive.}\par
00922     SpibRegs.SPIFFTX.bit.SPIFFENA = 1; {\cf20 // Enable SPI FIFO enhancements}\par
00923     SpibRegs.SPIFFTX.bit.TXFIFO = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
00924     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFTX[TXFFINT] flag just in case it is set}\par
00925     SpibRegs.SPIFFRX.bit.RXFIFORESET = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
00926     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFOVF] just in case it is set}\par
00927     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFINT] flag just in case it is set}\par
00928     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // RX FIFO interrupt based on RXFFIL match}\par
00929     SpibRegs.SPIFFCT.bit.TXDLY = 0; {\cf20 //Set delay between transmits to 0 spi clocks.}\par
00930     SpibRegs.SPICCR.bit.SPISWRESET = 1; {\cf20 // Pull the SPI out of reset}\par
00931     SpibRegs.SPIFFTX.bit.TXFIFO = 1; {\cf20 // Release transmit FIFO from reset.}\par
00932     SpibRegs.SPIFFRX.bit.RXFIFORESET = 1; {\cf20 // Re-enable receive FIFO operation}\par
00933     SpibRegs.SPICTL.bit.SPIINTENA = 1; {\cf20 // Enables SPI interrupt. !! I don\'92t think this is needed. Need to Test}\par
00934     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Clear Interrupt flag just in case it is set}\par
00935     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear overflow flag just in case it is set}\par
00936     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Receive FIFO interrupt flag just in case it is set.}\par
00937     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // Enable the RX FIFO Interrupt. RXFFST >= RXFFIL}\par
00938     SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 //Interrupt Level to 7 words or more received into FIFO causes interrupt}\par
00939     {\cf20 //interrupt number of words in FIFO here AND in timer}\par
00940 \par
00941     {\cf20 //  EDIS;}\par
00942 \par
00943     {\cf20 // SpibRegs.SPICCR.bit.SPICHAR = 0xF;}\par
00944     {\cf20 // SpibRegs.SPIFFCT.bit.TXDLY = 0x00;}\par
00945     {\cf20 //-----------------------------------------------------------------------------------------------------------------}\par
00946     {\cf20 //Step 2.}\par
00947     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x13,0x14,0x15,0x16}\par
00948     {\cf20 // 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C 0x1D, 0x1E, 0x1F. Use only one SS low to high for all these writes}\par
00949     {\cf20 // some code is given, most you have to fill you yourself.}\par
00950     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00951     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
00952     SpibRegs.SPITXBUF = 0x1300; {\cf20 //start address,  To address 00x13 write 0x00}\par
00953     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x14 write 0x00, To address 00x15 write 0x00}\par
00954     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x16 write 0x00, To address 00x17 write 0x00}\par
00955     SpibRegs.SPITXBUF = 0x0013; {\cf20 // To address 00x18 write 0x00, To address 00x19 write 0x13}\par
00956     SpibRegs.SPITXBUF = 0x0200;{\cf20 // To address 00x1A write 0x02, To address 00x1B write 0x00}\par
00957     SpibRegs.SPITXBUF = 0x0806;{\cf20 // To address 00x1C write 0x08, To address 00x1D write 0x06}\par
00958     SpibRegs.SPITXBUF = 0x0000;{\cf20 // To address 00x1E write 0x00, To address 00x1F write 0x00}\par
00959 \par
00960     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
00961     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=7); {\cf20 //should this be 0?}\par
00962     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00963     temp = SpibRegs.SPIRXBUF; {\cf20 // read the garbage receive values off the RX FIFO to clear}\par
00964     temp = SpibRegs.SPIRXBUF;\par
00965     temp = SpibRegs.SPIRXBUF;\par
00966     temp = SpibRegs.SPIRXBUF;\par
00967     temp = SpibRegs.SPIRXBUF;\par
00968     temp = SpibRegs.SPIRXBUF;\par
00969     temp = SpibRegs.SPIRXBUF;\par
00970     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
00971 \par
00972     {\cf20 //Step 3.}\par
00973     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x23,0x24,0x25,0x26}\par
00974     {\cf20 // 0x27, 0x28, 0x29. Use only one SS low to high for all these writes}\par
00975     {\cf20 // some code is given, most you have to fill you yourself.}\par
00976     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00977     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
00978     SpibRegs.SPITXBUF = 0x2300; {\cf20 //start address, To address 00x23 write 0x00}\par
00979     SpibRegs.SPITXBUF = 0x408C;{\cf20 // To address 00x24 write 0x40, To address 00x25 write 0x8C}\par
00980     SpibRegs.SPITXBUF = 0x0288;{\cf20 // To address 00x26 write 0x02, To address 00x27 write 0x88}\par
00981     SpibRegs.SPITXBUF = 0x0C0A;{\cf20 // To address 00x28 write 0x0C, To address 00x29 write 0x0A}\par
00982 \par
00983     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
00984     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=4);\par
00985     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00986     temp = SpibRegs.SPIRXBUF;\par
00987     temp = SpibRegs.SPIRXBUF;\par
00988     temp = SpibRegs.SPIRXBUF;\par
00989     temp = SpibRegs.SPIRXBUF;\par
00990     {\cf20 // read the additional number of garbage receive values off the RX FIFO to clear out the RX FIFO}\par
00991     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
00992 \par
00993     {\cf20 //Step 4.}\par
00994     {\cf20 // perform a single 16 bit transfer to initialize MPU-9250 register 0x2A}\par
00995     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
00996     SpibRegs.SPITXBUF = 0x2A81; {\cf20 //start address, Write to address 0x2A the value 0x81}\par
00997 \par
00998     {\cf20 // wait for one byte to be received}\par
00999     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01000     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01001     temp = SpibRegs.SPIRXBUF;\par
01002     DELAY_US(10);\par
01003 \par
01004     {\cf20 // The Remainder of this code is given to you and you do not need to make any changes.}\par
01005     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01006     SpibRegs.SPITXBUF = (0x3800 | 0x0001); {\cf20 // 0x3800}\par
01007     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01008     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01009     temp = SpibRegs.SPIRXBUF;\par
01010     DELAY_US(10);\par
01011     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01012     SpibRegs.SPITXBUF = (0x3A00 | 0x0001); {\cf20 // 0x3A00}\par
01013     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01014     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01015     temp = SpibRegs.SPIRXBUF;\par
01016     DELAY_US(10);\par
01017     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01018     SpibRegs.SPITXBUF = (0x6400 | 0x0001); {\cf20 // 0x6400}\par
01019     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01020     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01021     temp = SpibRegs.SPIRXBUF;\par
01022     DELAY_US(10);\par
01023     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01024     SpibRegs.SPITXBUF = (0x6700 | 0x0003); {\cf20 // 0x6700}\par
01025     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01026     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01027     temp = SpibRegs.SPIRXBUF;\par
01028     DELAY_US(10);\par
01029     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01030     SpibRegs.SPITXBUF = (0x6A00 | 0x0020); {\cf20 // 0x6A00}\par
01031     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01032     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01033     temp = SpibRegs.SPIRXBUF;\par
01034     DELAY_US(10);\par
01035     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01036     SpibRegs.SPITXBUF = (0x6B00 | 0x0001); {\cf20 // 0x6B00}\par
01037     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01038     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01039     temp = SpibRegs.SPIRXBUF;\par
01040     DELAY_US(10);\par
01041     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01042     SpibRegs.SPITXBUF = (0x7500 | 0x0071); {\cf20 // 0x7500}\par
01043     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01044     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01045     temp = SpibRegs.SPIRXBUF;\par
01046     DELAY_US(10);\par
01047     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01048 {\cf20 //    SpibRegs.SPITXBUF = (0x7700 | 0x00EB); // 0x7700}\par
01049     SpibRegs.SPITXBUF = (0x7700 | 0x0000); {\cf20 // 0x7700}\par
01050     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01051     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01052     temp = SpibRegs.SPIRXBUF;\par
01053     DELAY_US(10);\par
01054     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01055 {\cf20 //    SpibRegs.SPITXBUF = (0x7800 | 0x0012); // 0x7800}\par
01056     SpibRegs.SPITXBUF = (0x7800 | 0x0000); {\cf20 // 0x7800}\par
01057     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01058     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01059     temp = SpibRegs.SPIRXBUF;\par
01060     DELAY_US(10);\par
01061     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01062     SpibRegs.SPITXBUF = (0x7A00 | 0x0010); {\cf20 // 0x7A00}\par
01063     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01064     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01065     temp = SpibRegs.SPIRXBUF;\par
01066     DELAY_US(10);\par
01067     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01068     SpibRegs.SPITXBUF = (0x7B00 | 0x00FA); {\cf20 // 0x7B00}\par
01069     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01070     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01071     temp = SpibRegs.SPIRXBUF;\par
01072     DELAY_US(10);\par
01073     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01074     SpibRegs.SPITXBUF = (0x7D00 | 0x0021); {\cf20 // 0x7D00}\par
01075     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01076     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01077     temp = SpibRegs.SPIRXBUF;\par
01078     DELAY_US(10);\par
01079     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01080     SpibRegs.SPITXBUF = (0x7E00 | 0x0050); {\cf20 // 0x7E00}\par
01081     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01082     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01083     temp = SpibRegs.SPIRXBUF;\par
01084     DELAY_US(50);\par
01085 \par
01086     {\cf20 // Clear SPIB interrupt source just in case it was issued due to any of the above initializations.}\par
01087     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear Overflow flag}\par
01088     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Interrupt flag}\par
01089     PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
01090 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot2.c File Reference\par \pard\plain 
{\tc\tcl2 \v UART_Segbot2.c}
{\xe \v UART_Segbot2.c}
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
{\f2 #include "driverlib.h"}\par
{\f2 #include "device.h"}\par
{\f2 #include "f28379dSerial.h"}\par
{\f2 #include "LEDPatterns.h"}\par
{\f2 #include "song.h"}\par
{\f2 #include "dsp.h"}\par
{\f2 #include "fpu32/fpu_rfft.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union {\b phonedata_s}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PI}\~ 3.1415926535897932384626433832795\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWOPI}\~ 6.283185307179586476925286766559\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HALFPI}\~ 1.5707963267948966192313216916398\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef union {\b phonedata_s} {\b phonedata_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer0_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer1_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer2_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SWI_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SPIB_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b ADCA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupSpib} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXA} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXC} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_eQEPs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncLeft} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncRight} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2A} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2B} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b main} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b phonedata_t} {\b phoneaccel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numTimer0calls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numSWIcalls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numRXA} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LEDdisplaynum} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b Junk} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelzraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyrozraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ubal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K1} = -60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K2} = -7.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K3} = -1.1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uLeft} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uRight} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turn} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kp} = 3.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Ki} = 20.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kd} = .01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b FwdBackOffset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca0_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca1_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca0result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca1result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelzBalancePoint} = -.73\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16 {\b IMU_data} [9]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b temp} =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b doneCal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b T} = 0.001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Q} = 0.01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b R} = 25000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_tilt} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_P} = 22.365\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b SpibNumCalls} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pred_P} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_K} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b timecount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b calibration_state} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b calibration_count} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_x} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_y} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_z} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sendback} [10]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b past} [14]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HALFPI\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:HALFPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HALFPI\~ 1.5707963267948966192313216916398}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v PI\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PI\~ 3.1415926535897932384626433832795}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v TWOPI\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:TWOPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWOPI\~ 6.283185307179586476925286766559}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b UART_Segbot2.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v phonedata_t\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:phonedata_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef union {\b phonedata_s} {\b phonedata_t}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ADCA_ISR\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:ADCA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void ADCA_ISR (void )}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 655} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v cpu_timer0_isr\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:cpu_timer0_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer0_isr (void )}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 550} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v cpu_timer1_isr\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:cpu_timer1_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer1_isr (void )}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 568} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v cpu_timer2_isr\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:cpu_timer2_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer2_isr (void )}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 575} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v init_eQEPs\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:init_eQEPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_eQEPs (void )}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 824} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v main\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void main (void )}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v readEncLeft\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:readEncLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncLeft (void )}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 797} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v readEncRight\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:readEncRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncRight (void )}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 810} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v serialRXA\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:serialRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXA ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 587} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v serialRXC\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:serialRXC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXC ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 605} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v setEPWM2A\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:setEPWM2A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2A (float controleffort)}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 870} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v setEPWM2B\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:setEPWM2B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2B (float controleffort)}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 881} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v setupSpib\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:setupSpib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setupSpib (void )}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 891} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v SPIB_isr\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:SPIB_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SPIB_isr (void )}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 682} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v SWI_isr\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:SWI_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SWI_isr (void )}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 487} of file {\b UART_Segbot2.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v accelx\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx = 0}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accelx_offset\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelx_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx_offset = 0}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accelxraw\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelxraw = 0}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accely\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely = 0}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accely_offset\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accely_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely_offset = 0}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accelyraw\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelyraw = 0}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accelz\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz = 0}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accelz_offset\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz_offset = 0}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accelzBalancePoint\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelzBalancePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelzBalancePoint = -.73}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v accelzraw\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:accelzraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelzraw = 0}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v adca0_volts\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:adca0_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca0_volts = 0}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v adca0result\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:adca0result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca0result = 0}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v adca1_volts\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:adca1_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca1_volts = 0}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v adca1result\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:adca1result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca1result = 0}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v ble_x\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:ble_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_x = 0}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v ble_y\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:ble_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_y = 0}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v ble_z\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:ble_z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_z = 0}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v calibration_count\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:calibration_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t calibration_count = 0}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v calibration_state\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:calibration_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t calibration_state = 0}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v doneCal\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:doneCal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t doneCal = 0}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v eDif\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:eDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif = 0}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v eDif_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:eDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif_1 = 0}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v FwdBackOffset\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:FwdBackOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float FwdBackOffset = 0}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyro_array\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyro_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyro_value\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyro_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_value = 0}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyrox\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyrox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox = 0}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyrox_offset\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyrox_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox_offset = 0}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyroxraw\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyroxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroxraw = 0}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyroy\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy = 0}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyroy_offset\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyroy_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy_offset = 0}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyroyraw\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyroyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroyraw = 0}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyroz\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyroz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz = 0}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyroz_offset\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyroz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz_offset = 0}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v gyrozraw\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:gyrozraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyrozraw = 0}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v iDif\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:iDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif = 0}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v iDif_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:iDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif_1 = 0}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v IMU_data\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:IMU_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16 IMU_data[9]}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v Junk\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:Junk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Junk = 0}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v K1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:K1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K1 = -60}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v K2\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:K2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K2 = -7.0}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v K3\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:K3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K3 = -1.1}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v kalman_K\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:kalman_K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_K = 0}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v kalman_P\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:kalman_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_P = 22.365}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v kalman_tilt\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:kalman_tilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_tilt = 0}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v Kd\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:Kd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kd = .01}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v Ki\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:Ki}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Ki = 20.0}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v Kp\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:Kp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kp = 3.0}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v LEDdisplaynum\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:LEDdisplaynum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LEDdisplaynum = 0}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v LeftVel\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:LeftVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel = 0}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v LeftVel_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:LeftVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel_1 = 0}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v LeftWheel\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:LeftWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel = 0}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v LeftWheel_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:LeftWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel_1 = 0}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v LeftWheelArray\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:LeftWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v numRXA\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:numRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numRXA = 0}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v numSWIcalls\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:numSWIcalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numSWIcalls = 0}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v numTimer0calls\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:numTimer0calls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numTimer0calls = 0}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v past\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:past}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char past[14]}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 604} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v phoneaccel\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:phoneaccel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b phonedata_t} phoneaccel}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v pred_P\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:pred_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float pred_P = 0}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v Q\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:Q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Q = 0.01}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v R\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:R}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float R = 25000}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v RightVel\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:RightVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel = 0}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v RightVel_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:RightVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel_1 = 0}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v RightWheel\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:RightWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel = 0}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v RightWheel_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:RightWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel_1 = 0}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v RightWheelArray\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:RightWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v sendback\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:sendback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char sendback[10]}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 603} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v SpibNumCalls\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:SpibNumCalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SpibNumCalls = -1}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v T\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float T = 0.001}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v temp\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t temp =0}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v tilt_array\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:tilt_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v tilt_value\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:tilt_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_value = 0}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v timecount\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:timecount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t timecount = 0}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v turn\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turn = 0}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v turnrate\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:turnrate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate = 0}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v turnrate_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:turnrate_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate_1 = 0}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v turnref\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:turnref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref = 0}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v turnref_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:turnref_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref_1 = 0}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v UARTPrint\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:UARTPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint = 0}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v ubal\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:ubal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ubal = 0}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v uLeft\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:uLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uLeft = 5.0}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v uRight\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:uRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uRight = 5.0}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v velWheelDif\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:velWheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif = 0}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v velWheelDif_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:velWheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v WheelDif\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:WheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif = 0}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b UART_Segbot2.c}.}\par
}
{\xe \v WheelDif_1\:UART_Segbot2.c}
{\xe \v UART_Segbot2.c\:WheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b UART_Segbot2.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot2.c\par \pard\plain 
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //#############################################################################}\par
00002 {\cf20 //UART_Segbot read accelerometer}\par
00003 {\cf20 //#############################################################################}\par
00004 \par
00005 {\cf20 // Included Files}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 {\cf21 #include <stdarg.h>}\par
00009 {\cf21 #include <string.h>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include <limits.h>}\par
00012 {\cf21 #include "F28x_Project.h"}\par
00013 {\cf21 #include "driverlib.h"}\par
00014 {\cf21 #include "device.h"}\par
00015 {\cf21 #include "f28379dSerial.h"}\par
00016 {\cf21 #include "LEDPatterns.h"}\par
00017 {\cf21 #include "song.h"}\par
00018 {\cf21 #include "dsp.h"}\par
00019 {\cf21 #include "fpu32/fpu_rfft.h"}\par
00020 \par
00021 {\cf21 #define PI          3.1415926535897932384626433832795}\par
00022 {\cf21 #define TWOPI       6.283185307179586476925286766559}\par
00023 {\cf21 #define HALFPI      1.5707963267948966192313216916398}\par
00024 \par
00025 \par
00026 {\cf20 // Interrupt Service Routines predefinition}\par
00027 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void});\par
00028 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void});\par
00029 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void});\par
00030 __interrupt {\cf18 void} SWI_isr({\cf18 void});\par
00031 __interrupt {\cf18 void} SPIB_isr({\cf18 void});\par
00032 __interrupt {\cf18 void} ADCA_ISR({\cf18 void});\par
00033 \par
00034 {\cf18 void} setupSpib({\cf18 void});\par
00035 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data);\par
00036 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data);\par
00037 {\cf18 void} init_eQEPs({\cf18 void});\par
00038 {\cf18 float} readEncLeft({\cf18 void});\par
00039 {\cf18 float} readEncRight({\cf18 void});\par
00040 {\cf18 void} setEPWM2A({\cf18 float});\par
00041 {\cf18 void} setEPWM2B({\cf18 float});\par
00042 \par
00043 {\cf17 typedef} {\cf17 union }phonedata_s\{\par
00044     uint16_t rawdata[6];\par
00045     {\cf18 float} fltdata[3];\par
00046 \par
00047 \}phonedata_t;\par
00048 phonedata_t phoneaccel; {\cf20 //use new data type defined in union}\par
00049 \par
00050 {\cf20 // Count variables}\par
00051 uint32_t numTimer0calls = 0;\par
00052 uint32_t numSWIcalls = 0;\par
00053 uint32_t numRXA = 0;\par
00054 uint16_t UARTPrint = 0;\par
00055 uint16_t LEDdisplaynum = 0;\par
00056 \par
00057 int16_t Junk = 0;\par
00058 \par
00059 int16_t accelxraw = 0;\par
00060 int16_t accelyraw = 0;\par
00061 int16_t accelzraw = 0;\par
00062 int16_t gyroxraw = 0;\par
00063 int16_t gyroyraw = 0;\par
00064 int16_t gyrozraw = 0;\par
00065 \par
00066 {\cf18 float} accelx = 0;\par
00067 {\cf18 float} accely = 0;\par
00068 {\cf18 float} accelz = 0;\par
00069 {\cf18 float} gyrox = 0;\par
00070 {\cf18 float} gyroy = 0;\par
00071 {\cf18 float} gyroz = 0;\par
00072 {\cf18 float} LeftWheel = 0;\par
00073 {\cf18 float} RightWheel = 0;\par
00074 {\cf18 float} LeftWheel_1 = 0;\par
00075 {\cf18 float} RightWheel_1 = 0;\par
00076 {\cf18 float} LeftVel = 0;\par
00077 {\cf18 float} RightVel = 0;\par
00078 {\cf18 float} LeftVel_1 = 0;\par
00079 {\cf18 float} RightVel_1 = 0;\par
00080 {\cf18 float} ubal = 0;\par
00081 {\cf18 float} K1 = -60;\par
00082 {\cf20 //float K2 = -4.5;}\par
00083 {\cf18 float} K2 = -7.0;\par
00084 {\cf18 float} K3 = -1.1;\par
00085 {\cf18 float} WheelDif = 0;\par
00086 {\cf18 float} velWheelDif = 0;\par
00087 {\cf18 float} WheelDif_1 = 0;\par
00088 {\cf18 float} velWheelDif_1 = 0;\par
00089 {\cf18 float} turnref = 0;\par
00090 {\cf18 float} turnref_1 = 0;\par
00091 {\cf18 float} uLeft = 5.0;\par
00092 {\cf18 float} uRight = 5.0;\par
00093 {\cf18 float} eDif = 0;\par
00094 {\cf18 float} iDif = 0;\par
00095 {\cf18 float} eDif_1 = 0;\par
00096 {\cf18 float} iDif_1 = 0;\par
00097 {\cf18 float} turn = 0; {\cf20 //turn setpoint}\par
00098 {\cf18 float} Kp = 3.0;\par
00099 {\cf18 float} Ki = 20.0;\par
00100 {\cf20 //float Kd = .08;}\par
00101 {\cf18 float} Kd = .01;\par
00102 {\cf18 float} FwdBackOffset = 0;\par
00103 {\cf18 float} turnrate = 0;\par
00104 {\cf18 float} turnrate_1 = 0;\par
00105 \par
00106 \par
00107 {\cf20 //lab4 variables}\par
00108 {\cf18 float} adca0_volts = 0;\par
00109 {\cf18 float} adca1_volts = 0;\par
00110 int16_t adca0result = 0;\par
00111 int16_t adca1result = 0;\par
00112 \par
00113 {\cf20 // Needed global Variables}\par
00114 {\cf18 float} accelx_offset = 0;\par
00115 {\cf18 float} accely_offset = 0;\par
00116 {\cf18 float} accelz_offset = 0;\par
00117 {\cf18 float} gyrox_offset  = 0;\par
00118 {\cf18 float} gyroy_offset  = 0;\par
00119 {\cf18 float} gyroz_offset  = 0;\par
00120 {\cf20 //float accelzBalancePoint = -.76; // tune this}\par
00121 {\cf18 float} accelzBalancePoint = -.73;\par
00122 int16 IMU_data[9];\par
00123 uint16_t temp=0;\par
00124 int16_t doneCal = 0;\par
00125 {\cf18 float} tilt_value    = 0;\par
00126 {\cf18 float} tilt_array[4] = \{0, 0, 0, 0\};\par
00127 {\cf18 float} gyro_value    = 0;\par
00128 {\cf18 float} gyro_array[4] = \{0, 0, 0, 0\};\par
00129 {\cf18 float} LeftWheelArray[4] = \{0,0,0,0\};\par
00130 {\cf18 float} RightWheelArray[4] = \{0,0,0,0\};\par
00131 {\cf20 // Kalman Filter vars}\par
00132 {\cf18 float} T = 0.001;        {\cf20 //sample rate, 1ms}\par
00133 {\cf18 float} Q = 0.01; {\cf20 // made global to enable changing in runtime}\par
00134 {\cf18 float} R = 25000;{\cf20 //50000;}\par
00135 {\cf18 float} kalman_tilt = 0;\par
00136 {\cf18 float} kalman_P = 22.365;\par
00137 int16_t SpibNumCalls = -1;\par
00138 {\cf18 float} pred_P = 0;\par
00139 {\cf18 float} kalman_K = 0;\par
00140 int32_t timecount = 0;\par
00141 int16_t calibration_state = 0;\par
00142 int32_t calibration_count = 0;\par
00143 \par
00144 {\cf20 //BLE DATA}\par
00145 {\cf18 float} ble_x = 0;\par
00146 {\cf18 float} ble_y = 0;\par
00147 {\cf18 float} ble_z = 0;\par
00148 \par
00149 {\cf18 void} main({\cf18 void})\par
00150  \{\par
00151     {\cf20 // PLL, WatchDog, enable Peripheral Clocks}\par
00152     {\cf20 // This example function is found in the F2837xD_SysCtrl.c file.}\par
00153     InitSysCtrl();\par
00154 \par
00155     InitGpio();\par
00156 \par
00157     {\cf20 // Blue LED on LuanchPad}\par
00158     GPIO_SetupPinMux(31, GPIO_MUX_CPU1, 0);\par
00159     GPIO_SetupPinOptions(31, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00160     GpioDataRegs.GPASET.bit.GPIO31 = 1;\par
00161 \par
00162     {\cf20 // Red LED on LaunchPad}\par
00163     GPIO_SetupPinMux(34, GPIO_MUX_CPU1, 0);\par
00164     GPIO_SetupPinOptions(34, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00165     GpioDataRegs.GPBSET.bit.GPIO34 = 1;\par
00166 \par
00167     {\cf20 // LED1 and PWM Pin}\par
00168     GPIO_SetupPinMux(22, GPIO_MUX_CPU1, 0);\par
00169     GPIO_SetupPinOptions(22, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00170     GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;\par
00171 \par
00172     {\cf20 // LED2}\par
00173     GPIO_SetupPinMux(94, GPIO_MUX_CPU1, 0);\par
00174     GPIO_SetupPinOptions(94, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00175     GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;\par
00176 \par
00177     {\cf20 // LED3}\par
00178     GPIO_SetupPinMux(95, GPIO_MUX_CPU1, 0);\par
00179     GPIO_SetupPinOptions(95, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00180     GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;\par
00181 \par
00182     {\cf20 // LED4}\par
00183     GPIO_SetupPinMux(97, GPIO_MUX_CPU1, 0);\par
00184     GPIO_SetupPinOptions(97, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00185     GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;\par
00186 \par
00187     {\cf20 // LED5}\par
00188     GPIO_SetupPinMux(111, GPIO_MUX_CPU1, 0);\par
00189     GPIO_SetupPinOptions(111, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00190     GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;\par
00191 \par
00192     {\cf20 // LED6}\par
00193     GPIO_SetupPinMux(130, GPIO_MUX_CPU1, 0);\par
00194     GPIO_SetupPinOptions(130, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00195     GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;\par
00196 \par
00197     {\cf20 // LED7}\par
00198     GPIO_SetupPinMux(131, GPIO_MUX_CPU1, 0);\par
00199     GPIO_SetupPinOptions(131, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00200     GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;\par
00201 \par
00202     {\cf20 // LED8}\par
00203     GPIO_SetupPinMux(25, GPIO_MUX_CPU1, 0);\par
00204     GPIO_SetupPinOptions(25, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00205     GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;\par
00206 \par
00207     {\cf20 // LED9}\par
00208     GPIO_SetupPinMux(26, GPIO_MUX_CPU1, 0);\par
00209     GPIO_SetupPinOptions(26, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00210     GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;\par
00211 \par
00212     {\cf20 // LED10}\par
00213     GPIO_SetupPinMux(27, GPIO_MUX_CPU1, 0);\par
00214     GPIO_SetupPinOptions(27, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00215     GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;\par
00216 \par
00217     {\cf20 // LED11}\par
00218     GPIO_SetupPinMux(60, GPIO_MUX_CPU1, 0);\par
00219     GPIO_SetupPinOptions(60, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00220     GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;\par
00221 \par
00222     {\cf20 // LED12}\par
00223     GPIO_SetupPinMux(61, GPIO_MUX_CPU1, 0);\par
00224     GPIO_SetupPinOptions(61, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00225     GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;\par
00226 \par
00227     {\cf20 // LED13}\par
00228     GPIO_SetupPinMux(157, GPIO_MUX_CPU1, 0);\par
00229     GPIO_SetupPinOptions(157, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00230     GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;\par
00231 \par
00232     {\cf20 // LED14}\par
00233     GPIO_SetupPinMux(158, GPIO_MUX_CPU1, 0);\par
00234     GPIO_SetupPinOptions(158, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00235     GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;\par
00236 \par
00237     {\cf20 // LED15}\par
00238     GPIO_SetupPinMux(159, GPIO_MUX_CPU1, 0);\par
00239     GPIO_SetupPinOptions(159, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00240     GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;\par
00241 \par
00242     {\cf20 // LED16}\par
00243     GPIO_SetupPinMux(160, GPIO_MUX_CPU1, 0);\par
00244     GPIO_SetupPinOptions(160, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00245     GpioDataRegs.GPFCLEAR.bit.GPIO160 = 1;\par
00246 \par
00247     {\cf20 //WIZNET Reset}\par
00248     GPIO_SetupPinMux(0, GPIO_MUX_CPU1, 0);\par
00249     GPIO_SetupPinOptions(0, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00250     GpioDataRegs.GPASET.bit.GPIO0 = 1;\par
00251 \par
00252     {\cf20 //ESP8266 Reset}\par
00253     GPIO_SetupPinMux(1, GPIO_MUX_CPU1, 0);\par
00254     GPIO_SetupPinOptions(1, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00255     GpioDataRegs.GPASET.bit.GPIO1 = 1;\par
00256 \par
00257     {\cf20 //SPIRAM  CS  Chip Select}\par
00258     GPIO_SetupPinMux(19, GPIO_MUX_CPU1, 0);\par
00259     GPIO_SetupPinOptions(19, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00260     GpioDataRegs.GPASET.bit.GPIO19 = 1;\par
00261 \par
00262     {\cf20 //DRV8874 #1 DIR  Direction}\par
00263     GPIO_SetupPinMux(29, GPIO_MUX_CPU1, 0);\par
00264     GPIO_SetupPinOptions(29, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00265     GpioDataRegs.GPASET.bit.GPIO29 = 1;\par
00266 \par
00267     {\cf20 //DRV8874 #2 DIR  Direction}\par
00268     GPIO_SetupPinMux(32, GPIO_MUX_CPU1, 0);\par
00269     GPIO_SetupPinOptions(32, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00270     GpioDataRegs.GPBSET.bit.GPIO32 = 1;\par
00271 \par
00272     {\cf20 //DAN28027  CS  Chip Select}\par
00273     GPIO_SetupPinMux(9, GPIO_MUX_CPU1, 0);\par
00274     GPIO_SetupPinOptions(9, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00275     GpioDataRegs.GPASET.bit.GPIO9 = 1;\par
00276 \par
00277     {\cf20 //MPU9250  CS  Chip Select}\par
00278     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0);\par
00279     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00280     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
00281 \par
00282     {\cf20 //WIZNET  CS  Chip Select}\par
00283     GPIO_SetupPinMux(125, GPIO_MUX_CPU1, 0);\par
00284     GPIO_SetupPinOptions(125, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00285     GpioDataRegs.GPDSET.bit.GPIO125 = 1;\par
00286 \par
00287     {\cf20 //PushButton 1}\par
00288     GPIO_SetupPinMux(4, GPIO_MUX_CPU1, 0);\par
00289     GPIO_SetupPinOptions(4, GPIO_INPUT, GPIO_PULLUP);\par
00290 \par
00291     {\cf20 //PushButton 2}\par
00292     GPIO_SetupPinMux(5, GPIO_MUX_CPU1, 0);\par
00293     GPIO_SetupPinOptions(5, GPIO_INPUT, GPIO_PULLUP);\par
00294 \par
00295     {\cf20 //PushButton 3}\par
00296     GPIO_SetupPinMux(6, GPIO_MUX_CPU1, 0);\par
00297     GPIO_SetupPinOptions(6, GPIO_INPUT, GPIO_PULLUP);\par
00298 \par
00299     {\cf20 //PushButton 4}\par
00300     GPIO_SetupPinMux(7, GPIO_MUX_CPU1, 0);\par
00301     GPIO_SetupPinOptions(7, GPIO_INPUT, GPIO_PULLUP);\par
00302 \par
00303     {\cf20 //Joy Stick Pushbutton}\par
00304     GPIO_SetupPinMux(8, GPIO_MUX_CPU1, 0);\par
00305     GPIO_SetupPinOptions(8, GPIO_INPUT, GPIO_PULLUP);\par
00306 \par
00307     {\cf20 //Ground GPIO1 Connected to BT CTS Pin}\par
00308     GpioDataRegs.GPACLEAR.bit.GPIO1 = 1;\par
00309 \par
00310     {\cf20 // Clear all interrupts and initialize PIE vector table:}\par
00311     {\cf20 // Disable CPU interrupts}\par
00312     DINT;\par
00313 \par
00314     setupSpib();{\cf20 //run SPI setup code}\par
00315 \par
00316     {\cf20 // Initialize the PIE control registers to their default state.}\par
00317     {\cf20 // The default state is all PIE interrupts disabled and flags}\par
00318     {\cf20 // are cleared.}\par
00319     {\cf20 // This function is found in the F2837xD_PieCtrl.c file.}\par
00320     InitPieCtrl();\par
00321 \par
00322     {\cf20 // Disable CPU interrupts and clear all CPU interrupt flags:}\par
00323     IER = 0x0000;\par
00324     IFR = 0x0000;\par
00325 \par
00326     {\cf20 // Initialize the PIE vector table with pointers to the shell Interrupt}\par
00327     {\cf20 // Service Routines (ISR).}\par
00328     {\cf20 // This will populate the entire table, even if the interrupt}\par
00329     {\cf20 // is not used in this example.  This is useful for debug purposes.}\par
00330     {\cf20 // The shell ISR routines are found in F2837xD_DefaultIsr.c.}\par
00331     {\cf20 // This function is found in F2837xD_PieVect.c.}\par
00332     InitPieVectTable();\par
00333 \par
00334     {\cf20 // Interrupts that are used in this example are re-mapped to}\par
00335     {\cf20 // ISR functions found within this project}\par
00336     EALLOW;  {\cf20 // This is needed to write to EALLOW protected registers}\par
00337     PieVectTable.TIMER0_INT = &cpu_timer0_isr;\par
00338     PieVectTable.TIMER1_INT = &cpu_timer1_isr;\par
00339     PieVectTable.TIMER2_INT = &cpu_timer2_isr;\par
00340     PieVectTable.SCIA_RX_INT = &RXAINT_recv_ready;\par
00341     PieVectTable.SCIC_RX_INT = &RXCINT_recv_ready;\par
00342     PieVectTable.SCID_RX_INT = &RXDINT_recv_ready;\par
00343     PieVectTable.SCIA_TX_INT = &TXAINT_data_sent;\par
00344     PieVectTable.SCIC_TX_INT = &TXCINT_data_sent;\par
00345     PieVectTable.SCID_TX_INT = &TXDINT_data_sent;\par
00346     PieVectTable.SPIB_RX_INT = &SPIB_isr;\par
00347     PieVectTable.ADCA1_INT = &ADCA_ISR;\par
00348 \par
00349     PieVectTable.EMIF_ERROR_INT = &SWI_isr;\par
00350     EDIS;    {\cf20 // This is needed to disable write to EALLOW protected registers}\par
00351 \par
00352 \par
00353     {\cf20 // Initialize the CpuTimers Device Peripheral. This function can be}\par
00354     {\cf20 // found in F2837xD_CpuTimers.c}\par
00355     InitCpuTimers();\par
00356 \par
00357     {\cf20 // Configure CPU-Timer 0, 1, and 2 to interrupt every second:}\par
00358     {\cf20 // 200MHz CPU Freq, 1 second Period (in uSeconds)}\par
00359     ConfigCpuTimer(&CpuTimer0, 200, 1000); {\cf20 //change to 1 ms}\par
00360     ConfigCpuTimer(&CpuTimer1, 200, 4000); {\cf20 //change to 4 ms}\par
00361     ConfigCpuTimer(&CpuTimer2, 200, 40000);\par
00362 \par
00363     {\cf20 // Enable CpuTimer Interrupt bit TIE}\par
00364     CpuTimer0Regs.TCR.all = 0x4000;\par
00365     CpuTimer1Regs.TCR.all = 0x4000;\par
00366     CpuTimer2Regs.TCR.all = 0x4000;\par
00367 \par
00368     init_serial(&SerialA,115200,serialRXA);\par
00369     init_serial(&SerialC,9600,serialRXC); {\cf20 //set to 9600 for Bluetooth Chip, initializations and muxing done in Serial.c}\par
00370 {\cf20 //    init_serial(&SerialD,115200,serialRXD);}\par
00371 \par
00372     {\cf20 //pwm no output}\par
00373     EALLOW;\par
00374     EPwm5Regs.ETSEL.bit.SOCAEN = 0; {\cf20 // Disable SOC on A group}\par
00375     EPwm5Regs.TBCTL.bit.CTRMODE = 3; {\cf20 // freeze counter}\par
00376     EPwm5Regs.ETSEL.bit.SOCASEL = 2; {\cf20 // Select Event when counter equal to PRD}\par
00377     EPwm5Regs.ETPS.bit.SOCAPRD = 1; {\cf20 // Generate pulse on 1st event (\'93pulse\'94 is the same as \'93trigger\'94)}\par
00378     EPwm5Regs.TBCTR = 0x0; {\cf20 // Clear counter}\par
00379     EPwm5Regs.TBPHS.bit.TBPHS = 0x0000; {\cf20 // Phase is 0}\par
00380     EPwm5Regs.TBCTL.bit.PHSEN = 0; {\cf20 // Disable phase loading}\par
00381     EPwm5Regs.TBCTL.bit.CLKDIV = 0; {\cf20 // divide by 1  50Mhz Clock}\par
00382     EPwm5Regs.TBPRD = 50000;  {\cf20 // Set Period to 1ms sample. Rampling rate: 1000 Hz}\par
00383     {\cf20 //(1/50MHz)*TBPRD = .001 s}\par
00384     {\cf20 // Notice here that we are not setting CMPA or CMPB because we are not using the PWM signal}\par
00385     EPwm5Regs.ETSEL.bit.SOCAEN = 1; {\cf20 //enable SOCA}\par
00386     EPwm5Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //unfreeze, and enter up count mode}\par
00387     EDIS;\par
00388 \par
00389     EALLOW;\par
00390     {\cf20 //write configurations for all ADCs  ADCA, ADCB, ADCC, ADCD}\par
00391     AdcaRegs.ADCCTL2.bit.PRESCALE = 6; {\cf20 //set ADCCLK divider to /4}\par
00392     {\cf20 //        AdcbRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00393     {\cf20 //        AdccRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00394     {\cf20 //        AdcdRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00395     AdcSetMode(ADC_ADCA, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  {\cf20 //read calibration settings}\par
00396     {\cf20 //        AdcSetMode(ADC_ADCB, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00397     {\cf20 //        AdcSetMode(ADC_ADCC, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00398     {\cf20 //        AdcSetMode(ADC_ADCD, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00399     {\cf20 //Set pulse positions to late}\par
00400     AdcaRegs.ADCCTL1.bit.INTPULSEPOS = 1;\par
00401     {\cf20 //        AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00402     {\cf20 //        AdccRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00403     {\cf20 //        AdcdRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00404     {\cf20 //power up the ADCs}\par
00405     AdcaRegs.ADCCTL1.bit.ADCPWDNZ = 1;\par
00406     {\cf20 //        AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00407     {\cf20 //        AdccRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00408     {\cf20 //        AdcdRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00409     {\cf20 //delay for 1ms to allow ADC time to power up}\par
00410     DELAY_US(1000);\par
00411 \par
00412 \par
00413     {\cf20 //Select the channels to convert and end of conversion flag}\par
00414     {\cf20 //Many statements commented out,  To be used when using ADCA or ADCB}\par
00415     {\cf20 //ADCA}\par
00416     AdcaRegs.ADCSOC0CTL.bit.CHSEL = 2;  {\cf20 //SOC0 will convert Channel you choose Does not have to be A0}\par
00417     AdcaRegs.ADCSOC0CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00418     AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC0}\par
00419     AdcaRegs.ADCSOC1CTL.bit.CHSEL = 3;  {\cf20 //SOC1 will convert Channel you choose Does not have to be A1}\par
00420     AdcaRegs.ADCSOC1CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00421     AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC1}\par
00422     AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = 1; {\cf20 //set to last SOC that is converted and it will set INT1 flag ADCA1}\par
00423     AdcaRegs.ADCINTSEL1N2.bit.INT1E = 1;   {\cf20 //enable INT1 flag}\par
00424     AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; {\cf20 //make sure INT1 flag is cleared}\par
00425     EDIS;\par
00426 \par
00427     {\cf20 //2A and 2B - Motors}\par
00428     EPwm2Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //count up mode}\par
00429     EPwm2Regs.TBCTL.bit.FREE_SOFT = 2; {\cf20 //free run}\par
00430     EPwm2Regs.TBCTL.bit.PHSEN = 0; {\cf20 //disable phase loading}\par
00431     EPwm2Regs.TBCTL.bit.CLKDIV = 0; {\cf20 //clock divide = 1}\par
00432     EPwm2Regs.TBCTR = 0; {\cf20 //start the timers at 0}\par
00433     EPwm2Regs.TBPRD = 2500; {\cf20 //set period to 50 microseconds (20 kHz)}\par
00434     {\cf20 // (1/50MHz)*TBPRD = 50 us}\par
00435     EPwm2Regs.CMPA.bit.CMPA = 0; {\cf20 //start duty cycle at 0%}\par
00436     EPwm2Regs.CMPB.bit.CMPB = 0; {\cf20 //start duty cycle at 0%}\par
00437     {\cf20 // duty cycle = CMPA/TBPRD}\par
00438     EPwm2Regs.AQCTLA.bit.CAU = 1; {\cf20 //clear signal when TBCTR = CMPA}\par
00439     EPwm2Regs.AQCTLB.bit.CBU = 1; {\cf20 //clear signal when TBCTR = CMPB}\par
00440     EPwm2Regs.AQCTLA.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00441     EPwm2Regs.AQCTLB.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00442     EPwm2Regs.TBPHS.bit.TBPHS = 0; {\cf20 //set phase to 0}\par
00443     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2A}\par
00444     GPIO_SetupPinMux(3, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2B}\par
00445 \par
00446     init_eQEPs(); {\cf20 //call eQEP setup function}\par
00447 \par
00448     {\cf20 // Enable CPU int1 which is connected to CPU-Timer 0, CPU int13}\par
00449     {\cf20 // which is connected to CPU-Timer 1, and CPU int 14, which is connected}\par
00450     {\cf20 // to CPU-Timer 2:  int 12 is for the SWI.  }\par
00451     IER |= M_INT1;\par
00452     IER |= M_INT8;  {\cf20 // SCIC SCID}\par
00453     IER |= M_INT9;  {\cf20 // SCIA}\par
00454     IER |= M_INT12;\par
00455     IER |= M_INT13;\par
00456     IER |= M_INT14;\par
00457     IER |= M_INT6; {\cf20 //SPI}\par
00458 \par
00459     {\cf20 // Enable TINT0 in the PIE: Group 1 interrupt 7}\par
00460     PieCtrlRegs.PIEIER1.bit.INTx7 = 1;\par
00461     {\cf20 // Enable SWI in the PIE: Group 12 interrupt 9}\par
00462     PieCtrlRegs.PIEIER12.bit.INTx9 = 1;\par
00463     {\cf20 //Enable SPI}\par
00464     PieCtrlRegs.PIEIER6.bit.INTx3 = 1;\par
00465     {\cf20 //Enable ADCA1}\par
00466     PieCtrlRegs.PIEIER1.bit.INTx1 = 1;\par
00467 \par
00468     {\cf20 // Enable global Interrupts and higher priority real-time debug events}\par
00469     EINT;  {\cf20 // Enable Global interrupt INTM}\par
00470     ERTM;  {\cf20 // Enable Global realtime interrupt DBGM}\par
00471 \par
00472 \par
00473     {\cf20 // IDLE loop. Just sit and loop forever (optional):}\par
00474     {\cf19 while}(1)\par
00475     \{\par
00476         {\cf19 if} (UARTPrint == 1 ) \{\par
00477 {\cf20 //            serial_printf(&SerialC,"Num Timer2:%ld Num SerialRX: %ld\\r\\n",CpuTimer2.InterruptCount,numRXA); //prints to BT app}\par
00478 {\cf20 //            serial_printf(&SerialC,"FwdBackOffset: %.2f TurnRate: %.2f\\r\\n",FwdBackOffset, turnrate); //prints to BT app}\par
00479             serial_printf(&SerialA,{\cf22 "X: %.2f Y: %.2f Z: %.2f\\r\\n"},ble_x, ble_y, ble_z);{\cf20 //print acceleration data from phone to tera term}\par
00480             UARTPrint = 0;\par
00481         \}\par
00482     \}\par
00483 \}\par
00484 \par
00485 \par
00486 {\cf20 // SWI_isr,  Using this interrupt as a Software started interrupt}\par
00487 __interrupt {\cf18 void} SWI_isr({\cf18 void}) \{\par
00488 \par
00489     {\cf20 // These three lines of code allow SWI_isr, to be interrupted by other interrupt functions}\par
00490     {\cf20 // making it lower priority than all other Hardware interrupts.}\par
00491     PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\par
00492     {\cf17 asm}({\cf22 "       NOP"});                    {\cf20 // Wait one cycle}\par
00493     EINT;                                 {\cf20 // Clear INTM to enable interrupts}\par
00494 \par
00495 \par
00496 \par
00497     {\cf20 // Insert SWI ISR Code here.......}\par
00498     {\cf20 //solve for filtered velocity in rads/s}\par
00499     LeftVel = .6*LeftVel_1 + 100*(LeftWheel-LeftWheel_1);\par
00500     RightVel = .6*RightVel_1 + 100*(RightWheel-RightWheel_1);\par
00501 \par
00502     {\cf20 //Turning}\par
00503     WheelDif = LeftWheel - RightWheel;\par
00504     velWheelDif = .33*velWheelDif_1 + .67*(WheelDif-WheelDif_1)/.004;\par
00505     eDif = turnref - WheelDif;\par
00506     {\cf20 //calculate iDif without integral windup}\par
00507     {\cf19 if}(fabs(turn)>3)\{\par
00508         iDif = iDif_1;\par
00509     \}{\cf19 else}\{\par
00510         iDif = iDif_1 + .004*(eDif+eDif_1)/2;\par
00511     \}\par
00512 \par
00513     {\cf20 //Calculate Balance and Turn COntrols}\par
00514     ubal = -K1*tilt_value -K2*gyro_value - K3*(LeftVel+RightVel)/2.0;\par
00515     turn = Kp*eDif + Ki*iDif - Kd*velWheelDif;\par
00516     {\cf20 //saturate turn so balance control dominates (controllefford between +-10)}\par
00517     {\cf19 if}(turn>4)\{\par
00518         turn = 4;\par
00519     \}{\cf19 else} {\cf19 if}(turn<-4)\{\par
00520         turn = -4;\par
00521     \}\par
00522 \par
00523     turnref = turnref_1 + (turnrate + turnrate_1)*.004/2.0;\par
00524 \par
00525     {\cf20 //Calculate controleffort for each motor}\par
00526     uRight = ubal/2.0 - turn + FwdBackOffset;\par
00527     uLeft = ubal/2.0 + turn + FwdBackOffset;\par
00528 \par
00529     {\cf20 //Send ControlEffort to PWM Motor Command}\par
00530     setEPWM2A(uRight);\par
00531     setEPWM2B(-uLeft);\par
00532 \par
00533     {\cf20 //Save Past States}\par
00534     LeftVel_1 = LeftVel;\par
00535     RightVel_1 = RightVel;\par
00536     LeftWheel_1 = LeftWheel;\par
00537     RightWheel_1 = RightWheel;\par
00538     eDif_1 = eDif;\par
00539     iDif_1 = iDif;\par
00540     turnrate_1 = turnrate;\par
00541     turnref_1 = turnref;\par
00542 \par
00543     numSWIcalls++;\par
00544     \par
00545     DINT;\par
00546 \par
00547 \}\par
00548 \par
00549 {\cf20 // cpu_timer0_isr - CPU Timer0 ISR}\par
00550 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void})\par
00551 \{\par
00552     CpuTimer0.InterruptCount++;\par
00553 \par
00554     numTimer0calls++;\par
00555 \par
00556 {\cf20 //    if ((numTimer0calls % 200) == 0) \{}\par
00557 {\cf20 //        UARTPrint = 1;}\par
00558 {\cf20 //    \}}\par
00559 \par
00560     {\cf20 // Blink LaunchPad Red LED}\par
00561 {\cf20 //    GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;}\par
00562 \par
00563     {\cf20 // Acknowledge this interrupt to receive more interrupts from group 1}\par
00564     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00565 \}\par
00566 \par
00567 {\cf20 // cpu_timer1_isr - CPU Timer1 ISR}\par
00568 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void})\par
00569 \{\par
00570 \par
00571     CpuTimer1.InterruptCount++;\par
00572 \}\par
00573 \par
00574 {\cf20 // cpu_timer2_isr CPU Timer2 ISR}\par
00575 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void})\par
00576 \{\par
00577 \par
00578 \par
00579     {\cf20 // Blink LaunchPad Blue LED}\par
00580 {\cf20 //    GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;}\par
00581 \par
00582     CpuTimer2.InterruptCount++;\par
00583 \par
00584 \}\par
00585 \par
00586 {\cf20 // This function is called each time a char is recieved over UARTA.}\par
00587 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data) \{\par
00588     numRXA ++;\par
00589 {\cf20 //    if (data == 'q') \{}\par
00590 {\cf20 //        turnrate = turnrate - 0.2;}\par
00591 {\cf20 //    \} else if (data == 'r') \{}\par
00592 {\cf20 //        turnrate = turnrate + 0.2;}\par
00593 {\cf20 //    \} else if (data == '3') \{}\par
00594 {\cf20 //        FwdBackOffset = FwdBackOffset - 0.2;}\par
00595 {\cf20 //    \} else if (data == 's') \{}\par
00596 {\cf20 //        FwdBackOffset = FwdBackOffset + 0.2;}\par
00597 {\cf20 //    \} else \{}\par
00598 {\cf20 //        turnrate = 0;}\par
00599 {\cf20 //        FwdBackOffset = 0;}\par
00600 {\cf20 //    \}}\par
00601 \}\par
00602 \par
00603 {\cf18 char} sendback[10];\par
00604 {\cf18 char} past[14];\par
00605 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data) \{\par
00606 {\cf20 //    sendback[0] = data;}\par
00607 {\cf20 //    serial_send(&SerialA, sendback, 1); //every character that comes into BT will be echoed to Tera Term}\par
00608 \par
00609     {\cf20 //save past states}\par
00610     past[0] = past[1];\par
00611     past[1] = past[2];\par
00612     past[2] = past[3];\par
00613     past[3] = past[4];\par
00614     past[4] = past[5];\par
00615     past[5] = past[6];\par
00616     past[6] = past[7];\par
00617     past[7] = past[8];\par
00618     past[8] = past[9];\par
00619     past[9] = past[10];\par
00620     past[10] = past[11];\par
00621     past[11] = past[12];\par
00622     past[12] = past[13];\par
00623     past[13] = data;\par
00624 \par
00625     {\cf19 if}((past[0] == {\cf23 '!'})&&(past[1] == {\cf23 'A'}))\{\par
00626         {\cf20 //incoming accelerometer data (arbitrary start point 0)}\par
00627 \par
00628         {\cf20 //float is a 32-bit value (4x8-bit)}\par
00629         {\cf20 //mantissa*2^exp where mantissa takes ~upper 21 bits and ~lower 10 is exponent}\par
00630         {\cf20 //meaning it is not a standard ascii}\par
00631         {\cf20 //create a union}\par
00632         {\cf20 //there will be six 16-bit ints that make up 3 floats}\par
00633         {\cf20 //for a union, takes up same place in memory}\par
00634         {\cf20 //float comes over in 4 8 bit chunks}\par
00635 \par
00636         {\cf20 //X}\par
00637         phoneaccel.rawdata[0] = (past[3]<<8)|past[2];\par
00638         phoneaccel.rawdata[1] = (past[5]<<8)|past[4];\par
00639         {\cf20 //Y}\par
00640         phoneaccel.rawdata[2] = (past[7]<<8)|past[6];\par
00641         phoneaccel.rawdata[3] = (past[9]<<8)|past[8];\par
00642         {\cf20 //Z}\par
00643         phoneaccel.rawdata[4] = (past[11]<<8)|past[10];\par
00644         phoneaccel.rawdata[5] = (past[13]<<8)|past[12];\par
00645 \par
00646         ble_x = phoneaccel.fltdata[0];\par
00647         ble_y = phoneaccel.fltdata[1];\par
00648         ble_z = phoneaccel.fltdata[2];\par
00649 \par
00650         UARTPrint = 1;\par
00651     \}\par
00652 \}\par
00653 \par
00654 \par
00655 __interrupt {\cf18 void} ADCA_ISR({\cf18 void})\{\par
00656         adca0result = AdcaResultRegs.ADCRESULT0; {\cf20 //read ADC values}\par
00657         adca1result = AdcaResultRegs.ADCRESULT1;\par
00658 \par
00659         {\cf20 // Here covert ADCIND0, ADCIND1 to volts}\par
00660         adca0_volts = adca0result/1365.0;\par
00661         adca1_volts = adca1result/1365.0;\par
00662 \par
00663         {\cf20 //SPI Read Gyros and Accelerometers}\par
00664 \par
00665         GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00666         SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 // Issue the SPIB_RX_INT when two values are in the RX FIFO}\par
00667 \par
00668         {\cf20 //write to TXBUF}\par
00669         SpibRegs.SPITXBUF = 0x8000|0x3A00; {\cf20 //start address (one register before accel)}\par
00670         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_XOUT}\par
00671         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_YOUT}\par
00672         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_ZOUT}\par
00673         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read TEMP_OUT}\par
00674         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_XOUT}\par
00675         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_YOUT}\par
00676         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_ZOUT}\par
00677 \par
00678         AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;  {\cf20 //clear interrupt flag}\par
00679         PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00680 \}\par
00681 \par
00682 __interrupt {\cf18 void} SPIB_isr({\cf18 void})\{\par
00683 \par
00684     {\cf20 //read from RX FIFO}\par
00685     Junk = SpibRegs.SPIRXBUF; {\cf20 //garbage value read}\par
00686     accelxraw = SpibRegs.SPIRXBUF;\par
00687     accelyraw = SpibRegs.SPIRXBUF;\par
00688     accelzraw = SpibRegs.SPIRXBUF;\par
00689     Junk = SpibRegs.SPIRXBUF;\par
00690     gyroxraw = SpibRegs.SPIRXBUF;\par
00691     gyroyraw = SpibRegs.SPIRXBUF;\par
00692     gyrozraw = SpibRegs.SPIRXBUF;\par
00693 \par
00694     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00695 \par
00696     accelx = (float)(accelxraw*4.0/32767.0); {\cf20 // m/s2, this value is saturated due to offset}\par
00697     accely = (float)(accelyraw*4.0/32767.0); {\cf20 // m/s2}\par
00698     accelz = (float)(accelzraw*4.0/32767.0); {\cf20 // m/s2}\par
00699     gyrox = (float)(gyroxraw*250.0/32767.0); {\cf20 //deg per second}\par
00700     gyroy = (float)(gyroyraw*250.0/32767.0); {\cf20 //deg per second}\par
00701     gyroz = (float)(gyrozraw*250.0/32767.0); {\cf20 //deg per second}\par
00702 \par
00703 {\cf20 //    LeftWheel = -readEncLeft();}\par
00704 {\cf20 //    RightWheel = readEncRight();}\par
00705 \par
00706 {\cf20 //    //Send ControlEffort to PWM Motor Command}\par
00707 {\cf20 //    setEPWM2A(uRight);}\par
00708 {\cf20 //    setEPWM2B(-uLeft);}\par
00709 \par
00710     {\cf20 //Code to be copied into SPIB_ISR interrupt function after the IMU measurements have been collected.}\par
00711       {\cf19 if}(calibration_state == 0)\{\par
00712             calibration_count++;\par
00713             {\cf19 if} (calibration_count == 2000) \{\par
00714                 calibration_state = 1;\par
00715                 calibration_count = 0;\par
00716             \}\par
00717         \} {\cf19 else} {\cf19 if}(calibration_state == 1)\{\par
00718             accelx_offset+=accelx;\par
00719             accely_offset+=accely;\par
00720             accelz_offset+=accelz;\par
00721             gyrox_offset+=gyrox;\par
00722             gyroy_offset+=gyroy;\par
00723             gyroz_offset+=gyroz;\par
00724             calibration_count++;\par
00725             {\cf19 if} (calibration_count == 2000) \{\par
00726                 calibration_state = 2;\par
00727                 accelx_offset/=2000.0;\par
00728                 accely_offset/=2000.0;\par
00729                 accelz_offset/=2000.0;\par
00730                 gyrox_offset/=2000.0;\par
00731                 gyroy_offset/=2000.0;\par
00732                 gyroz_offset/=2000.0;\par
00733                 calibration_count = 0;\par
00734                 doneCal = 1;\par
00735             \}\par
00736 \par
00737         \} {\cf19 else} {\cf19 if}(calibration_state == 2)\{\par
00738 \par
00739             accelx -=(accelx_offset);\par
00740             accely -=(accely_offset);\par
00741             accelz -=(accelz_offset-accelzBalancePoint);\par
00742             gyrox -= gyrox_offset;\par
00743             gyroy -= gyroy_offset;\par
00744             gyroz -= gyroz_offset;\par
00745 \par
00746             {\cf20 /*--------------Kalman Filtering code start---------------------------------------------------------------------*/}\par
00747             {\cf18 float} tiltrate = (gyrox*PI)/180.0; {\cf20 // rad/s}\par
00748             {\cf18 float} pred_tilt, z, y, S;\par
00749 \par
00750             {\cf20 // Prediction Step}\par
00751             pred_tilt = kalman_tilt + T*tiltrate;\par
00752             pred_P = kalman_P + Q;\par
00753 \par
00754             {\cf20 // Update Step}\par
00755             z = -accelz;  {\cf20 // Note the negative here due to the polarity of AccelZ}\par
00756             y = z - pred_tilt;\par
00757             S = pred_P + R;\par
00758             kalman_K = pred_P/S;\par
00759             kalman_tilt = pred_tilt + kalman_K*y;\par
00760             kalman_P = (1 - kalman_K)*pred_P;\par
00761 \par
00762             SpibNumCalls++;\par
00763             {\cf20 // Kalman Filter used}\par
00764             tilt_array[SpibNumCalls] = kalman_tilt;\par
00765             gyro_array[SpibNumCalls] = tiltrate;\par
00766             LeftWheelArray[SpibNumCalls] = -readEncLeft();\par
00767             RightWheelArray[SpibNumCalls] = readEncRight();\par
00768 \par
00769             {\cf19 if} (SpibNumCalls >= 3) \{  {\cf20 // should never be greater than 3}\par
00770                 tilt_value = (tilt_array[0] + tilt_array[1] + tilt_array[2] + tilt_array[3])/4.0;\par
00771                 gyro_value = (gyro_array[0] + gyro_array[1] + gyro_array[2] + gyro_array[3])/4.0;\par
00772                 LeftWheel=(LeftWheelArray[0]+LeftWheelArray[1]+LeftWheelArray[2]+LeftWheelArray[3])/4.0;\par
00773                 RightWheel=(RightWheelArray[0]+RightWheelArray[1]+RightWheelArray[2]+RightWheelArray[3])/4.0;\par
00774                 SpibNumCalls = -1;\par
00775 \par
00776                 PieCtrlRegs.PIEIFR12.bit.INTx9 = 1;  {\cf20 // Manually cause the interrupt for the SWI}\par
00777             \}\par
00778         \}\par
00779 \par
00780         timecount++;\par
00781 \par
00782         {\cf19 if}((timecount%200) == 0)\par
00783         \{\par
00784             {\cf19 if}(doneCal == 0) \{\par
00785                 GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;  {\cf20 // Blink Blue LED while calibrating}\par
00786             \}\par
00787             GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;  {\cf20 // Always Block Red LED}\par
00788 \par
00789 {\cf20 //            UARTPrint = 1;  // Tell While loop to print}\par
00790         \}\par
00791 \par
00792         SpibRegs.SPIFFRX.bit.RXFFOVFCLR=1;  {\cf20 // Clear Overflow flag}\par
00793         SpibRegs.SPIFFRX.bit.RXFFINTCLR=1;  {\cf20 // Clear Interrupt flag}\par
00794         PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
00795 \}\par
00796 \par
00797 {\cf18 float} readEncLeft({\cf18 void}) \{\par
00798     int32_t raw = 0;\par
00799     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U}\par
00800 \par
00801     raw = EQep1Regs.QPOSCNT;\par
00802     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00803 \par
00804     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00805     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00806     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00807     {\cf19 return} (raw*(TWOPI/600.0)); {\cf20 //wheel rotation in radians}\par
00808 \}\par
00809 \par
00810 {\cf18 float} readEncRight({\cf18 void}) \{\par
00811 \par
00812     int32_t raw = 0;\par
00813     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U  -1 32bit signed int}\par
00814 \par
00815     raw = EQep2Regs.QPOSCNT;\par
00816     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00817 \par
00818     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00819     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00820     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00821     {\cf19 return} (raw*(TWOPI/600.0));\par
00822 \}\par
00823 \par
00824 {\cf18 void} init_eQEPs({\cf18 void}) \{\par
00825 \par
00826     {\cf20 // setup eQEP1 pins for input}\par
00827     EALLOW;\par
00828     {\cf20 //Disable internal pull-up for the selected output pins for reduced power consumption}\par
00829     GpioCtrlRegs.GPAPUD.bit.GPIO20 = 1;    {\cf20 // Disable pull-up on GPIO20 (EQEP1A)}\par
00830     GpioCtrlRegs.GPAPUD.bit.GPIO21 = 1;    {\cf20 // Disable pull-up on GPIO21 (EQEP1B)}\par
00831     GpioCtrlRegs.GPAQSEL2.bit.GPIO20 = 2;   {\cf20 // Qual every 6 samples}\par
00832     GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 2;   {\cf20 // Qual every 6 samples}\par
00833     EDIS;\par
00834     {\cf20 // This specifies which of the possible GPIO pins will be EQEP1 functional pins.}\par
00835     {\cf20 // Comment out other unwanted lines.}\par
00836     GPIO_SetupPinMux(20, GPIO_MUX_CPU1, 1);\par
00837     GPIO_SetupPinMux(21, GPIO_MUX_CPU1, 1);\par
00838     EQep1Regs.QEPCTL.bit.QPEN = 0;    {\cf20 // make sure eqep in reset}\par
00839     EQep1Regs.QDECCTL.bit.QSRC = 0;   {\cf20 // Quadrature count mode}\par
00840     EQep1Regs.QPOSCTL.all = 0x0;      {\cf20 // Disable eQep Position Compare}\par
00841     EQep1Regs.QCAPCTL.all = 0x0;      {\cf20 // Disable eQep Capture}\par
00842     EQep1Regs.QEINT.all = 0x0;        {\cf20 // Disable all eQep interrupts}\par
00843     EQep1Regs.QPOSMAX = 0xFFFFFFFF;   {\cf20 // use full range of the 32 bit count}\par
00844     EQep1Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend in Code Composer}\par
00845     EQep1Regs.QPOSCNT = 0;\par
00846     EQep1Regs.QEPCTL.bit.QPEN = 1;    {\cf20 // Enable EQep}\par
00847 \par
00848 \par
00849     {\cf20 // setup QEP2 pins for input}\par
00850     EALLOW;\par
00851     {\cf20 //Disable internal pull-up for the selected output pinsfor reduced power consumption}\par
00852     GpioCtrlRegs.GPBPUD.bit.GPIO54 = 1;    {\cf20 // Disable pull-up on GPIO54 (EQEP2A)}\par
00853     GpioCtrlRegs.GPBPUD.bit.GPIO55 = 1;    {\cf20 // Disable pull-up on GPIO55 (EQEP2B)}\par
00854     GpioCtrlRegs.GPBQSEL2.bit.GPIO54 = 2;   {\cf20 // Qual every 6 samples}\par
00855     GpioCtrlRegs.GPBQSEL2.bit.GPIO55 = 2;   {\cf20 // Qual every 6 samples}\par
00856     EDIS;\par
00857     GPIO_SetupPinMux(54, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2A}\par
00858     GPIO_SetupPinMux(55, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2B}\par
00859     EQep2Regs.QEPCTL.bit.QPEN = 0;   {\cf20 // make sure qep reset}\par
00860     EQep2Regs.QDECCTL.bit.QSRC = 0;  {\cf20 // Quadrature count mode}\par
00861     EQep2Regs.QPOSCTL.all = 0x0;     {\cf20 // Disable eQep Position Compare}\par
00862     EQep2Regs.QCAPCTL.all = 0x0;     {\cf20 // Disable eQep Capture}\par
00863     EQep2Regs.QEINT.all = 0x0;       {\cf20 // Disable all eQep interrupts}\par
00864     EQep2Regs.QPOSMAX = 0xFFFFFFFF;  {\cf20 // use full range of the 32 bit count.}\par
00865     EQep2Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend}\par
00866     EQep2Regs.QPOSCNT = 0;\par
00867     EQep2Regs.QEPCTL.bit.QPEN = 1;   {\cf20 // Enable EQep}\par
00868 \}\par
00869 \par
00870 {\cf18 void} setEPWM2A({\cf18 float} controleffort)\{\par
00871     {\cf20 //saturate value}\par
00872     {\cf19 if}(controleffort > 10)\{\par
00873         controleffort = 10;\par
00874     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
00875         controleffort = -10;\par
00876     \}\par
00877 \par
00878     EPwm2Regs.CMPA.bit.CMPA = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
00879 \}\par
00880 \par
00881 {\cf18 void} setEPWM2B({\cf18 float} controleffort)\{\par
00882     {\cf19 if}(controleffort > 10)\{\par
00883         controleffort = 10;\par
00884     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
00885         controleffort = -10;\par
00886     \}\par
00887 \par
00888     EPwm2Regs.CMPB.bit.CMPB = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
00889 \}\par
00890 \par
00891 {\cf18 void} setupSpib({\cf18 void}) {\cf20 //Call this function in main() somewhere after the DINT; line of code.}\par
00892 \{\par
00893     int16_t temp = 0; {\cf20 // for reading RXBUF}\par
00894     {\cf20 //Step 1.}\par
00895     {\cf20 // cut and paste here all the SpibRegs initializations you found for part 3. Change so that 16 bits are}\par
00896     {\cf20 //transmitted each TX FIFO write and change the delay in between each transfer to 0.}\par
00897 \par
00898     {\cf20 //lab4 setup Serial}\par
00899     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO2 and used as DAN777 SS}\par
00900     GPIO_SetupPinOptions(2, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO2 an Output Pin}\par
00901     GpioDataRegs.GPASET.bit.GPIO2 = 1; {\cf20 //Initially Set GPIO2/SS High so DAN777 is not selected}\par
00902     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO66 and used as MPU-9250 SS}\par
00903     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO66 an Output Pin}\par
00904     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 //Initially Set GPIO66/SS High so MPU-9250 is not selected}\par
00905     GPIO_SetupPinMux(63, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO63 pin to SPISIMOB}\par
00906     GPIO_SetupPinMux(64, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO64 pin to SPISOMIB}\par
00907     GPIO_SetupPinMux(65, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO65 pin to SPICLKB}\par
00908     EALLOW;\par
00909     GpioCtrlRegs.GPBPUD.bit.GPIO63 = 0; {\cf20 // Enable Pull-ups on SPI PINs Recommended by TI for SPI Pins}\par
00910     GpioCtrlRegs.GPCPUD.bit.GPIO64 = 0;\par
00911     GpioCtrlRegs.GPCPUD.bit.GPIO65 = 0;\par
00912     GpioCtrlRegs.GPBQSEL2.bit.GPIO63 = 3; {\cf20 // Set prequalifier for SPI PINS}\par
00913     GpioCtrlRegs.GPCQSEL1.bit.GPIO64 = 3; {\cf20 // The prequalifier eliminates short noise spikes}\par
00914     GpioCtrlRegs.GPCQSEL1.bit.GPIO65 = 3; {\cf20 // by making sure the serial pin stays low for 3 clock periods.}\par
00915     EDIS;\par
00916     {\cf20 // ---------------------------------------------------------------------------}\par
00917     SpibRegs.SPICCR.bit.SPISWRESET = 0; {\cf20 // Put SPI in Reset}\par
00918     SpibRegs.SPICTL.bit.CLK_PHASE = 1; {\cf20 //This happens to be the mode for both the DAN777 and}\par
00919     SpibRegs.SPICCR.bit.CLKPOLARITY = 0; {\cf20 //The MPU-9250, Mode 01.}\par
00920     SpibRegs.SPICTL.bit.MASTER_SLAVE = 1; {\cf20 // Set to SPI Master}\par
00921     SpibRegs.SPICCR.bit.SPICHAR = 15; {\cf20 // Set to transmit and receive 16 bits each write to SPITXBUF}\par
00922     SpibRegs.SPICTL.bit.TALK = 1; {\cf20 // Enable transmission}\par
00923     SpibRegs.SPIPRI.bit.FREE = 1; {\cf20 // Free run, continue SPI operation}\par
00924     SpibRegs.SPICTL.bit.SPIINTENA = 0; {\cf20 // Disables the SPI interrupt}\par
00925     SpibRegs.SPIPRI.bit.SOFT = 0; {\cf20 // This line may not be used}\par
00926     SpibRegs.SPIBRR.bit.SPI_BIT_RATE = 49; {\cf20 // Set SCLK bit rate to 1 MHz so 1us period. SPI base clock is}\par
00927     {\cf20 // 50MHZ. And this setting divides that base clock to create SCLK\'92s period, there is a +1}\par
00928     SpibRegs.SPISTS.all = 0x0000; {\cf20 // Clear status flags just in case they are set for some reason}\par
00929     SpibRegs.SPIFFTX.bit.SPIRST = 1;{\cf20 // Pull SPI FIFO out of reset, SPI FIFO can resume transmit or receive.}\par
00930     SpibRegs.SPIFFTX.bit.SPIFFENA = 1; {\cf20 // Enable SPI FIFO enhancements}\par
00931     SpibRegs.SPIFFTX.bit.TXFIFO = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
00932     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFTX[TXFFINT] flag just in case it is set}\par
00933     SpibRegs.SPIFFRX.bit.RXFIFORESET = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
00934     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFOVF] just in case it is set}\par
00935     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFINT] flag just in case it is set}\par
00936     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // RX FIFO interrupt based on RXFFIL match}\par
00937     SpibRegs.SPIFFCT.bit.TXDLY = 0; {\cf20 //Set delay between transmits to 0 spi clocks.}\par
00938     SpibRegs.SPICCR.bit.SPISWRESET = 1; {\cf20 // Pull the SPI out of reset}\par
00939     SpibRegs.SPIFFTX.bit.TXFIFO = 1; {\cf20 // Release transmit FIFO from reset.}\par
00940     SpibRegs.SPIFFRX.bit.RXFIFORESET = 1; {\cf20 // Re-enable receive FIFO operation}\par
00941     SpibRegs.SPICTL.bit.SPIINTENA = 1; {\cf20 // Enables SPI interrupt. !! I don\'92t think this is needed. Need to Test}\par
00942     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Clear Interrupt flag just in case it is set}\par
00943     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear overflow flag just in case it is set}\par
00944     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Receive FIFO interrupt flag just in case it is set.}\par
00945     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // Enable the RX FIFO Interrupt. RXFFST >= RXFFIL}\par
00946     SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 //Interrupt Level to 7 words or more received into FIFO causes interrupt}\par
00947     {\cf20 //interrupt number of words in FIFO here AND in timer}\par
00948 \par
00949     {\cf20 //  EDIS;}\par
00950 \par
00951     {\cf20 // SpibRegs.SPICCR.bit.SPICHAR = 0xF;}\par
00952     {\cf20 // SpibRegs.SPIFFCT.bit.TXDLY = 0x00;}\par
00953     {\cf20 //-----------------------------------------------------------------------------------------------------------------}\par
00954     {\cf20 //Step 2.}\par
00955     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x13,0x14,0x15,0x16}\par
00956     {\cf20 // 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C 0x1D, 0x1E, 0x1F. Use only one SS low to high for all these writes}\par
00957     {\cf20 // some code is given, most you have to fill you yourself.}\par
00958     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00959     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
00960     SpibRegs.SPITXBUF = 0x1300; {\cf20 //start address,  To address 00x13 write 0x00}\par
00961     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x14 write 0x00, To address 00x15 write 0x00}\par
00962     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x16 write 0x00, To address 00x17 write 0x00}\par
00963     SpibRegs.SPITXBUF = 0x0013; {\cf20 // To address 00x18 write 0x00, To address 00x19 write 0x13}\par
00964     SpibRegs.SPITXBUF = 0x0200;{\cf20 // To address 00x1A write 0x02, To address 00x1B write 0x00}\par
00965     SpibRegs.SPITXBUF = 0x0806;{\cf20 // To address 00x1C write 0x08, To address 00x1D write 0x06}\par
00966     SpibRegs.SPITXBUF = 0x0000;{\cf20 // To address 00x1E write 0x00, To address 00x1F write 0x00}\par
00967 \par
00968     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
00969     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=7); {\cf20 //should this be 0?}\par
00970     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00971     temp = SpibRegs.SPIRXBUF; {\cf20 // read the garbage receive values off the RX FIFO to clear}\par
00972     temp = SpibRegs.SPIRXBUF;\par
00973     temp = SpibRegs.SPIRXBUF;\par
00974     temp = SpibRegs.SPIRXBUF;\par
00975     temp = SpibRegs.SPIRXBUF;\par
00976     temp = SpibRegs.SPIRXBUF;\par
00977     temp = SpibRegs.SPIRXBUF;\par
00978     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
00979 \par
00980     {\cf20 //Step 3.}\par
00981     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x23,0x24,0x25,0x26}\par
00982     {\cf20 // 0x27, 0x28, 0x29. Use only one SS low to high for all these writes}\par
00983     {\cf20 // some code is given, most you have to fill you yourself.}\par
00984     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00985     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
00986     SpibRegs.SPITXBUF = 0x2300; {\cf20 //start address, To address 00x23 write 0x00}\par
00987     SpibRegs.SPITXBUF = 0x408C;{\cf20 // To address 00x24 write 0x40, To address 00x25 write 0x8C}\par
00988     SpibRegs.SPITXBUF = 0x0288;{\cf20 // To address 00x26 write 0x02, To address 00x27 write 0x88}\par
00989     SpibRegs.SPITXBUF = 0x0C0A;{\cf20 // To address 00x28 write 0x0C, To address 00x29 write 0x0A}\par
00990 \par
00991     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
00992     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=4);\par
00993     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00994     temp = SpibRegs.SPIRXBUF;\par
00995     temp = SpibRegs.SPIRXBUF;\par
00996     temp = SpibRegs.SPIRXBUF;\par
00997     temp = SpibRegs.SPIRXBUF;\par
00998     {\cf20 // read the additional number of garbage receive values off the RX FIFO to clear out the RX FIFO}\par
00999     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
01000 \par
01001     {\cf20 //Step 4.}\par
01002     {\cf20 // perform a single 16 bit transfer to initialize MPU-9250 register 0x2A}\par
01003     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01004     SpibRegs.SPITXBUF = 0x2A81; {\cf20 //start address, Write to address 0x2A the value 0x81}\par
01005 \par
01006     {\cf20 // wait for one byte to be received}\par
01007     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01008     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01009     temp = SpibRegs.SPIRXBUF;\par
01010     DELAY_US(10);\par
01011 \par
01012     {\cf20 // The Remainder of this code is given to you and you do not need to make any changes.}\par
01013     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01014     SpibRegs.SPITXBUF = (0x3800 | 0x0001); {\cf20 // 0x3800}\par
01015     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01016     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01017     temp = SpibRegs.SPIRXBUF;\par
01018     DELAY_US(10);\par
01019     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01020     SpibRegs.SPITXBUF = (0x3A00 | 0x0001); {\cf20 // 0x3A00}\par
01021     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01022     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01023     temp = SpibRegs.SPIRXBUF;\par
01024     DELAY_US(10);\par
01025     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01026     SpibRegs.SPITXBUF = (0x6400 | 0x0001); {\cf20 // 0x6400}\par
01027     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01028     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01029     temp = SpibRegs.SPIRXBUF;\par
01030     DELAY_US(10);\par
01031     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01032     SpibRegs.SPITXBUF = (0x6700 | 0x0003); {\cf20 // 0x6700}\par
01033     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01034     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01035     temp = SpibRegs.SPIRXBUF;\par
01036     DELAY_US(10);\par
01037     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01038     SpibRegs.SPITXBUF = (0x6A00 | 0x0020); {\cf20 // 0x6A00}\par
01039     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01040     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01041     temp = SpibRegs.SPIRXBUF;\par
01042     DELAY_US(10);\par
01043     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01044     SpibRegs.SPITXBUF = (0x6B00 | 0x0001); {\cf20 // 0x6B00}\par
01045     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01046     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01047     temp = SpibRegs.SPIRXBUF;\par
01048     DELAY_US(10);\par
01049     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01050     SpibRegs.SPITXBUF = (0x7500 | 0x0071); {\cf20 // 0x7500}\par
01051     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01052     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01053     temp = SpibRegs.SPIRXBUF;\par
01054     DELAY_US(10);\par
01055     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01056 {\cf20 //    SpibRegs.SPITXBUF = (0x7700 | 0x00EB); // 0x7700}\par
01057     SpibRegs.SPITXBUF = (0x7700 | 0x0000); {\cf20 // 0x7700}\par
01058     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01059     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01060     temp = SpibRegs.SPIRXBUF;\par
01061     DELAY_US(10);\par
01062     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01063 {\cf20 //    SpibRegs.SPITXBUF = (0x7800 | 0x0012); // 0x7800}\par
01064     SpibRegs.SPITXBUF = (0x7800 | 0x0000); {\cf20 // 0x7800}\par
01065     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01066     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01067     temp = SpibRegs.SPIRXBUF;\par
01068     DELAY_US(10);\par
01069     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01070     SpibRegs.SPITXBUF = (0x7A00 | 0x0010); {\cf20 // 0x7A00}\par
01071     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01072     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01073     temp = SpibRegs.SPIRXBUF;\par
01074     DELAY_US(10);\par
01075     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01076     SpibRegs.SPITXBUF = (0x7B00 | 0x00FA); {\cf20 // 0x7B00}\par
01077     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01078     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01079     temp = SpibRegs.SPIRXBUF;\par
01080     DELAY_US(10);\par
01081     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01082     SpibRegs.SPITXBUF = (0x7D00 | 0x0021); {\cf20 // 0x7D00}\par
01083     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01084     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01085     temp = SpibRegs.SPIRXBUF;\par
01086     DELAY_US(10);\par
01087     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01088     SpibRegs.SPITXBUF = (0x7E00 | 0x0050); {\cf20 // 0x7E00}\par
01089     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01090     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01091     temp = SpibRegs.SPIRXBUF;\par
01092     DELAY_US(50);\par
01093 \par
01094     {\cf20 // Clear SPIB interrupt source just in case it was issued due to any of the above initializations.}\par
01095     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear Overflow flag}\par
01096     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Interrupt flag}\par
01097     PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
01098 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot3.c File Reference\par \pard\plain 
{\tc\tcl2 \v UART_Segbot3.c}
{\xe \v UART_Segbot3.c}
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
{\f2 #include "driverlib.h"}\par
{\f2 #include "device.h"}\par
{\f2 #include "f28379dSerial.h"}\par
{\f2 #include "LEDPatterns.h"}\par
{\f2 #include "song.h"}\par
{\f2 #include "dsp.h"}\par
{\f2 #include "fpu32/fpu_rfft.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union {\b phonedata_s}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PI}\~ 3.1415926535897932384626433832795\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWOPI}\~ 6.283185307179586476925286766559\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HALFPI}\~ 1.5707963267948966192313216916398\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef union {\b phonedata_s} {\b phonedata_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer0_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer1_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer2_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SWI_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SPIB_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b ADCA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupSpib} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXA} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXC} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_eQEPs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncLeft} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncRight} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2A} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2B} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b main} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b phonedata_t} {\b phoneaccel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numTimer0calls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numSWIcalls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numRXA} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint2} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LEDdisplaynum} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b Junk} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelzraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyrozraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ubal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K1} = -60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K2} = -7.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K3} = -1.1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uLeft} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uRight} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turn} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kp} = 3.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Ki} = 20.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kd} = .01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b FwdBackOffset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca0_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca1_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca0result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca1result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelzBalancePoint} = -.73\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16 {\b IMU_data} [9]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b temp} =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b doneCal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b T} = 0.001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Q} = 0.01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b R} = 25000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_tilt} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_P} = 22.365\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b SpibNumCalls} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pred_P} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_K} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b timecount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b calibration_state} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b calibration_count} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_x} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_y} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_z} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sendback} [10]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b past} [14]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HALFPI\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:HALFPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HALFPI\~ 1.5707963267948966192313216916398}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v PI\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PI\~ 3.1415926535897932384626433832795}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v TWOPI\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:TWOPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWOPI\~ 6.283185307179586476925286766559}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b UART_Segbot3.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v phonedata_t\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:phonedata_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef union {\b phonedata_s} {\b phonedata_t}}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ADCA_ISR\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:ADCA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void ADCA_ISR (void )}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 663} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v cpu_timer0_isr\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:cpu_timer0_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer0_isr (void )}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 555} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v cpu_timer1_isr\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:cpu_timer1_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer1_isr (void )}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 566} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v cpu_timer2_isr\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:cpu_timer2_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer2_isr (void )}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 573} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v init_eQEPs\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:init_eQEPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_eQEPs (void )}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 825} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v main\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void main (void )}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v readEncLeft\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:readEncLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncLeft (void )}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 798} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v readEncRight\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:readEncRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncRight (void )}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 811} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v serialRXA\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:serialRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXA ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 583} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v serialRXC\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:serialRXC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXC ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 589} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v setEPWM2A\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:setEPWM2A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2A (float controleffort)}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 871} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v setEPWM2B\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:setEPWM2B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2B (float controleffort)}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 882} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v setupSpib\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:setupSpib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setupSpib (void )}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 892} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v SPIB_isr\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:SPIB_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SPIB_isr (void )}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 690} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v SWI_isr\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:SWI_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SWI_isr (void )}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 492} of file {\b UART_Segbot3.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v accelx\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx = 0}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accelx_offset\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelx_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx_offset = 0}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accelxraw\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelxraw = 0}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accely\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely = 0}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accely_offset\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accely_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely_offset = 0}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accelyraw\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelyraw = 0}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accelz\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz = 0}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accelz_offset\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz_offset = 0}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accelzBalancePoint\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelzBalancePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelzBalancePoint = -.73}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v accelzraw\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:accelzraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelzraw = 0}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v adca0_volts\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:adca0_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca0_volts = 0}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v adca0result\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:adca0result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca0result = 0}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v adca1_volts\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:adca1_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca1_volts = 0}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v adca1result\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:adca1result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca1result = 0}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v ble_x\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:ble_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_x = 0}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v ble_y\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:ble_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_y = 0}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v ble_z\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:ble_z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_z = 0}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v calibration_count\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:calibration_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t calibration_count = 0}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v calibration_state\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:calibration_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t calibration_state = 0}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v doneCal\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:doneCal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t doneCal = 0}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v eDif\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:eDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif = 0}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v eDif_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:eDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif_1 = 0}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v FwdBackOffset\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:FwdBackOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float FwdBackOffset = 0}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyro_array\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyro_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyro_value\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyro_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_value = 0}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyrox\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyrox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox = 0}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyrox_offset\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyrox_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox_offset = 0}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyroxraw\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyroxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroxraw = 0}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyroy\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy = 0}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyroy_offset\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyroy_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy_offset = 0}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyroyraw\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyroyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroyraw = 0}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyroz\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyroz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz = 0}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyroz_offset\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyroz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz_offset = 0}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v gyrozraw\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:gyrozraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyrozraw = 0}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v iDif\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:iDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif = 0}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v iDif_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:iDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif_1 = 0}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v IMU_data\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:IMU_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16 IMU_data[9]}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v Junk\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:Junk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Junk = 0}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v K1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:K1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K1 = -60}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v K2\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:K2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K2 = -7.0}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v K3\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:K3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K3 = -1.1}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v kalman_K\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:kalman_K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_K = 0}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v kalman_P\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:kalman_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_P = 22.365}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v kalman_tilt\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:kalman_tilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_tilt = 0}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v Kd\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:Kd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kd = .01}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v Ki\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:Ki}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Ki = 20.0}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v Kp\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:Kp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kp = 3.0}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v LEDdisplaynum\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:LEDdisplaynum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LEDdisplaynum = 0}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v LeftVel\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:LeftVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel = 0}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v LeftVel_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:LeftVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel_1 = 0}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v LeftWheel\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:LeftWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel = 0}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v LeftWheel_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:LeftWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel_1 = 0}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v LeftWheelArray\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:LeftWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v numRXA\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:numRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numRXA = 0}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v numSWIcalls\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:numSWIcalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numSWIcalls = 0}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v numTimer0calls\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:numTimer0calls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numTimer0calls = 0}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v past\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:past}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char past[14]}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 588} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v phoneaccel\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:phoneaccel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b phonedata_t} phoneaccel}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v pred_P\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:pred_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float pred_P = 0}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v Q\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:Q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Q = 0.01}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v R\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:R}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float R = 25000}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v RightVel\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:RightVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel = 0}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v RightVel_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:RightVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel_1 = 0}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v RightWheel\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:RightWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel = 0}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v RightWheel_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:RightWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel_1 = 0}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v RightWheelArray\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:RightWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v sendback\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:sendback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char sendback[10]}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 587} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v SpibNumCalls\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:SpibNumCalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SpibNumCalls = -1}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v T\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float T = 0.001}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v temp\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t temp =0}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v tilt_array\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:tilt_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v tilt_value\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:tilt_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_value = 0}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v timecount\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:timecount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t timecount = 0}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v turn\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turn = 0}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v turnrate\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:turnrate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate = 0}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v turnrate_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:turnrate_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate_1 = 0}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v turnref\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:turnref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref = 0}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v turnref_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:turnref_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref_1 = 0}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v UARTPrint\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:UARTPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint = 0}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v UARTPrint2\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:UARTPrint2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint2 = 0}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v ubal\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:ubal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ubal = 0}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v uLeft\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:uLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uLeft = 5.0}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v uRight\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:uRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uRight = 5.0}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v velWheelDif\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:velWheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif = 0}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v velWheelDif_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:velWheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v WheelDif\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:WheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif = 0}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b UART_Segbot3.c}.}\par
}
{\xe \v WheelDif_1\:UART_Segbot3.c}
{\xe \v UART_Segbot3.c\:WheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b UART_Segbot3.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot3.c\par \pard\plain 
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //#############################################################################}\par
00002 {\cf20 //UART_Segbot read accelerometer and steer}\par
00003 {\cf20 //#############################################################################}\par
00004 \par
00005 {\cf20 // Included Files}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 {\cf21 #include <stdarg.h>}\par
00009 {\cf21 #include <string.h>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include <limits.h>}\par
00012 {\cf21 #include "F28x_Project.h"}\par
00013 {\cf21 #include "driverlib.h"}\par
00014 {\cf21 #include "device.h"}\par
00015 {\cf21 #include "f28379dSerial.h"}\par
00016 {\cf21 #include "LEDPatterns.h"}\par
00017 {\cf21 #include "song.h"}\par
00018 {\cf21 #include "dsp.h"}\par
00019 {\cf21 #include "fpu32/fpu_rfft.h"}\par
00020 \par
00021 {\cf21 #define PI          3.1415926535897932384626433832795}\par
00022 {\cf21 #define TWOPI       6.283185307179586476925286766559}\par
00023 {\cf21 #define HALFPI      1.5707963267948966192313216916398}\par
00024 \par
00025 \par
00026 {\cf20 // Interrupt Service Routines predefinition}\par
00027 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void});\par
00028 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void});\par
00029 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void});\par
00030 __interrupt {\cf18 void} SWI_isr({\cf18 void});\par
00031 __interrupt {\cf18 void} SPIB_isr({\cf18 void});\par
00032 __interrupt {\cf18 void} ADCA_ISR({\cf18 void});\par
00033 \par
00034 {\cf18 void} setupSpib({\cf18 void});\par
00035 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data);\par
00036 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data);\par
00037 {\cf18 void} init_eQEPs({\cf18 void});\par
00038 {\cf18 float} readEncLeft({\cf18 void});\par
00039 {\cf18 float} readEncRight({\cf18 void});\par
00040 {\cf18 void} setEPWM2A({\cf18 float});\par
00041 {\cf18 void} setEPWM2B({\cf18 float});\par
00042 \par
00043 {\cf17 typedef} {\cf17 union }phonedata_s\{\par
00044     uint16_t rawdata[6];\par
00045     {\cf18 float} fltdata[3];\par
00046 \par
00047 \}phonedata_t;\par
00048 phonedata_t phoneaccel; {\cf20 //use new data type defined in union}\par
00049 \par
00050 {\cf20 // Count variables}\par
00051 uint32_t numTimer0calls = 0;\par
00052 uint32_t numSWIcalls = 0;\par
00053 uint32_t numRXA = 0;\par
00054 uint16_t UARTPrint = 0;\par
00055 uint16_t UARTPrint2 = 0;\par
00056 uint16_t LEDdisplaynum = 0;\par
00057 \par
00058 int16_t Junk = 0;\par
00059 \par
00060 int16_t accelxraw = 0;\par
00061 int16_t accelyraw = 0;\par
00062 int16_t accelzraw = 0;\par
00063 int16_t gyroxraw = 0;\par
00064 int16_t gyroyraw = 0;\par
00065 int16_t gyrozraw = 0;\par
00066 \par
00067 {\cf18 float} accelx = 0;\par
00068 {\cf18 float} accely = 0;\par
00069 {\cf18 float} accelz = 0;\par
00070 {\cf18 float} gyrox = 0;\par
00071 {\cf18 float} gyroy = 0;\par
00072 {\cf18 float} gyroz = 0;\par
00073 {\cf18 float} LeftWheel = 0;\par
00074 {\cf18 float} RightWheel = 0;\par
00075 {\cf18 float} LeftWheel_1 = 0;\par
00076 {\cf18 float} RightWheel_1 = 0;\par
00077 {\cf18 float} LeftVel = 0;\par
00078 {\cf18 float} RightVel = 0;\par
00079 {\cf18 float} LeftVel_1 = 0;\par
00080 {\cf18 float} RightVel_1 = 0;\par
00081 {\cf18 float} ubal = 0;\par
00082 {\cf18 float} K1 = -60;\par
00083 {\cf20 //float K2 = -4.5;}\par
00084 {\cf18 float} K2 = -7.0;\par
00085 {\cf18 float} K3 = -1.1;\par
00086 {\cf18 float} WheelDif = 0;\par
00087 {\cf18 float} velWheelDif = 0;\par
00088 {\cf18 float} WheelDif_1 = 0;\par
00089 {\cf18 float} velWheelDif_1 = 0;\par
00090 {\cf18 float} turnref = 0;\par
00091 {\cf18 float} turnref_1 = 0;\par
00092 {\cf18 float} uLeft = 5.0;\par
00093 {\cf18 float} uRight = 5.0;\par
00094 {\cf18 float} eDif = 0;\par
00095 {\cf18 float} iDif = 0;\par
00096 {\cf18 float} eDif_1 = 0;\par
00097 {\cf18 float} iDif_1 = 0;\par
00098 {\cf18 float} turn = 0; {\cf20 //turn setpoint}\par
00099 {\cf18 float} Kp = 3.0;\par
00100 {\cf18 float} Ki = 20.0;\par
00101 {\cf20 //float Kd = .08;}\par
00102 {\cf18 float} Kd = .01;\par
00103 {\cf18 float} FwdBackOffset = 0;\par
00104 {\cf18 float} turnrate = 0;\par
00105 {\cf18 float} turnrate_1 = 0;\par
00106 \par
00107 \par
00108 {\cf20 //lab4 variables}\par
00109 {\cf18 float} adca0_volts = 0;\par
00110 {\cf18 float} adca1_volts = 0;\par
00111 int16_t adca0result = 0;\par
00112 int16_t adca1result = 0;\par
00113 \par
00114 {\cf20 // Needed global Variables}\par
00115 {\cf18 float} accelx_offset = 0;\par
00116 {\cf18 float} accely_offset = 0;\par
00117 {\cf18 float} accelz_offset = 0;\par
00118 {\cf18 float} gyrox_offset  = 0;\par
00119 {\cf18 float} gyroy_offset  = 0;\par
00120 {\cf18 float} gyroz_offset  = 0;\par
00121 {\cf20 //float accelzBalancePoint = -.76; // tune this}\par
00122 {\cf18 float} accelzBalancePoint = -.73;\par
00123 int16 IMU_data[9];\par
00124 uint16_t temp=0;\par
00125 int16_t doneCal = 0;\par
00126 {\cf18 float} tilt_value    = 0;\par
00127 {\cf18 float} tilt_array[4] = \{0, 0, 0, 0\};\par
00128 {\cf18 float} gyro_value    = 0;\par
00129 {\cf18 float} gyro_array[4] = \{0, 0, 0, 0\};\par
00130 {\cf18 float} LeftWheelArray[4] = \{0,0,0,0\};\par
00131 {\cf18 float} RightWheelArray[4] = \{0,0,0,0\};\par
00132 {\cf20 // Kalman Filter vars}\par
00133 {\cf18 float} T = 0.001;        {\cf20 //sample rate, 1ms}\par
00134 {\cf18 float} Q = 0.01; {\cf20 // made global to enable changing in runtime}\par
00135 {\cf18 float} R = 25000;{\cf20 //50000;}\par
00136 {\cf18 float} kalman_tilt = 0;\par
00137 {\cf18 float} kalman_P = 22.365;\par
00138 int16_t SpibNumCalls = -1;\par
00139 {\cf18 float} pred_P = 0;\par
00140 {\cf18 float} kalman_K = 0;\par
00141 int32_t timecount = 0;\par
00142 int16_t calibration_state = 0;\par
00143 int32_t calibration_count = 0;\par
00144 \par
00145 {\cf20 //BLE DATA}\par
00146 {\cf18 float} ble_x = 0;\par
00147 {\cf18 float} ble_y = 0;\par
00148 {\cf18 float} ble_z = 0;\par
00149 \par
00150 {\cf18 void} main({\cf18 void})\par
00151  \{\par
00152     {\cf20 // PLL, WatchDog, enable Peripheral Clocks}\par
00153     {\cf20 // This example function is found in the F2837xD_SysCtrl.c file.}\par
00154     InitSysCtrl();\par
00155 \par
00156     InitGpio();\par
00157 \par
00158     {\cf20 // Blue LED on LuanchPad}\par
00159     GPIO_SetupPinMux(31, GPIO_MUX_CPU1, 0);\par
00160     GPIO_SetupPinOptions(31, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00161     GpioDataRegs.GPASET.bit.GPIO31 = 1;\par
00162 \par
00163     {\cf20 // Red LED on LaunchPad}\par
00164     GPIO_SetupPinMux(34, GPIO_MUX_CPU1, 0);\par
00165     GPIO_SetupPinOptions(34, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00166     GpioDataRegs.GPBSET.bit.GPIO34 = 1;\par
00167 \par
00168     {\cf20 // LED1 and PWM Pin}\par
00169     GPIO_SetupPinMux(22, GPIO_MUX_CPU1, 0);\par
00170     GPIO_SetupPinOptions(22, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00171     GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;\par
00172 \par
00173     {\cf20 // LED2}\par
00174     GPIO_SetupPinMux(94, GPIO_MUX_CPU1, 0);\par
00175     GPIO_SetupPinOptions(94, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00176     GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;\par
00177 \par
00178     {\cf20 // LED3}\par
00179     GPIO_SetupPinMux(95, GPIO_MUX_CPU1, 0);\par
00180     GPIO_SetupPinOptions(95, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00181     GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;\par
00182 \par
00183     {\cf20 // LED4}\par
00184     GPIO_SetupPinMux(97, GPIO_MUX_CPU1, 0);\par
00185     GPIO_SetupPinOptions(97, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00186     GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;\par
00187 \par
00188     {\cf20 // LED5}\par
00189     GPIO_SetupPinMux(111, GPIO_MUX_CPU1, 0);\par
00190     GPIO_SetupPinOptions(111, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00191     GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;\par
00192 \par
00193     {\cf20 // LED6}\par
00194     GPIO_SetupPinMux(130, GPIO_MUX_CPU1, 0);\par
00195     GPIO_SetupPinOptions(130, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00196     GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;\par
00197 \par
00198     {\cf20 // LED7}\par
00199     GPIO_SetupPinMux(131, GPIO_MUX_CPU1, 0);\par
00200     GPIO_SetupPinOptions(131, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00201     GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;\par
00202 \par
00203     {\cf20 // LED8}\par
00204     GPIO_SetupPinMux(25, GPIO_MUX_CPU1, 0);\par
00205     GPIO_SetupPinOptions(25, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00206     GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;\par
00207 \par
00208     {\cf20 // LED9}\par
00209     GPIO_SetupPinMux(26, GPIO_MUX_CPU1, 0);\par
00210     GPIO_SetupPinOptions(26, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00211     GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;\par
00212 \par
00213     {\cf20 // LED10}\par
00214     GPIO_SetupPinMux(27, GPIO_MUX_CPU1, 0);\par
00215     GPIO_SetupPinOptions(27, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00216     GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;\par
00217 \par
00218     {\cf20 // LED11}\par
00219     GPIO_SetupPinMux(60, GPIO_MUX_CPU1, 0);\par
00220     GPIO_SetupPinOptions(60, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00221     GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;\par
00222 \par
00223     {\cf20 // LED12}\par
00224     GPIO_SetupPinMux(61, GPIO_MUX_CPU1, 0);\par
00225     GPIO_SetupPinOptions(61, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00226     GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;\par
00227 \par
00228     {\cf20 // LED13}\par
00229     GPIO_SetupPinMux(157, GPIO_MUX_CPU1, 0);\par
00230     GPIO_SetupPinOptions(157, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00231     GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;\par
00232 \par
00233     {\cf20 // LED14}\par
00234     GPIO_SetupPinMux(158, GPIO_MUX_CPU1, 0);\par
00235     GPIO_SetupPinOptions(158, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00236     GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;\par
00237 \par
00238     {\cf20 // LED15}\par
00239     GPIO_SetupPinMux(159, GPIO_MUX_CPU1, 0);\par
00240     GPIO_SetupPinOptions(159, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00241     GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;\par
00242 \par
00243     {\cf20 // LED16}\par
00244     GPIO_SetupPinMux(160, GPIO_MUX_CPU1, 0);\par
00245     GPIO_SetupPinOptions(160, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00246     GpioDataRegs.GPFCLEAR.bit.GPIO160 = 1;\par
00247 \par
00248     {\cf20 //WIZNET Reset}\par
00249     GPIO_SetupPinMux(0, GPIO_MUX_CPU1, 0);\par
00250     GPIO_SetupPinOptions(0, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00251     GpioDataRegs.GPASET.bit.GPIO0 = 1;\par
00252 \par
00253     {\cf20 //ESP8266 Reset}\par
00254     GPIO_SetupPinMux(1, GPIO_MUX_CPU1, 0);\par
00255     GPIO_SetupPinOptions(1, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00256     GpioDataRegs.GPASET.bit.GPIO1 = 1;\par
00257 \par
00258     {\cf20 //SPIRAM  CS  Chip Select}\par
00259     GPIO_SetupPinMux(19, GPIO_MUX_CPU1, 0);\par
00260     GPIO_SetupPinOptions(19, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00261     GpioDataRegs.GPASET.bit.GPIO19 = 1;\par
00262 \par
00263     {\cf20 //DRV8874 #1 DIR  Direction}\par
00264     GPIO_SetupPinMux(29, GPIO_MUX_CPU1, 0);\par
00265     GPIO_SetupPinOptions(29, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00266     GpioDataRegs.GPASET.bit.GPIO29 = 1;\par
00267 \par
00268     {\cf20 //DRV8874 #2 DIR  Direction}\par
00269     GPIO_SetupPinMux(32, GPIO_MUX_CPU1, 0);\par
00270     GPIO_SetupPinOptions(32, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00271     GpioDataRegs.GPBSET.bit.GPIO32 = 1;\par
00272 \par
00273     {\cf20 //DAN28027  CS  Chip Select}\par
00274     GPIO_SetupPinMux(9, GPIO_MUX_CPU1, 0);\par
00275     GPIO_SetupPinOptions(9, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00276     GpioDataRegs.GPASET.bit.GPIO9 = 1;\par
00277 \par
00278     {\cf20 //MPU9250  CS  Chip Select}\par
00279     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0);\par
00280     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00281     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
00282 \par
00283     {\cf20 //WIZNET  CS  Chip Select}\par
00284     GPIO_SetupPinMux(125, GPIO_MUX_CPU1, 0);\par
00285     GPIO_SetupPinOptions(125, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00286     GpioDataRegs.GPDSET.bit.GPIO125 = 1;\par
00287 \par
00288     {\cf20 //PushButton 1}\par
00289     GPIO_SetupPinMux(4, GPIO_MUX_CPU1, 0);\par
00290     GPIO_SetupPinOptions(4, GPIO_INPUT, GPIO_PULLUP);\par
00291 \par
00292     {\cf20 //PushButton 2}\par
00293     GPIO_SetupPinMux(5, GPIO_MUX_CPU1, 0);\par
00294     GPIO_SetupPinOptions(5, GPIO_INPUT, GPIO_PULLUP);\par
00295 \par
00296     {\cf20 //PushButton 3}\par
00297     GPIO_SetupPinMux(6, GPIO_MUX_CPU1, 0);\par
00298     GPIO_SetupPinOptions(6, GPIO_INPUT, GPIO_PULLUP);\par
00299 \par
00300     {\cf20 //PushButton 4}\par
00301     GPIO_SetupPinMux(7, GPIO_MUX_CPU1, 0);\par
00302     GPIO_SetupPinOptions(7, GPIO_INPUT, GPIO_PULLUP);\par
00303 \par
00304     {\cf20 //Joy Stick Pushbutton}\par
00305     GPIO_SetupPinMux(8, GPIO_MUX_CPU1, 0);\par
00306     GPIO_SetupPinOptions(8, GPIO_INPUT, GPIO_PULLUP);\par
00307 \par
00308     {\cf20 //Ground GPIO1 Connected to BT CTS Pin}\par
00309     GpioDataRegs.GPACLEAR.bit.GPIO1 = 1;\par
00310 \par
00311     {\cf20 // Clear all interrupts and initialize PIE vector table:}\par
00312     {\cf20 // Disable CPU interrupts}\par
00313     DINT;\par
00314 \par
00315     setupSpib();{\cf20 //run SPI setup code}\par
00316 \par
00317     {\cf20 // Initialize the PIE control registers to their default state.}\par
00318     {\cf20 // The default state is all PIE interrupts disabled and flags}\par
00319     {\cf20 // are cleared.}\par
00320     {\cf20 // This function is found in the F2837xD_PieCtrl.c file.}\par
00321     InitPieCtrl();\par
00322 \par
00323     {\cf20 // Disable CPU interrupts and clear all CPU interrupt flags:}\par
00324     IER = 0x0000;\par
00325     IFR = 0x0000;\par
00326 \par
00327     {\cf20 // Initialize the PIE vector table with pointers to the shell Interrupt}\par
00328     {\cf20 // Service Routines (ISR).}\par
00329     {\cf20 // This will populate the entire table, even if the interrupt}\par
00330     {\cf20 // is not used in this example.  This is useful for debug purposes.}\par
00331     {\cf20 // The shell ISR routines are found in F2837xD_DefaultIsr.c.}\par
00332     {\cf20 // This function is found in F2837xD_PieVect.c.}\par
00333     InitPieVectTable();\par
00334 \par
00335     {\cf20 // Interrupts that are used in this example are re-mapped to}\par
00336     {\cf20 // ISR functions found within this project}\par
00337     EALLOW;  {\cf20 // This is needed to write to EALLOW protected registers}\par
00338     PieVectTable.TIMER0_INT = &cpu_timer0_isr;\par
00339     PieVectTable.TIMER1_INT = &cpu_timer1_isr;\par
00340     PieVectTable.TIMER2_INT = &cpu_timer2_isr;\par
00341     PieVectTable.SCIA_RX_INT = &RXAINT_recv_ready;\par
00342     PieVectTable.SCIC_RX_INT = &RXCINT_recv_ready;\par
00343     PieVectTable.SCID_RX_INT = &RXDINT_recv_ready;\par
00344     PieVectTable.SCIA_TX_INT = &TXAINT_data_sent;\par
00345     PieVectTable.SCIC_TX_INT = &TXCINT_data_sent;\par
00346     PieVectTable.SCID_TX_INT = &TXDINT_data_sent;\par
00347     PieVectTable.SPIB_RX_INT = &SPIB_isr;\par
00348     PieVectTable.ADCA1_INT = &ADCA_ISR;\par
00349 \par
00350     PieVectTable.EMIF_ERROR_INT = &SWI_isr;\par
00351     EDIS;    {\cf20 // This is needed to disable write to EALLOW protected registers}\par
00352 \par
00353 \par
00354     {\cf20 // Initialize the CpuTimers Device Peripheral. This function can be}\par
00355     {\cf20 // found in F2837xD_CpuTimers.c}\par
00356     InitCpuTimers();\par
00357 \par
00358     {\cf20 // Configure CPU-Timer 0, 1, and 2 to interrupt every second:}\par
00359     {\cf20 // 200MHz CPU Freq, 1 second Period (in uSeconds)}\par
00360     ConfigCpuTimer(&CpuTimer0, 200, 1000); {\cf20 //change to 1 ms}\par
00361     ConfigCpuTimer(&CpuTimer1, 200, 4000); {\cf20 //change to 4 ms}\par
00362     ConfigCpuTimer(&CpuTimer2, 200, 200000);\par
00363 \par
00364     {\cf20 // Enable CpuTimer Interrupt bit TIE}\par
00365     CpuTimer0Regs.TCR.all = 0x4000;\par
00366     CpuTimer1Regs.TCR.all = 0x4000;\par
00367     CpuTimer2Regs.TCR.all = 0x4000;\par
00368 \par
00369     init_serial(&SerialA,115200,serialRXA);\par
00370     init_serial(&SerialC,9600,serialRXC); {\cf20 //set to 9600 for Bluetooth Chip, initializations and muxing done in Serial.c}\par
00371 {\cf20 //    init_serial(&SerialD,115200,serialRXD);}\par
00372 \par
00373     {\cf20 //pwm no output}\par
00374     EALLOW;\par
00375     EPwm5Regs.ETSEL.bit.SOCAEN = 0; {\cf20 // Disable SOC on A group}\par
00376     EPwm5Regs.TBCTL.bit.CTRMODE = 3; {\cf20 // freeze counter}\par
00377     EPwm5Regs.ETSEL.bit.SOCASEL = 2; {\cf20 // Select Event when counter equal to PRD}\par
00378     EPwm5Regs.ETPS.bit.SOCAPRD = 1; {\cf20 // Generate pulse on 1st event (\'93pulse\'94 is the same as \'93trigger\'94)}\par
00379     EPwm5Regs.TBCTR = 0x0; {\cf20 // Clear counter}\par
00380     EPwm5Regs.TBPHS.bit.TBPHS = 0x0000; {\cf20 // Phase is 0}\par
00381     EPwm5Regs.TBCTL.bit.PHSEN = 0; {\cf20 // Disable phase loading}\par
00382     EPwm5Regs.TBCTL.bit.CLKDIV = 0; {\cf20 // divide by 1  50Mhz Clock}\par
00383     EPwm5Regs.TBPRD = 50000;  {\cf20 // Set Period to 1ms sample. Rampling rate: 1000 Hz}\par
00384     {\cf20 //(1/50MHz)*TBPRD = .001 s}\par
00385     {\cf20 // Notice here that we are not setting CMPA or CMPB because we are not using the PWM signal}\par
00386     EPwm5Regs.ETSEL.bit.SOCAEN = 1; {\cf20 //enable SOCA}\par
00387     EPwm5Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //unfreeze, and enter up count mode}\par
00388     EDIS;\par
00389 \par
00390     EALLOW;\par
00391     {\cf20 //write configurations for all ADCs  ADCA, ADCB, ADCC, ADCD}\par
00392     AdcaRegs.ADCCTL2.bit.PRESCALE = 6; {\cf20 //set ADCCLK divider to /4}\par
00393     {\cf20 //        AdcbRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00394     {\cf20 //        AdccRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00395     {\cf20 //        AdcdRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00396     AdcSetMode(ADC_ADCA, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  {\cf20 //read calibration settings}\par
00397     {\cf20 //        AdcSetMode(ADC_ADCB, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00398     {\cf20 //        AdcSetMode(ADC_ADCC, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00399     {\cf20 //        AdcSetMode(ADC_ADCD, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00400     {\cf20 //Set pulse positions to late}\par
00401     AdcaRegs.ADCCTL1.bit.INTPULSEPOS = 1;\par
00402     {\cf20 //        AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00403     {\cf20 //        AdccRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00404     {\cf20 //        AdcdRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00405     {\cf20 //power up the ADCs}\par
00406     AdcaRegs.ADCCTL1.bit.ADCPWDNZ = 1;\par
00407     {\cf20 //        AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00408     {\cf20 //        AdccRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00409     {\cf20 //        AdcdRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00410     {\cf20 //delay for 1ms to allow ADC time to power up}\par
00411     DELAY_US(1000);\par
00412 \par
00413 \par
00414     {\cf20 //Select the channels to convert and end of conversion flag}\par
00415     {\cf20 //Many statements commented out,  To be used when using ADCA or ADCB}\par
00416     {\cf20 //ADCA}\par
00417     AdcaRegs.ADCSOC0CTL.bit.CHSEL = 2;  {\cf20 //SOC0 will convert Channel you choose Does not have to be A0}\par
00418     AdcaRegs.ADCSOC0CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00419     AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC0}\par
00420     AdcaRegs.ADCSOC1CTL.bit.CHSEL = 3;  {\cf20 //SOC1 will convert Channel you choose Does not have to be A1}\par
00421     AdcaRegs.ADCSOC1CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00422     AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC1}\par
00423     AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = 1; {\cf20 //set to last SOC that is converted and it will set INT1 flag ADCA1}\par
00424     AdcaRegs.ADCINTSEL1N2.bit.INT1E = 1;   {\cf20 //enable INT1 flag}\par
00425     AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; {\cf20 //make sure INT1 flag is cleared}\par
00426     EDIS;\par
00427 \par
00428     {\cf20 //2A and 2B - Motors}\par
00429     EPwm2Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //count up mode}\par
00430     EPwm2Regs.TBCTL.bit.FREE_SOFT = 2; {\cf20 //free run}\par
00431     EPwm2Regs.TBCTL.bit.PHSEN = 0; {\cf20 //disable phase loading}\par
00432     EPwm2Regs.TBCTL.bit.CLKDIV = 0; {\cf20 //clock divide = 1}\par
00433     EPwm2Regs.TBCTR = 0; {\cf20 //start the timers at 0}\par
00434     EPwm2Regs.TBPRD = 2500; {\cf20 //set period to 50 microseconds (20 kHz)}\par
00435     {\cf20 // (1/50MHz)*TBPRD = 50 us}\par
00436     EPwm2Regs.CMPA.bit.CMPA = 0; {\cf20 //start duty cycle at 0%}\par
00437     EPwm2Regs.CMPB.bit.CMPB = 0; {\cf20 //start duty cycle at 0%}\par
00438     {\cf20 // duty cycle = CMPA/TBPRD}\par
00439     EPwm2Regs.AQCTLA.bit.CAU = 1; {\cf20 //clear signal when TBCTR = CMPA}\par
00440     EPwm2Regs.AQCTLB.bit.CBU = 1; {\cf20 //clear signal when TBCTR = CMPB}\par
00441     EPwm2Regs.AQCTLA.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00442     EPwm2Regs.AQCTLB.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00443     EPwm2Regs.TBPHS.bit.TBPHS = 0; {\cf20 //set phase to 0}\par
00444     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2A}\par
00445     GPIO_SetupPinMux(3, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2B}\par
00446 \par
00447     init_eQEPs(); {\cf20 //call eQEP setup function}\par
00448 \par
00449     {\cf20 // Enable CPU int1 which is connected to CPU-Timer 0, CPU int13}\par
00450     {\cf20 // which is connected to CPU-Timer 1, and CPU int 14, which is connected}\par
00451     {\cf20 // to CPU-Timer 2:  int 12 is for the SWI.  }\par
00452     IER |= M_INT1;\par
00453     IER |= M_INT8;  {\cf20 // SCIC SCID}\par
00454     IER |= M_INT9;  {\cf20 // SCIA}\par
00455     IER |= M_INT12;\par
00456     IER |= M_INT13;\par
00457     IER |= M_INT14;\par
00458     IER |= M_INT6; {\cf20 //SPI}\par
00459 \par
00460     {\cf20 // Enable TINT0 in the PIE: Group 1 interrupt 7}\par
00461     PieCtrlRegs.PIEIER1.bit.INTx7 = 1;\par
00462     {\cf20 // Enable SWI in the PIE: Group 12 interrupt 9}\par
00463     PieCtrlRegs.PIEIER12.bit.INTx9 = 1;\par
00464     {\cf20 //Enable SPI}\par
00465     PieCtrlRegs.PIEIER6.bit.INTx3 = 1;\par
00466     {\cf20 //Enable ADCA1}\par
00467     PieCtrlRegs.PIEIER1.bit.INTx1 = 1;\par
00468 \par
00469     {\cf20 // Enable global Interrupts and higher priority real-time debug events}\par
00470     EINT;  {\cf20 // Enable Global interrupt INTM}\par
00471     ERTM;  {\cf20 // Enable Global realtime interrupt DBGM}\par
00472 \par
00473 \par
00474     {\cf20 // IDLE loop. Just sit and loop forever (optional):}\par
00475     {\cf19 while}(1)\par
00476     \{\par
00477         {\cf19 if} (UARTPrint == 1 ) \{\par
00478 {\cf20 //            serial_printf(&SerialC,"Num Timer2:%ld Num SerialRX: %ld\\r\\n",CpuTimer2.InterruptCount,numRXA); //prints to BT app}\par
00479 {\cf20 //            serial_printf(&SerialC,"FwdBackOffset: %.2f TurnRate: %.2f\\r\\n",FwdBackOffset, turnrate); //prints to BT app}\par
00480             serial_printf(&SerialA,{\cf22 "X: %.2f Y: %.2f Z: %.2f\\r\\n"},ble_x, ble_y, ble_z);{\cf20 //print acceleration data from phone to tera term}\par
00481             UARTPrint = 0;\par
00482         \}\par
00483        {\cf19 if}(UARTPrint2 == 1)\{\par
00484            serial_printf(&SerialC,{\cf22 "LeftVel: %.2f RightVel: %.2f\\r\\n"},LeftVel, RightVel); {\cf20 //prints to BT app}\par
00485            UARTPrint2 = 0;\par
00486        \}\par
00487     \}\par
00488 \}\par
00489 \par
00490 \par
00491 {\cf20 // SWI_isr,  Using this interrupt as a Software started interrupt}\par
00492 __interrupt {\cf18 void} SWI_isr({\cf18 void}) \{\par
00493 \par
00494     {\cf20 // These three lines of code allow SWI_isr, to be interrupted by other interrupt functions}\par
00495     {\cf20 // making it lower priority than all other Hardware interrupts.}\par
00496     PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\par
00497     {\cf17 asm}({\cf22 "       NOP"});                    {\cf20 // Wait one cycle}\par
00498     EINT;                                 {\cf20 // Clear INTM to enable interrupts}\par
00499 \par
00500 \par
00501 \par
00502     {\cf20 // Insert SWI ISR Code here.......}\par
00503     {\cf20 //solve for filtered velocity in rads/s}\par
00504     LeftVel = .6*LeftVel_1 + 100*(LeftWheel-LeftWheel_1);\par
00505     RightVel = .6*RightVel_1 + 100*(RightWheel-RightWheel_1);\par
00506 \par
00507     {\cf20 //Turning}\par
00508     WheelDif = LeftWheel - RightWheel;\par
00509     velWheelDif = .33*velWheelDif_1 + .67*(WheelDif-WheelDif_1)/.004;\par
00510     eDif = turnref - WheelDif;\par
00511     {\cf20 //calculate iDif without integral windup}\par
00512     {\cf19 if}(fabs(turn)>3)\{\par
00513         iDif = iDif_1;\par
00514     \}{\cf19 else}\{\par
00515         iDif = iDif_1 + .004*(eDif+eDif_1)/2;\par
00516     \}\par
00517 \par
00518     {\cf20 //Calculate Balance and Turn COntrols}\par
00519     ubal = -K1*tilt_value -K2*gyro_value - K3*(LeftVel+RightVel)/2.0;\par
00520     turn = Kp*eDif + Ki*iDif - Kd*velWheelDif;\par
00521     {\cf20 //saturate turn so balance control dominates (controllefford between +-10)}\par
00522     {\cf19 if}(turn>4)\{\par
00523         turn = 4;\par
00524     \}{\cf19 else} {\cf19 if}(turn<-4)\{\par
00525         turn = -4;\par
00526     \}\par
00527 \par
00528     turnref = turnref_1 + (turnrate + turnrate_1)*.004/2.0;\par
00529 \par
00530     {\cf20 //Calculate controleffort for each motor}\par
00531     uRight = ubal/2.0 - turn + FwdBackOffset;\par
00532     uLeft = ubal/2.0 + turn + FwdBackOffset;\par
00533 \par
00534     {\cf20 //Send ControlEffort to PWM Motor Command}\par
00535     setEPWM2A(uRight);\par
00536     setEPWM2B(-uLeft);\par
00537 \par
00538     {\cf20 //Save Past States}\par
00539     LeftVel_1 = LeftVel;\par
00540     RightVel_1 = RightVel;\par
00541     LeftWheel_1 = LeftWheel;\par
00542     RightWheel_1 = RightWheel;\par
00543     eDif_1 = eDif;\par
00544     iDif_1 = iDif;\par
00545     turnrate_1 = turnrate;\par
00546     turnref_1 = turnref;\par
00547 \par
00548     numSWIcalls++;\par
00549     \par
00550     DINT;\par
00551 \par
00552 \}\par
00553 \par
00554 {\cf20 // cpu_timer0_isr - CPU Timer0 ISR}\par
00555 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void})\par
00556 \{\par
00557     CpuTimer0.InterruptCount++;\par
00558 \par
00559     numTimer0calls++;\par
00560 \par
00561     {\cf20 // Acknowledge this interrupt to receive more interrupts from group 1}\par
00562     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00563 \}\par
00564 \par
00565 {\cf20 // cpu_timer1_isr - CPU Timer1 ISR}\par
00566 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void})\par
00567 \{\par
00568 \par
00569     CpuTimer1.InterruptCount++;\par
00570 \}\par
00571 \par
00572 {\cf20 // cpu_timer2_isr CPU Timer2 ISR}\par
00573 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void})\par
00574 \{\par
00575 \par
00576     UARTPrint2 = 1; {\cf20 //every 200 ms}\par
00577 \par
00578     CpuTimer2.InterruptCount++;\par
00579 \par
00580 \}\par
00581 \par
00582 {\cf20 // This function is called each time a char is recieved over UARTA.}\par
00583 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data) \{\par
00584     numRXA ++;\par
00585 \}\par
00586 \par
00587 {\cf18 char} sendback[10];\par
00588 {\cf18 char} past[14];\par
00589 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data) \{\par
00590 {\cf20 //    sendback[0] = data;}\par
00591 {\cf20 //    serial_send(&SerialA, sendback, 1); //every character that comes into BT will be echoed to Tera Term}\par
00592 \par
00593     {\cf20 //save past states}\par
00594     past[0] = past[1];\par
00595     past[1] = past[2];\par
00596     past[2] = past[3];\par
00597     past[3] = past[4];\par
00598     past[4] = past[5];\par
00599     past[5] = past[6];\par
00600     past[6] = past[7];\par
00601     past[7] = past[8];\par
00602     past[8] = past[9];\par
00603     past[9] = past[10];\par
00604     past[10] = past[11];\par
00605     past[11] = past[12];\par
00606     past[12] = past[13];\par
00607     past[13] = data;\par
00608 \par
00609     {\cf19 if}((past[0] == {\cf23 '!'})&&(past[1] == {\cf23 'A'}))\{\par
00610         {\cf20 //incoming accelerometer data (arbitrary start point 0)}\par
00611 \par
00612         {\cf20 //float is a 32-bit value (4x8-bit)}\par
00613         {\cf20 //mantissa*2^exp where mantissa takes ~upper 21 bits and ~lower 10 is exponent}\par
00614         {\cf20 //meaning it is not a standard ascii}\par
00615         {\cf20 //create a union}\par
00616         {\cf20 //there will be six 16-bit ints that make up 3 floats}\par
00617         {\cf20 //for a union, takes up same place in memory}\par
00618         {\cf20 //float comes over in 4 8 bit chunks}\par
00619 \par
00620         {\cf20 //X}\par
00621         phoneaccel.rawdata[0] = (past[3]<<8)|past[2];\par
00622         phoneaccel.rawdata[1] = (past[5]<<8)|past[4];\par
00623         {\cf20 //Y}\par
00624         phoneaccel.rawdata[2] = (past[7]<<8)|past[6];\par
00625         phoneaccel.rawdata[3] = (past[9]<<8)|past[8];\par
00626         {\cf20 //Z}\par
00627         phoneaccel.rawdata[4] = (past[11]<<8)|past[10];\par
00628         phoneaccel.rawdata[5] = (past[13]<<8)|past[12];\par
00629 \par
00630         ble_x = phoneaccel.fltdata[0];\par
00631         ble_y = phoneaccel.fltdata[1];\par
00632         ble_z = phoneaccel.fltdata[2];\par
00633 \par
00634         {\cf20 //Interpret phone accel data as steering instructions}\par
00635         {\cf19 if}(ble_y >= 0.3)\{\par
00636             {\cf20 //turn left}\par
00637 {\cf20 //            turnrate = -2.0;}\par
00638             turnrate = -4.0;\par
00639         \}{\cf19 else} {\cf19 if}(ble_y <= -0.3)\{\par
00640             {\cf20 //turn right}\par
00641 {\cf20 //            turnrate = 2.0;}\par
00642             turnrate = 4.0;\par
00643         \}{\cf19 else} {\cf19 if}(fabs(ble_y) < 0.3)\{\par
00644             {\cf20 //don't turn}\par
00645             turnrate = 0;\par
00646         \}\par
00647 \par
00648         {\cf19 if}(ble_z <= -0.3)\{\par
00649             {\cf20 //go forward}\par
00650             FwdBackOffset = -1.0;\par
00651         \}{\cf19 else} {\cf19 if}(ble_z >= 0.3)\{\par
00652             {\cf20 //go backward}\par
00653             FwdBackOffset = 1.0;\par
00654         \}{\cf19 else} {\cf19 if}(fabs(ble_z) < 0.3)\{\par
00655             {\cf20 //don't go forward or backward}\par
00656             FwdBackOffset = 0;\par
00657         \}\par
00658 \par
00659         UARTPrint = 1;\par
00660     \}\par
00661 \}\par
00662 \par
00663 __interrupt {\cf18 void} ADCA_ISR({\cf18 void})\{\par
00664         adca0result = AdcaResultRegs.ADCRESULT0; {\cf20 //read ADC values}\par
00665         adca1result = AdcaResultRegs.ADCRESULT1;\par
00666 \par
00667         {\cf20 // Here covert ADCIND0, ADCIND1 to volts}\par
00668         adca0_volts = adca0result/1365.0;\par
00669         adca1_volts = adca1result/1365.0;\par
00670 \par
00671         {\cf20 //SPI Read Gyros and Accelerometers}\par
00672 \par
00673         GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00674         SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 // Issue the SPIB_RX_INT when two values are in the RX FIFO}\par
00675 \par
00676         {\cf20 //write to TXBUF}\par
00677         SpibRegs.SPITXBUF = 0x8000|0x3A00; {\cf20 //start address (one register before accel)}\par
00678         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_XOUT}\par
00679         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_YOUT}\par
00680         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_ZOUT}\par
00681         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read TEMP_OUT}\par
00682         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_XOUT}\par
00683         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_YOUT}\par
00684         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_ZOUT}\par
00685 \par
00686         AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;  {\cf20 //clear interrupt flag}\par
00687         PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00688 \}\par
00689 \par
00690 __interrupt {\cf18 void} SPIB_isr({\cf18 void})\{\par
00691 \par
00692     {\cf20 //read from RX FIFO}\par
00693     Junk = SpibRegs.SPIRXBUF; {\cf20 //garbage value read}\par
00694     accelxraw = SpibRegs.SPIRXBUF;\par
00695     accelyraw = SpibRegs.SPIRXBUF;\par
00696     accelzraw = SpibRegs.SPIRXBUF;\par
00697     Junk = SpibRegs.SPIRXBUF;\par
00698     gyroxraw = SpibRegs.SPIRXBUF;\par
00699     gyroyraw = SpibRegs.SPIRXBUF;\par
00700     gyrozraw = SpibRegs.SPIRXBUF;\par
00701 \par
00702     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00703 \par
00704     accelx = (float)(accelxraw*4.0/32767.0); {\cf20 // m/s2, this value is saturated due to offset}\par
00705     accely = (float)(accelyraw*4.0/32767.0); {\cf20 // m/s2}\par
00706     accelz = (float)(accelzraw*4.0/32767.0); {\cf20 // m/s2}\par
00707     gyrox = (float)(gyroxraw*250.0/32767.0); {\cf20 //deg per second}\par
00708     gyroy = (float)(gyroyraw*250.0/32767.0); {\cf20 //deg per second}\par
00709     gyroz = (float)(gyrozraw*250.0/32767.0); {\cf20 //deg per second}\par
00710 \par
00711     {\cf20 //Code to be copied into SPIB_ISR interrupt function after the IMU measurements have been collected.}\par
00712       {\cf19 if}(calibration_state == 0)\{\par
00713             calibration_count++;\par
00714             {\cf19 if} (calibration_count == 2000) \{\par
00715                 calibration_state = 1;\par
00716                 calibration_count = 0;\par
00717             \}\par
00718         \} {\cf19 else} {\cf19 if}(calibration_state == 1)\{\par
00719             accelx_offset+=accelx;\par
00720             accely_offset+=accely;\par
00721             accelz_offset+=accelz;\par
00722             gyrox_offset+=gyrox;\par
00723             gyroy_offset+=gyroy;\par
00724             gyroz_offset+=gyroz;\par
00725             calibration_count++;\par
00726             {\cf19 if} (calibration_count == 2000) \{\par
00727                 calibration_state = 2;\par
00728                 accelx_offset/=2000.0;\par
00729                 accely_offset/=2000.0;\par
00730                 accelz_offset/=2000.0;\par
00731                 gyrox_offset/=2000.0;\par
00732                 gyroy_offset/=2000.0;\par
00733                 gyroz_offset/=2000.0;\par
00734                 calibration_count = 0;\par
00735                 doneCal = 1;\par
00736             \}\par
00737 \par
00738         \} {\cf19 else} {\cf19 if}(calibration_state == 2)\{\par
00739 \par
00740             accelx -=(accelx_offset);\par
00741             accely -=(accely_offset);\par
00742             accelz -=(accelz_offset-accelzBalancePoint);\par
00743             gyrox -= gyrox_offset;\par
00744             gyroy -= gyroy_offset;\par
00745             gyroz -= gyroz_offset;\par
00746 \par
00747             {\cf20 /*--------------Kalman Filtering code start---------------------------------------------------------------------*/}\par
00748             {\cf18 float} tiltrate = (gyrox*PI)/180.0; {\cf20 // rad/s}\par
00749             {\cf18 float} pred_tilt, z, y, S;\par
00750 \par
00751             {\cf20 // Prediction Step}\par
00752             pred_tilt = kalman_tilt + T*tiltrate;\par
00753             pred_P = kalman_P + Q;\par
00754 \par
00755             {\cf20 // Update Step}\par
00756             z = -accelz;  {\cf20 // Note the negative here due to the polarity of AccelZ}\par
00757             y = z - pred_tilt;\par
00758             S = pred_P + R;\par
00759             kalman_K = pred_P/S;\par
00760             kalman_tilt = pred_tilt + kalman_K*y;\par
00761             kalman_P = (1 - kalman_K)*pred_P;\par
00762 \par
00763             SpibNumCalls++;\par
00764             {\cf20 // Kalman Filter used}\par
00765             tilt_array[SpibNumCalls] = kalman_tilt;\par
00766             gyro_array[SpibNumCalls] = tiltrate;\par
00767             LeftWheelArray[SpibNumCalls] = -readEncLeft();\par
00768             RightWheelArray[SpibNumCalls] = readEncRight();\par
00769 \par
00770             {\cf19 if} (SpibNumCalls >= 3) \{  {\cf20 // should never be greater than 3}\par
00771                 tilt_value = (tilt_array[0] + tilt_array[1] + tilt_array[2] + tilt_array[3])/4.0;\par
00772                 gyro_value = (gyro_array[0] + gyro_array[1] + gyro_array[2] + gyro_array[3])/4.0;\par
00773                 LeftWheel=(LeftWheelArray[0]+LeftWheelArray[1]+LeftWheelArray[2]+LeftWheelArray[3])/4.0;\par
00774                 RightWheel=(RightWheelArray[0]+RightWheelArray[1]+RightWheelArray[2]+RightWheelArray[3])/4.0;\par
00775                 SpibNumCalls = -1;\par
00776 \par
00777                 PieCtrlRegs.PIEIFR12.bit.INTx9 = 1;  {\cf20 // Manually cause the interrupt for the SWI}\par
00778             \}\par
00779         \}\par
00780 \par
00781         timecount++;\par
00782 \par
00783         {\cf19 if}((timecount%200) == 0)\par
00784         \{\par
00785             {\cf19 if}(doneCal == 0) \{\par
00786                 GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;  {\cf20 // Blink Blue LED while calibrating}\par
00787             \}\par
00788             GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;  {\cf20 // Always Block Red LED}\par
00789 \par
00790 {\cf20 //            UARTPrint = 1;  // Tell While loop to print}\par
00791         \}\par
00792 \par
00793         SpibRegs.SPIFFRX.bit.RXFFOVFCLR=1;  {\cf20 // Clear Overflow flag}\par
00794         SpibRegs.SPIFFRX.bit.RXFFINTCLR=1;  {\cf20 // Clear Interrupt flag}\par
00795         PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
00796 \}\par
00797 \par
00798 {\cf18 float} readEncLeft({\cf18 void}) \{\par
00799     int32_t raw = 0;\par
00800     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U}\par
00801 \par
00802     raw = EQep1Regs.QPOSCNT;\par
00803     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00804 \par
00805     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00806     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00807     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00808     {\cf19 return} (raw*(TWOPI/600.0)); {\cf20 //wheel rotation in radians}\par
00809 \}\par
00810 \par
00811 {\cf18 float} readEncRight({\cf18 void}) \{\par
00812 \par
00813     int32_t raw = 0;\par
00814     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U  -1 32bit signed int}\par
00815 \par
00816     raw = EQep2Regs.QPOSCNT;\par
00817     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00818 \par
00819     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00820     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00821     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00822     {\cf19 return} (raw*(TWOPI/600.0));\par
00823 \}\par
00824 \par
00825 {\cf18 void} init_eQEPs({\cf18 void}) \{\par
00826 \par
00827     {\cf20 // setup eQEP1 pins for input}\par
00828     EALLOW;\par
00829     {\cf20 //Disable internal pull-up for the selected output pins for reduced power consumption}\par
00830     GpioCtrlRegs.GPAPUD.bit.GPIO20 = 1;    {\cf20 // Disable pull-up on GPIO20 (EQEP1A)}\par
00831     GpioCtrlRegs.GPAPUD.bit.GPIO21 = 1;    {\cf20 // Disable pull-up on GPIO21 (EQEP1B)}\par
00832     GpioCtrlRegs.GPAQSEL2.bit.GPIO20 = 2;   {\cf20 // Qual every 6 samples}\par
00833     GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 2;   {\cf20 // Qual every 6 samples}\par
00834     EDIS;\par
00835     {\cf20 // This specifies which of the possible GPIO pins will be EQEP1 functional pins.}\par
00836     {\cf20 // Comment out other unwanted lines.}\par
00837     GPIO_SetupPinMux(20, GPIO_MUX_CPU1, 1);\par
00838     GPIO_SetupPinMux(21, GPIO_MUX_CPU1, 1);\par
00839     EQep1Regs.QEPCTL.bit.QPEN = 0;    {\cf20 // make sure eqep in reset}\par
00840     EQep1Regs.QDECCTL.bit.QSRC = 0;   {\cf20 // Quadrature count mode}\par
00841     EQep1Regs.QPOSCTL.all = 0x0;      {\cf20 // Disable eQep Position Compare}\par
00842     EQep1Regs.QCAPCTL.all = 0x0;      {\cf20 // Disable eQep Capture}\par
00843     EQep1Regs.QEINT.all = 0x0;        {\cf20 // Disable all eQep interrupts}\par
00844     EQep1Regs.QPOSMAX = 0xFFFFFFFF;   {\cf20 // use full range of the 32 bit count}\par
00845     EQep1Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend in Code Composer}\par
00846     EQep1Regs.QPOSCNT = 0;\par
00847     EQep1Regs.QEPCTL.bit.QPEN = 1;    {\cf20 // Enable EQep}\par
00848 \par
00849 \par
00850     {\cf20 // setup QEP2 pins for input}\par
00851     EALLOW;\par
00852     {\cf20 //Disable internal pull-up for the selected output pinsfor reduced power consumption}\par
00853     GpioCtrlRegs.GPBPUD.bit.GPIO54 = 1;    {\cf20 // Disable pull-up on GPIO54 (EQEP2A)}\par
00854     GpioCtrlRegs.GPBPUD.bit.GPIO55 = 1;    {\cf20 // Disable pull-up on GPIO55 (EQEP2B)}\par
00855     GpioCtrlRegs.GPBQSEL2.bit.GPIO54 = 2;   {\cf20 // Qual every 6 samples}\par
00856     GpioCtrlRegs.GPBQSEL2.bit.GPIO55 = 2;   {\cf20 // Qual every 6 samples}\par
00857     EDIS;\par
00858     GPIO_SetupPinMux(54, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2A}\par
00859     GPIO_SetupPinMux(55, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2B}\par
00860     EQep2Regs.QEPCTL.bit.QPEN = 0;   {\cf20 // make sure qep reset}\par
00861     EQep2Regs.QDECCTL.bit.QSRC = 0;  {\cf20 // Quadrature count mode}\par
00862     EQep2Regs.QPOSCTL.all = 0x0;     {\cf20 // Disable eQep Position Compare}\par
00863     EQep2Regs.QCAPCTL.all = 0x0;     {\cf20 // Disable eQep Capture}\par
00864     EQep2Regs.QEINT.all = 0x0;       {\cf20 // Disable all eQep interrupts}\par
00865     EQep2Regs.QPOSMAX = 0xFFFFFFFF;  {\cf20 // use full range of the 32 bit count.}\par
00866     EQep2Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend}\par
00867     EQep2Regs.QPOSCNT = 0;\par
00868     EQep2Regs.QEPCTL.bit.QPEN = 1;   {\cf20 // Enable EQep}\par
00869 \}\par
00870 \par
00871 {\cf18 void} setEPWM2A({\cf18 float} controleffort)\{\par
00872     {\cf20 //saturate value}\par
00873     {\cf19 if}(controleffort > 10)\{\par
00874         controleffort = 10;\par
00875     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
00876         controleffort = -10;\par
00877     \}\par
00878 \par
00879     EPwm2Regs.CMPA.bit.CMPA = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
00880 \}\par
00881 \par
00882 {\cf18 void} setEPWM2B({\cf18 float} controleffort)\{\par
00883     {\cf19 if}(controleffort > 10)\{\par
00884         controleffort = 10;\par
00885     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
00886         controleffort = -10;\par
00887     \}\par
00888 \par
00889     EPwm2Regs.CMPB.bit.CMPB = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
00890 \}\par
00891 \par
00892 {\cf18 void} setupSpib({\cf18 void}) {\cf20 //Call this function in main() somewhere after the DINT; line of code.}\par
00893 \{\par
00894     int16_t temp = 0; {\cf20 // for reading RXBUF}\par
00895     {\cf20 //Step 1.}\par
00896     {\cf20 // cut and paste here all the SpibRegs initializations you found for part 3. Change so that 16 bits are}\par
00897     {\cf20 //transmitted each TX FIFO write and change the delay in between each transfer to 0.}\par
00898 \par
00899     {\cf20 //lab4 setup Serial}\par
00900     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO2 and used as DAN777 SS}\par
00901     GPIO_SetupPinOptions(2, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO2 an Output Pin}\par
00902     GpioDataRegs.GPASET.bit.GPIO2 = 1; {\cf20 //Initially Set GPIO2/SS High so DAN777 is not selected}\par
00903     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO66 and used as MPU-9250 SS}\par
00904     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO66 an Output Pin}\par
00905     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 //Initially Set GPIO66/SS High so MPU-9250 is not selected}\par
00906     GPIO_SetupPinMux(63, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO63 pin to SPISIMOB}\par
00907     GPIO_SetupPinMux(64, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO64 pin to SPISOMIB}\par
00908     GPIO_SetupPinMux(65, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO65 pin to SPICLKB}\par
00909     EALLOW;\par
00910     GpioCtrlRegs.GPBPUD.bit.GPIO63 = 0; {\cf20 // Enable Pull-ups on SPI PINs Recommended by TI for SPI Pins}\par
00911     GpioCtrlRegs.GPCPUD.bit.GPIO64 = 0;\par
00912     GpioCtrlRegs.GPCPUD.bit.GPIO65 = 0;\par
00913     GpioCtrlRegs.GPBQSEL2.bit.GPIO63 = 3; {\cf20 // Set prequalifier for SPI PINS}\par
00914     GpioCtrlRegs.GPCQSEL1.bit.GPIO64 = 3; {\cf20 // The prequalifier eliminates short noise spikes}\par
00915     GpioCtrlRegs.GPCQSEL1.bit.GPIO65 = 3; {\cf20 // by making sure the serial pin stays low for 3 clock periods.}\par
00916     EDIS;\par
00917     {\cf20 // ---------------------------------------------------------------------------}\par
00918     SpibRegs.SPICCR.bit.SPISWRESET = 0; {\cf20 // Put SPI in Reset}\par
00919     SpibRegs.SPICTL.bit.CLK_PHASE = 1; {\cf20 //This happens to be the mode for both the DAN777 and}\par
00920     SpibRegs.SPICCR.bit.CLKPOLARITY = 0; {\cf20 //The MPU-9250, Mode 01.}\par
00921     SpibRegs.SPICTL.bit.MASTER_SLAVE = 1; {\cf20 // Set to SPI Master}\par
00922     SpibRegs.SPICCR.bit.SPICHAR = 15; {\cf20 // Set to transmit and receive 16 bits each write to SPITXBUF}\par
00923     SpibRegs.SPICTL.bit.TALK = 1; {\cf20 // Enable transmission}\par
00924     SpibRegs.SPIPRI.bit.FREE = 1; {\cf20 // Free run, continue SPI operation}\par
00925     SpibRegs.SPICTL.bit.SPIINTENA = 0; {\cf20 // Disables the SPI interrupt}\par
00926     SpibRegs.SPIPRI.bit.SOFT = 0; {\cf20 // This line may not be used}\par
00927     SpibRegs.SPIBRR.bit.SPI_BIT_RATE = 49; {\cf20 // Set SCLK bit rate to 1 MHz so 1us period. SPI base clock is}\par
00928     {\cf20 // 50MHZ. And this setting divides that base clock to create SCLK\'92s period, there is a +1}\par
00929     SpibRegs.SPISTS.all = 0x0000; {\cf20 // Clear status flags just in case they are set for some reason}\par
00930     SpibRegs.SPIFFTX.bit.SPIRST = 1;{\cf20 // Pull SPI FIFO out of reset, SPI FIFO can resume transmit or receive.}\par
00931     SpibRegs.SPIFFTX.bit.SPIFFENA = 1; {\cf20 // Enable SPI FIFO enhancements}\par
00932     SpibRegs.SPIFFTX.bit.TXFIFO = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
00933     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFTX[TXFFINT] flag just in case it is set}\par
00934     SpibRegs.SPIFFRX.bit.RXFIFORESET = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
00935     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFOVF] just in case it is set}\par
00936     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFINT] flag just in case it is set}\par
00937     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // RX FIFO interrupt based on RXFFIL match}\par
00938     SpibRegs.SPIFFCT.bit.TXDLY = 0; {\cf20 //Set delay between transmits to 0 spi clocks.}\par
00939     SpibRegs.SPICCR.bit.SPISWRESET = 1; {\cf20 // Pull the SPI out of reset}\par
00940     SpibRegs.SPIFFTX.bit.TXFIFO = 1; {\cf20 // Release transmit FIFO from reset.}\par
00941     SpibRegs.SPIFFRX.bit.RXFIFORESET = 1; {\cf20 // Re-enable receive FIFO operation}\par
00942     SpibRegs.SPICTL.bit.SPIINTENA = 1; {\cf20 // Enables SPI interrupt. !! I don\'92t think this is needed. Need to Test}\par
00943     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Clear Interrupt flag just in case it is set}\par
00944     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear overflow flag just in case it is set}\par
00945     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Receive FIFO interrupt flag just in case it is set.}\par
00946     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // Enable the RX FIFO Interrupt. RXFFST >= RXFFIL}\par
00947     SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 //Interrupt Level to 7 words or more received into FIFO causes interrupt}\par
00948     {\cf20 //interrupt number of words in FIFO here AND in timer}\par
00949 \par
00950     {\cf20 //  EDIS;}\par
00951 \par
00952     {\cf20 // SpibRegs.SPICCR.bit.SPICHAR = 0xF;}\par
00953     {\cf20 // SpibRegs.SPIFFCT.bit.TXDLY = 0x00;}\par
00954     {\cf20 //-----------------------------------------------------------------------------------------------------------------}\par
00955     {\cf20 //Step 2.}\par
00956     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x13,0x14,0x15,0x16}\par
00957     {\cf20 // 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C 0x1D, 0x1E, 0x1F. Use only one SS low to high for all these writes}\par
00958     {\cf20 // some code is given, most you have to fill you yourself.}\par
00959     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00960     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
00961     SpibRegs.SPITXBUF = 0x1300; {\cf20 //start address,  To address 00x13 write 0x00}\par
00962     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x14 write 0x00, To address 00x15 write 0x00}\par
00963     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x16 write 0x00, To address 00x17 write 0x00}\par
00964     SpibRegs.SPITXBUF = 0x0013; {\cf20 // To address 00x18 write 0x00, To address 00x19 write 0x13}\par
00965     SpibRegs.SPITXBUF = 0x0200;{\cf20 // To address 00x1A write 0x02, To address 00x1B write 0x00}\par
00966     SpibRegs.SPITXBUF = 0x0806;{\cf20 // To address 00x1C write 0x08, To address 00x1D write 0x06}\par
00967     SpibRegs.SPITXBUF = 0x0000;{\cf20 // To address 00x1E write 0x00, To address 00x1F write 0x00}\par
00968 \par
00969     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
00970     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=7); {\cf20 //should this be 0?}\par
00971     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00972     temp = SpibRegs.SPIRXBUF; {\cf20 // read the garbage receive values off the RX FIFO to clear}\par
00973     temp = SpibRegs.SPIRXBUF;\par
00974     temp = SpibRegs.SPIRXBUF;\par
00975     temp = SpibRegs.SPIRXBUF;\par
00976     temp = SpibRegs.SPIRXBUF;\par
00977     temp = SpibRegs.SPIRXBUF;\par
00978     temp = SpibRegs.SPIRXBUF;\par
00979     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
00980 \par
00981     {\cf20 //Step 3.}\par
00982     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x23,0x24,0x25,0x26}\par
00983     {\cf20 // 0x27, 0x28, 0x29. Use only one SS low to high for all these writes}\par
00984     {\cf20 // some code is given, most you have to fill you yourself.}\par
00985     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00986     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
00987     SpibRegs.SPITXBUF = 0x2300; {\cf20 //start address, To address 00x23 write 0x00}\par
00988     SpibRegs.SPITXBUF = 0x408C;{\cf20 // To address 00x24 write 0x40, To address 00x25 write 0x8C}\par
00989     SpibRegs.SPITXBUF = 0x0288;{\cf20 // To address 00x26 write 0x02, To address 00x27 write 0x88}\par
00990     SpibRegs.SPITXBUF = 0x0C0A;{\cf20 // To address 00x28 write 0x0C, To address 00x29 write 0x0A}\par
00991 \par
00992     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
00993     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=4);\par
00994     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00995     temp = SpibRegs.SPIRXBUF;\par
00996     temp = SpibRegs.SPIRXBUF;\par
00997     temp = SpibRegs.SPIRXBUF;\par
00998     temp = SpibRegs.SPIRXBUF;\par
00999     {\cf20 // read the additional number of garbage receive values off the RX FIFO to clear out the RX FIFO}\par
01000     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
01001 \par
01002     {\cf20 //Step 4.}\par
01003     {\cf20 // perform a single 16 bit transfer to initialize MPU-9250 register 0x2A}\par
01004     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01005     SpibRegs.SPITXBUF = 0x2A81; {\cf20 //start address, Write to address 0x2A the value 0x81}\par
01006 \par
01007     {\cf20 // wait for one byte to be received}\par
01008     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01009     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01010     temp = SpibRegs.SPIRXBUF;\par
01011     DELAY_US(10);\par
01012 \par
01013     {\cf20 // The Remainder of this code is given to you and you do not need to make any changes.}\par
01014     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01015     SpibRegs.SPITXBUF = (0x3800 | 0x0001); {\cf20 // 0x3800}\par
01016     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01017     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01018     temp = SpibRegs.SPIRXBUF;\par
01019     DELAY_US(10);\par
01020     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01021     SpibRegs.SPITXBUF = (0x3A00 | 0x0001); {\cf20 // 0x3A00}\par
01022     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01023     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01024     temp = SpibRegs.SPIRXBUF;\par
01025     DELAY_US(10);\par
01026     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01027     SpibRegs.SPITXBUF = (0x6400 | 0x0001); {\cf20 // 0x6400}\par
01028     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01029     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01030     temp = SpibRegs.SPIRXBUF;\par
01031     DELAY_US(10);\par
01032     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01033     SpibRegs.SPITXBUF = (0x6700 | 0x0003); {\cf20 // 0x6700}\par
01034     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01035     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01036     temp = SpibRegs.SPIRXBUF;\par
01037     DELAY_US(10);\par
01038     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01039     SpibRegs.SPITXBUF = (0x6A00 | 0x0020); {\cf20 // 0x6A00}\par
01040     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01041     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01042     temp = SpibRegs.SPIRXBUF;\par
01043     DELAY_US(10);\par
01044     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01045     SpibRegs.SPITXBUF = (0x6B00 | 0x0001); {\cf20 // 0x6B00}\par
01046     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01047     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01048     temp = SpibRegs.SPIRXBUF;\par
01049     DELAY_US(10);\par
01050     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01051     SpibRegs.SPITXBUF = (0x7500 | 0x0071); {\cf20 // 0x7500}\par
01052     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01053     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01054     temp = SpibRegs.SPIRXBUF;\par
01055     DELAY_US(10);\par
01056     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01057 {\cf20 //    SpibRegs.SPITXBUF = (0x7700 | 0x00EB); // 0x7700}\par
01058     SpibRegs.SPITXBUF = (0x7700 | 0x0000); {\cf20 // 0x7700}\par
01059     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01060     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01061     temp = SpibRegs.SPIRXBUF;\par
01062     DELAY_US(10);\par
01063     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01064 {\cf20 //    SpibRegs.SPITXBUF = (0x7800 | 0x0012); // 0x7800}\par
01065     SpibRegs.SPITXBUF = (0x7800 | 0x0000); {\cf20 // 0x7800}\par
01066     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01067     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01068     temp = SpibRegs.SPIRXBUF;\par
01069     DELAY_US(10);\par
01070     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01071     SpibRegs.SPITXBUF = (0x7A00 | 0x0010); {\cf20 // 0x7A00}\par
01072     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01073     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01074     temp = SpibRegs.SPIRXBUF;\par
01075     DELAY_US(10);\par
01076     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01077     SpibRegs.SPITXBUF = (0x7B00 | 0x00FA); {\cf20 // 0x7B00}\par
01078     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01079     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01080     temp = SpibRegs.SPIRXBUF;\par
01081     DELAY_US(10);\par
01082     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01083     SpibRegs.SPITXBUF = (0x7D00 | 0x0021); {\cf20 // 0x7D00}\par
01084     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01085     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01086     temp = SpibRegs.SPIRXBUF;\par
01087     DELAY_US(10);\par
01088     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01089     SpibRegs.SPITXBUF = (0x7E00 | 0x0050); {\cf20 // 0x7E00}\par
01090     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01091     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01092     temp = SpibRegs.SPIRXBUF;\par
01093     DELAY_US(50);\par
01094 \par
01095     {\cf20 // Clear SPIB interrupt source just in case it was issued due to any of the above initializations.}\par
01096     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear Overflow flag}\par
01097     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Interrupt flag}\par
01098     PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
01099 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot4.c File Reference\par \pard\plain 
{\tc\tcl2 \v UART_Segbot4.c}
{\xe \v UART_Segbot4.c}
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include "F28x_Project.h"}\par
{\f2 #include "driverlib.h"}\par
{\f2 #include "F2837xD_device.h"}\par
{\f2 #include "f28379dSerial.h"}\par
{\f2 #include "LEDPatterns.h"}\par
{\f2 #include "song.h"}\par
{\f2 #include "dsp.h"}\par
{\f2 #include "fpu_rfft.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union {\b phonedata_s}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PI}\~ 3.1415926535897932384626433832795\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TWOPI}\~ 6.283185307179586476925286766559\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HALFPI}\~ 1.5707963267948966192313216916398\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b songsize}\~ 14\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b sampling_rate}\~ 10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NOTE}\~ 625\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b n_samples}\~ 1000\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef union {\b phonedata_s} {\b phonedata_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer0_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer1_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b cpu_timer2_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SWI_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b SPIB_isr} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b ADCA_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__interrupt void {\b ADCB_ISR} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupSpib} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXA} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serialRXC} ({\b serial_t} *s, char data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_eQEPs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncLeft} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b readEncRight} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2A} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEPWM2B} (float)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b goertzel_mag} (int numSamples, int TARGET_FREQUENCY, int SAMPLING_RATE, float *data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b main} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b phonedata_t} {\b phoneaccel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b song} [{\b songsize}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b dance} [{\b songsize}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b pwm12prd} = 50000000/{\b sampling_rate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b note_detected} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b thresh} = 150\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adcb_arrayPing} [{\b n_samples}] = \{0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adcb_arrayPong} [{\b n_samples}] = \{0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adcb0result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b adcbcount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b PingPong} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b RunPong} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b RunPing} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b goer_result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b steeroff} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numTimer0calls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numSWIcalls} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b numRXA} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b UARTPrint2} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LEDdisplaynum} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b Junk} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b accelzraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroxraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyroyraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b gyrozraw} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightVel_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ubal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K1} = -60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K2} = -7.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b K3} = -1.1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b WheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b velWheelDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnref_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uLeft} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uRight} = 5.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b iDif_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turn} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kp} = 3.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Ki} = 20.0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Kd} = .01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b FwdBackOffset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b turnrate_1} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca0_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b adca1_volts} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca0result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b adca1result} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelx_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accely_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyrox_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroy_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyroz_offset} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b accelzBalancePoint} = -.73\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16 {\b IMU_data} [9]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b temp} =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b doneCal} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b tilt_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_value} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b gyro_array} [4] = \{0, 0, 0, 0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LeftWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b RightWheelArray} [4] = \{0,0,0,0\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b T} = 0.001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Q} = 0.01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b R} = 25000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_tilt} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_P} = 22.365\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b SpibNumCalls} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pred_P} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b kalman_K} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b timecount} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int16_t {\b calibration_state} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b calibration_count} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_x} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_y} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b ble_z} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sendback} [10]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b past} [14]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HALFPI\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:HALFPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HALFPI\~ 1.5707963267948966192313216916398}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v n_samples\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:n_samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define n_samples\~ 1000}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v NOTE\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NOTE\~ 625}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v PI\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PI\~ 3.1415926535897932384626433832795}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v sampling_rate\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:sampling_rate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define sampling_rate\~ 10000}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v songsize\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:songsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define songsize\~ 14}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v TWOPI\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:TWOPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TWOPI\~ 6.283185307179586476925286766559}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b UART_Segbot4.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v phonedata_t\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:phonedata_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef union {\b phonedata_s} {\b phonedata_t}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ADCA_ISR\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:ADCA_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void ADCA_ISR (void )}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 776} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v ADCB_ISR\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:ADCB_ISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void ADCB_ISR (void )}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 911} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v cpu_timer0_isr\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:cpu_timer0_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer0_isr (void )}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 645} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v cpu_timer1_isr\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:cpu_timer1_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer1_isr (void )}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 675} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v cpu_timer2_isr\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:cpu_timer2_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void cpu_timer2_isr (void )}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 682} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v goertzel_mag\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:goertzel_mag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float goertzel_mag (int numSamples, int TARGET_FREQUENCY, int SAMPLING_RATE, float * data)}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1243} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v init_eQEPs\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:init_eQEPs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_eQEPs (void )}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 968} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v main\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void main (void )}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v readEncLeft\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:readEncLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncLeft (void )}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 941} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v readEncRight\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:readEncRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float readEncRight (void )}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 954} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v serialRXA\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:serialRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXA ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 692} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v serialRXC\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:serialRXC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serialRXC ({\b serial_t} * s, char data)}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 698} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v setEPWM2A\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:setEPWM2A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2A (float controleffort)}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1014} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v setEPWM2B\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:setEPWM2B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEPWM2B (float controleffort)}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1025} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v setupSpib\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:setupSpib}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setupSpib (void )}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1035} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v SPIB_isr\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:SPIB_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SPIB_isr (void )}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 803} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v SWI_isr\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:SWI_isr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__interrupt void SWI_isr (void )}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 582} of file {\b UART_Segbot4.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v accelx\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx = 0}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accelx_offset\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelx_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelx_offset = 0}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accelxraw\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelxraw = 0}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accely\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely = 0}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accely_offset\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accely_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accely_offset = 0}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accelyraw\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelyraw = 0}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accelz\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz = 0}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accelz_offset\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelz_offset = 0}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accelzBalancePoint\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelzBalancePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float accelzBalancePoint = -.73}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v accelzraw\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:accelzraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t accelzraw = 0}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adca0_volts\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adca0_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca0_volts = 0}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adca0result\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adca0result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca0result = 0}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adca1_volts\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adca1_volts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adca1_volts = 0}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adca1result\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adca1result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adca1result = 0}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adcb0result\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adcb0result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t adcb0result = 0}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adcb_arrayPing\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adcb_arrayPing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adcb_arrayPing[{\b n_samples}] = \{0\}}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adcb_arrayPong\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adcb_arrayPong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float adcb_arrayPong[{\b n_samples}] = \{0\}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v adcbcount\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:adcbcount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t adcbcount = 0}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v ble_x\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:ble_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_x = 0}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v ble_y\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:ble_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_y = 0}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v ble_z\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:ble_z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ble_z = 0}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v calibration_count\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:calibration_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t calibration_count = 0}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 175} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v calibration_state\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:calibration_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t calibration_state = 0}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v dance\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:dance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float dance[{\b songsize}]}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{-6,6,-6,6,\par
                         -6,6,-6,6,\par
                         -6,6,-6,6,\par
                         -6,6\par
                        \}\par
}
{
Definition at line {\b 63} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v doneCal\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:doneCal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t doneCal = 0}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v eDif\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:eDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif = 0}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v eDif_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:eDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float eDif_1 = 0}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v FwdBackOffset\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:FwdBackOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float FwdBackOffset = 0}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v goer_result\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:goer_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float goer_result = 0}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyro_array\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyro_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyro_value\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyro_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyro_value = 0}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyrox\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyrox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox = 0}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyrox_offset\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyrox_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyrox_offset = 0}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyroxraw\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyroxraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroxraw = 0}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyroy\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy = 0}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyroy_offset\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyroy_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroy_offset = 0}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyroyraw\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyroyraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyroyraw = 0}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyroz\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyroz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz = 0}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyroz_offset\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyroz_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float gyroz_offset = 0}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v gyrozraw\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:gyrozraw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t gyrozraw = 0}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v iDif\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:iDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif = 0}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v iDif_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:iDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float iDif_1 = 0}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v IMU_data\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:IMU_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16 IMU_data[9]}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v Junk\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:Junk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t Junk = 0}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v K1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:K1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K1 = -60}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v K2\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:K2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K2 = -7.0}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v K3\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:K3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float K3 = -1.1}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v kalman_K\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:kalman_K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_K = 0}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v kalman_P\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:kalman_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_P = 22.365}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v kalman_tilt\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:kalman_tilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float kalman_tilt = 0}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v Kd\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:Kd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kd = .01}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v Ki\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:Ki}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Ki = 20.0}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v Kp\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:Kp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Kp = 3.0}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v LEDdisplaynum\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:LEDdisplaynum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LEDdisplaynum = 0}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v LeftVel\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:LeftVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel = 0}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v LeftVel_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:LeftVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftVel_1 = 0}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v LeftWheel\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:LeftWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel = 0}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v LeftWheel_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:LeftWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheel_1 = 0}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v LeftWheelArray\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:LeftWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LeftWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v note_detected\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:note_detected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t note_detected = 0}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v numRXA\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:numRXA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numRXA = 0}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v numSWIcalls\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:numSWIcalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numSWIcalls = 0}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v numTimer0calls\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:numTimer0calls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t numTimer0calls = 0}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v past\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:past}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char past[14]}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 697} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v phoneaccel\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:phoneaccel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b phonedata_t} phoneaccel}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v PingPong\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:PingPong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t PingPong = 0}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v pred_P\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:pred_P}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float pred_P = 0}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v pwm12prd\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:pwm12prd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t pwm12prd = 50000000/{\b sampling_rate}}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v Q\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:Q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Q = 0.01}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v R\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:R}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float R = 25000}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v RightVel\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:RightVel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel = 0}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v RightVel_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:RightVel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightVel_1 = 0}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v RightWheel\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:RightWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel = 0}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v RightWheel_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:RightWheel_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheel_1 = 0}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v RightWheelArray\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:RightWheelArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float RightWheelArray[4] = \{0,0,0,0\}}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v RunPing\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:RunPing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t RunPing = 0}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v RunPong\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:RunPong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t RunPong = 0}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v sendback\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:sendback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char sendback[10]}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 696} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v song\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:song}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float song[{\b songsize}]}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{F5NOTE,F5NOTE,F5NOTE,F5NOTE,\par
                        E5NOTE,E5NOTE,F5NOTE,F5NOTE,\par
                        E5NOTE,E5NOTE,D5NOTE,D5NOTE,\par
                        G5NOTE,G5NOTE\par
                        \}\par
}
{
Definition at line {\b 58} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v SpibNumCalls\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:SpibNumCalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t SpibNumCalls = -1}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v steeroff\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:steeroff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t steeroff = 0}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v T\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float T = 0.001}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v temp\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t temp =0}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v thresh\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:thresh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int16_t thresh = 150}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v tilt_array\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:tilt_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_array[4] = \{0, 0, 0, 0\}}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v tilt_value\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:tilt_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float tilt_value = 0}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v timecount\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:timecount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t timecount = 0}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 173} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v turn\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turn = 0}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v turnrate\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:turnrate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate = 0}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v turnrate_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:turnrate_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnrate_1 = 0}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v turnref\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:turnref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref = 0}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v turnref_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:turnref_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float turnref_1 = 0}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v UARTPrint\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:UARTPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint = 0}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v UARTPrint2\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:UARTPrint2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t UARTPrint2 = 0}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v ubal\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:ubal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float ubal = 0}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v uLeft\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:uLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uLeft = 5.0}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v uRight\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:uRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float uRight = 5.0}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v velWheelDif\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:velWheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif = 0}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v velWheelDif_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:velWheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float velWheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v WheelDif\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:WheelDif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif = 0}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b UART_Segbot4.c}.}\par
}
{\xe \v WheelDif_1\:UART_Segbot4.c}
{\xe \v UART_Segbot4.c\:WheelDif_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float WheelDif_1 = 0}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b UART_Segbot4.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
UART_Segbot4.c\par \pard\plain 
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //#############################################################################}\par
00002 {\cf20 //UART_Segbot Steer and Celebrate}\par
00003 {\cf20 //#############################################################################}\par
00004 \par
00005 {\cf20 // Included Files}\par
00006 {\cf21 #include <stdio.h>}\par
00007 {\cf21 #include <stdlib.h>}\par
00008 {\cf21 #include <stdarg.h>}\par
00009 {\cf21 #include <string.h>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include <limits.h>}\par
00012 {\cf21 #include "F28x_Project.h"}\par
00013 {\cf21 #include "driverlib.h"}\par
00014 {\cf21 #include "F2837xD_device.h"}\par
00015 {\cf21 #include "f28379dSerial.h"}\par
00016 {\cf21 #include "LEDPatterns.h"}\par
00017 {\cf21 #include "song.h"}\par
00018 {\cf21 #include "dsp.h"}\par
00019 {\cf21 #include "fpu_rfft.h"}\par
00020 \par
00021 {\cf21 #define PI          3.1415926535897932384626433832795}\par
00022 {\cf21 #define TWOPI       6.283185307179586476925286766559}\par
00023 {\cf21 #define HALFPI      1.5707963267948966192313216916398}\par
00024 \par
00025 {\cf20 //NOTES DEFINED IN song.h}\par
00026 {\cf21 #define songsize    14}\par
00027 {\cf21 #define sampling_rate 10000 }{\cf20 // 10 kHz}\par
00028 {\cf21 #define NOTE    625 }{\cf20 // Cheer}\par
00029 {\cf21 #define n_samples   1000 }{\cf20 // with a sampling frequency of 10kHz, this runs Goertzl 10x per second with 1000 ADC samples}\par
00030 \par
00031 {\cf20 // Interrupt Service Routines predefinition}\par
00032 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void});\par
00033 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void});\par
00034 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void});\par
00035 __interrupt {\cf18 void} SWI_isr({\cf18 void});\par
00036 __interrupt {\cf18 void} SPIB_isr({\cf18 void});\par
00037 __interrupt {\cf18 void} ADCA_ISR({\cf18 void});\par
00038 __interrupt {\cf18 void} ADCB_ISR({\cf18 void});\par
00039 \par
00040 {\cf18 void} setupSpib({\cf18 void});\par
00041 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data);\par
00042 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data);\par
00043 {\cf18 void} init_eQEPs({\cf18 void});\par
00044 {\cf18 float} readEncLeft({\cf18 void});\par
00045 {\cf18 float} readEncRight({\cf18 void});\par
00046 {\cf18 void} setEPWM2A({\cf18 float});\par
00047 {\cf18 void} setEPWM2B({\cf18 float});\par
00048 {\cf18 float} goertzel_mag({\cf18 int} numSamples,{\cf18 int} TARGET_FREQUENCY,{\cf18 int} SAMPLING_RATE, {\cf18 float}* data);\par
00049 \par
00050 {\cf17 typedef} {\cf17 union }phonedata_s\{\par
00051     uint16_t rawdata[6];\par
00052     {\cf18 float} fltdata[3];\par
00053 \par
00054 \}phonedata_t;\par
00055 phonedata_t phoneaccel; {\cf20 //use new data type defined in union}\par
00056 \par
00057 {\cf20 //Song}\par
00058 {\cf18 float} song[songsize] = \{F5NOTE,F5NOTE,F5NOTE,F5NOTE,\par
00059                         E5NOTE,E5NOTE,F5NOTE,F5NOTE,\par
00060                         E5NOTE,E5NOTE,D5NOTE,D5NOTE,\par
00061                         G5NOTE,G5NOTE\par
00062                         \};\par
00063 {\cf18 float} dance[songsize] = \{-6,6,-6,6,\par
00064                          -6,6,-6,6,\par
00065                          -6,6,-6,6,\par
00066                          -6,6\par
00067                         \};\par
00068 \par
00069 int16_t pwm12prd = 50000000/sampling_rate;\par
00070 int16_t note_detected = 0;\par
00071 int16_t thresh = 150; {\cf20 //tune this value}\par
00072 {\cf18 float} adcb_arrayPing[n_samples]= \{0\};\par
00073 {\cf18 float} adcb_arrayPong[n_samples]= \{0\};\par
00074 int16_t adcb0result = 0;\par
00075 int32_t adcbcount = 0;\par
00076 int16_t PingPong = 0;\par
00077 int16_t RunPong = 0;\par
00078 int16_t RunPing = 0;\par
00079 {\cf18 float} goer_result = 0;\par
00080 int16_t steeroff = 0;\par
00081 \par
00082 {\cf20 // Count variables}\par
00083 uint32_t numTimer0calls = 0;\par
00084 uint32_t numSWIcalls = 0;\par
00085 uint32_t numRXA = 0;\par
00086 uint16_t UARTPrint = 0;\par
00087 uint16_t UARTPrint2 = 0;\par
00088 uint16_t LEDdisplaynum = 0;\par
00089 \par
00090 int16_t Junk = 0;\par
00091 \par
00092 int16_t accelxraw = 0;\par
00093 int16_t accelyraw = 0;\par
00094 int16_t accelzraw = 0;\par
00095 int16_t gyroxraw = 0;\par
00096 int16_t gyroyraw = 0;\par
00097 int16_t gyrozraw = 0;\par
00098 \par
00099 {\cf18 float} accelx = 0;\par
00100 {\cf18 float} accely = 0;\par
00101 {\cf18 float} accelz = 0;\par
00102 {\cf18 float} gyrox = 0;\par
00103 {\cf18 float} gyroy = 0;\par
00104 {\cf18 float} gyroz = 0;\par
00105 {\cf18 float} LeftWheel = 0;\par
00106 {\cf18 float} RightWheel = 0;\par
00107 {\cf18 float} LeftWheel_1 = 0;\par
00108 {\cf18 float} RightWheel_1 = 0;\par
00109 {\cf18 float} LeftVel = 0;\par
00110 {\cf18 float} RightVel = 0;\par
00111 {\cf18 float} LeftVel_1 = 0;\par
00112 {\cf18 float} RightVel_1 = 0;\par
00113 {\cf18 float} ubal = 0;\par
00114 {\cf18 float} K1 = -60;\par
00115 {\cf20 //float K2 = -4.5;}\par
00116 {\cf18 float} K2 = -7.0;\par
00117 {\cf18 float} K3 = -1.1;\par
00118 {\cf18 float} WheelDif = 0;\par
00119 {\cf18 float} velWheelDif = 0;\par
00120 {\cf18 float} WheelDif_1 = 0;\par
00121 {\cf18 float} velWheelDif_1 = 0;\par
00122 {\cf18 float} turnref = 0;\par
00123 {\cf18 float} turnref_1 = 0;\par
00124 {\cf18 float} uLeft = 5.0;\par
00125 {\cf18 float} uRight = 5.0;\par
00126 {\cf18 float} eDif = 0;\par
00127 {\cf18 float} iDif = 0;\par
00128 {\cf18 float} eDif_1 = 0;\par
00129 {\cf18 float} iDif_1 = 0;\par
00130 {\cf18 float} turn = 0; {\cf20 //turn setpoint}\par
00131 {\cf18 float} Kp = 3.0;\par
00132 {\cf18 float} Ki = 20.0;\par
00133 {\cf20 //float Kd = .08;}\par
00134 {\cf18 float} Kd = .01;\par
00135 {\cf18 float} FwdBackOffset = 0;\par
00136 {\cf18 float} turnrate = 0;\par
00137 {\cf18 float} turnrate_1 = 0;\par
00138 \par
00139 \par
00140 {\cf20 //lab4 variables}\par
00141 {\cf18 float} adca0_volts = 0;\par
00142 {\cf18 float} adca1_volts = 0;\par
00143 int16_t adca0result = 0;\par
00144 int16_t adca1result = 0;\par
00145 \par
00146 {\cf20 // Needed global Variables}\par
00147 {\cf18 float} accelx_offset = 0;\par
00148 {\cf18 float} accely_offset = 0;\par
00149 {\cf18 float} accelz_offset = 0;\par
00150 {\cf18 float} gyrox_offset  = 0;\par
00151 {\cf18 float} gyroy_offset  = 0;\par
00152 {\cf18 float} gyroz_offset  = 0;\par
00153 {\cf20 //float accelzBalancePoint = -.76; // tune this}\par
00154 {\cf18 float} accelzBalancePoint = -.73;\par
00155 int16 IMU_data[9];\par
00156 uint16_t temp=0;\par
00157 int16_t doneCal = 0;\par
00158 {\cf18 float} tilt_value    = 0;\par
00159 {\cf18 float} tilt_array[4] = \{0, 0, 0, 0\};\par
00160 {\cf18 float} gyro_value    = 0;\par
00161 {\cf18 float} gyro_array[4] = \{0, 0, 0, 0\};\par
00162 {\cf18 float} LeftWheelArray[4] = \{0,0,0,0\};\par
00163 {\cf18 float} RightWheelArray[4] = \{0,0,0,0\};\par
00164 {\cf20 // Kalman Filter vars}\par
00165 {\cf18 float} T = 0.001;        {\cf20 //sample rate, 1ms}\par
00166 {\cf18 float} Q = 0.01; {\cf20 // made global to enable changing in runtime}\par
00167 {\cf18 float} R = 25000;{\cf20 //50000;}\par
00168 {\cf18 float} kalman_tilt = 0;\par
00169 {\cf18 float} kalman_P = 22.365;\par
00170 int16_t SpibNumCalls = -1;\par
00171 {\cf18 float} pred_P = 0;\par
00172 {\cf18 float} kalman_K = 0;\par
00173 int32_t timecount = 0;\par
00174 int16_t calibration_state = 0;\par
00175 int32_t calibration_count = 0;\par
00176 \par
00177 {\cf20 //BLE DATA}\par
00178 {\cf18 float} ble_x = 0;\par
00179 {\cf18 float} ble_y = 0;\par
00180 {\cf18 float} ble_z = 0;\par
00181 \par
00182 {\cf18 void} main({\cf18 void})\par
00183  \{\par
00184     {\cf20 // PLL, WatchDog, enable Peripheral Clocks}\par
00185     {\cf20 // This example function is found in the F2837xD_SysCtrl.c file.}\par
00186     InitSysCtrl();\par
00187 \par
00188     InitGpio();\par
00189 \par
00190     {\cf20 // Blue LED on LuanchPad}\par
00191     GPIO_SetupPinMux(31, GPIO_MUX_CPU1, 0);\par
00192     GPIO_SetupPinOptions(31, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00193     GpioDataRegs.GPASET.bit.GPIO31 = 1;\par
00194 \par
00195     {\cf20 // Red LED on LaunchPad}\par
00196     GPIO_SetupPinMux(34, GPIO_MUX_CPU1, 0);\par
00197     GPIO_SetupPinOptions(34, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00198     GpioDataRegs.GPBSET.bit.GPIO34 = 1;\par
00199 \par
00200     {\cf20 // LED1 and PWM Pin}\par
00201     GPIO_SetupPinMux(22, GPIO_MUX_CPU1, 0);\par
00202     GPIO_SetupPinOptions(22, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00203     GpioDataRegs.GPACLEAR.bit.GPIO22 = 1;\par
00204 \par
00205     {\cf20 // LED2}\par
00206     GPIO_SetupPinMux(94, GPIO_MUX_CPU1, 0);\par
00207     GPIO_SetupPinOptions(94, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00208     GpioDataRegs.GPCCLEAR.bit.GPIO94 = 1;\par
00209 \par
00210     {\cf20 // LED3}\par
00211     GPIO_SetupPinMux(95, GPIO_MUX_CPU1, 0);\par
00212     GPIO_SetupPinOptions(95, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00213     GpioDataRegs.GPCCLEAR.bit.GPIO95 = 1;\par
00214 \par
00215     {\cf20 // LED4}\par
00216     GPIO_SetupPinMux(97, GPIO_MUX_CPU1, 0);\par
00217     GPIO_SetupPinOptions(97, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00218     GpioDataRegs.GPDCLEAR.bit.GPIO97 = 1;\par
00219 \par
00220     {\cf20 // LED5}\par
00221     GPIO_SetupPinMux(111, GPIO_MUX_CPU1, 0);\par
00222     GPIO_SetupPinOptions(111, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00223     GpioDataRegs.GPDCLEAR.bit.GPIO111 = 1;\par
00224 \par
00225     {\cf20 // LED6}\par
00226     GPIO_SetupPinMux(130, GPIO_MUX_CPU1, 0);\par
00227     GPIO_SetupPinOptions(130, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00228     GpioDataRegs.GPECLEAR.bit.GPIO130 = 1;\par
00229 \par
00230     {\cf20 // LED7}\par
00231     GPIO_SetupPinMux(131, GPIO_MUX_CPU1, 0);\par
00232     GPIO_SetupPinOptions(131, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00233     GpioDataRegs.GPECLEAR.bit.GPIO131 = 1;\par
00234 \par
00235     {\cf20 // LED8}\par
00236     GPIO_SetupPinMux(25, GPIO_MUX_CPU1, 0);\par
00237     GPIO_SetupPinOptions(25, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00238     GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;\par
00239 \par
00240     {\cf20 // LED9}\par
00241     GPIO_SetupPinMux(26, GPIO_MUX_CPU1, 0);\par
00242     GPIO_SetupPinOptions(26, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00243     GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;\par
00244 \par
00245     {\cf20 // LED10}\par
00246     GPIO_SetupPinMux(27, GPIO_MUX_CPU1, 0);\par
00247     GPIO_SetupPinOptions(27, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00248     GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;\par
00249 \par
00250     {\cf20 // LED11}\par
00251     GPIO_SetupPinMux(60, GPIO_MUX_CPU1, 0);\par
00252     GPIO_SetupPinOptions(60, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00253     GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;\par
00254 \par
00255     {\cf20 // LED12}\par
00256     GPIO_SetupPinMux(61, GPIO_MUX_CPU1, 0);\par
00257     GPIO_SetupPinOptions(61, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00258     GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;\par
00259 \par
00260     {\cf20 // LED13}\par
00261     GPIO_SetupPinMux(157, GPIO_MUX_CPU1, 0);\par
00262     GPIO_SetupPinOptions(157, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00263     GpioDataRegs.GPECLEAR.bit.GPIO157 = 1;\par
00264 \par
00265     {\cf20 // LED14}\par
00266     GPIO_SetupPinMux(158, GPIO_MUX_CPU1, 0);\par
00267     GPIO_SetupPinOptions(158, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00268     GpioDataRegs.GPECLEAR.bit.GPIO158 = 1;\par
00269 \par
00270     {\cf20 // LED15}\par
00271     GPIO_SetupPinMux(159, GPIO_MUX_CPU1, 0);\par
00272     GPIO_SetupPinOptions(159, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00273     GpioDataRegs.GPECLEAR.bit.GPIO159 = 1;\par
00274 \par
00275     {\cf20 // LED16}\par
00276     GPIO_SetupPinMux(160, GPIO_MUX_CPU1, 0);\par
00277     GPIO_SetupPinOptions(160, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00278     GpioDataRegs.GPFCLEAR.bit.GPIO160 = 1;\par
00279 \par
00280     {\cf20 //WIZNET Reset}\par
00281     GPIO_SetupPinMux(0, GPIO_MUX_CPU1, 0);\par
00282     GPIO_SetupPinOptions(0, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00283     GpioDataRegs.GPASET.bit.GPIO0 = 1;\par
00284 \par
00285     {\cf20 //ESP8266 Reset}\par
00286     GPIO_SetupPinMux(1, GPIO_MUX_CPU1, 0);\par
00287     GPIO_SetupPinOptions(1, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00288     GpioDataRegs.GPASET.bit.GPIO1 = 1;\par
00289 \par
00290     {\cf20 //SPIRAM  CS  Chip Select}\par
00291     GPIO_SetupPinMux(19, GPIO_MUX_CPU1, 0);\par
00292     GPIO_SetupPinOptions(19, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00293     GpioDataRegs.GPASET.bit.GPIO19 = 1;\par
00294 \par
00295     {\cf20 //DRV8874 #1 DIR  Direction}\par
00296     GPIO_SetupPinMux(29, GPIO_MUX_CPU1, 0);\par
00297     GPIO_SetupPinOptions(29, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00298     GpioDataRegs.GPASET.bit.GPIO29 = 1;\par
00299 \par
00300     {\cf20 //DRV8874 #2 DIR  Direction}\par
00301     GPIO_SetupPinMux(32, GPIO_MUX_CPU1, 0);\par
00302     GPIO_SetupPinOptions(32, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00303     GpioDataRegs.GPBSET.bit.GPIO32 = 1;\par
00304 \par
00305     {\cf20 //DAN28027  CS  Chip Select}\par
00306     GPIO_SetupPinMux(9, GPIO_MUX_CPU1, 0);\par
00307     GPIO_SetupPinOptions(9, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00308     GpioDataRegs.GPASET.bit.GPIO9 = 1;\par
00309 \par
00310     {\cf20 //MPU9250  CS  Chip Select}\par
00311     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0);\par
00312     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00313     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
00314 \par
00315     {\cf20 //WIZNET  CS  Chip Select}\par
00316     GPIO_SetupPinMux(125, GPIO_MUX_CPU1, 0);\par
00317     GPIO_SetupPinOptions(125, GPIO_OUTPUT, GPIO_PUSHPULL);\par
00318     GpioDataRegs.GPDSET.bit.GPIO125 = 1;\par
00319 \par
00320     {\cf20 //PushButton 1}\par
00321     GPIO_SetupPinMux(4, GPIO_MUX_CPU1, 0);\par
00322     GPIO_SetupPinOptions(4, GPIO_INPUT, GPIO_PULLUP);\par
00323 \par
00324     {\cf20 //PushButton 2}\par
00325     GPIO_SetupPinMux(5, GPIO_MUX_CPU1, 0);\par
00326     GPIO_SetupPinOptions(5, GPIO_INPUT, GPIO_PULLUP);\par
00327 \par
00328     {\cf20 //PushButton 3}\par
00329     GPIO_SetupPinMux(6, GPIO_MUX_CPU1, 0);\par
00330     GPIO_SetupPinOptions(6, GPIO_INPUT, GPIO_PULLUP);\par
00331 \par
00332     {\cf20 //PushButton 4}\par
00333     GPIO_SetupPinMux(7, GPIO_MUX_CPU1, 0);\par
00334     GPIO_SetupPinOptions(7, GPIO_INPUT, GPIO_PULLUP);\par
00335 \par
00336     {\cf20 //Joy Stick Pushbutton}\par
00337     GPIO_SetupPinMux(8, GPIO_MUX_CPU1, 0);\par
00338     GPIO_SetupPinOptions(8, GPIO_INPUT, GPIO_PULLUP);\par
00339 \par
00340     {\cf20 //Ground GPIO1 Connected to BT CTS Pin}\par
00341     GpioDataRegs.GPACLEAR.bit.GPIO1 = 1;\par
00342 \par
00343     {\cf20 // Clear all interrupts and initialize PIE vector table:}\par
00344     {\cf20 // Disable CPU interrupts}\par
00345     DINT;\par
00346 \par
00347     setupSpib();{\cf20 //run SPI setup code}\par
00348 \par
00349     {\cf20 // Initialize the PIE control registers to their default state.}\par
00350     {\cf20 // The default state is all PIE interrupts disabled and flags}\par
00351     {\cf20 // are cleared.}\par
00352     {\cf20 // This function is found in the F2837xD_PieCtrl.c file.}\par
00353     InitPieCtrl();\par
00354 \par
00355     {\cf20 // Disable CPU interrupts and clear all CPU interrupt flags:}\par
00356     IER = 0x0000;\par
00357     IFR = 0x0000;\par
00358 \par
00359     {\cf20 // Initialize the PIE vector table with pointers to the shell Interrupt}\par
00360     {\cf20 // Service Routines (ISR).}\par
00361     {\cf20 // This will populate the entire table, even if the interrupt}\par
00362     {\cf20 // is not used in this example.  This is useful for debug purposes.}\par
00363     {\cf20 // The shell ISR routines are found in F2837xD_DefaultIsr.c.}\par
00364     {\cf20 // This function is found in F2837xD_PieVect.c.}\par
00365     InitPieVectTable();\par
00366 \par
00367     {\cf20 // Interrupts that are used in this example are re-mapped to}\par
00368     {\cf20 // ISR functions found within this project}\par
00369     EALLOW;  {\cf20 // This is needed to write to EALLOW protected registers}\par
00370     PieVectTable.TIMER0_INT = &cpu_timer0_isr;\par
00371     PieVectTable.TIMER1_INT = &cpu_timer1_isr;\par
00372     PieVectTable.TIMER2_INT = &cpu_timer2_isr;\par
00373     PieVectTable.SCIA_RX_INT = &RXAINT_recv_ready;\par
00374     PieVectTable.SCIC_RX_INT = &RXCINT_recv_ready;\par
00375     PieVectTable.SCID_RX_INT = &RXDINT_recv_ready;\par
00376     PieVectTable.SCIA_TX_INT = &TXAINT_data_sent;\par
00377     PieVectTable.SCIC_TX_INT = &TXCINT_data_sent;\par
00378     PieVectTable.SCID_TX_INT = &TXDINT_data_sent;\par
00379     PieVectTable.SPIB_RX_INT = &SPIB_isr;\par
00380     PieVectTable.ADCA1_INT = &ADCA_ISR;\par
00381     PieVectTable.ADCB1_INT = &ADCB_ISR;\par
00382 \par
00383     PieVectTable.EMIF_ERROR_INT = &SWI_isr;\par
00384     EDIS;    {\cf20 // This is needed to disable write to EALLOW protected registers}\par
00385 \par
00386 \par
00387     {\cf20 // Initialize the CpuTimers Device Peripheral. This function can be}\par
00388     {\cf20 // found in F2837xD_CpuTimers.c}\par
00389     InitCpuTimers();\par
00390 \par
00391     {\cf20 // Configure CPU-Timer 0, 1, and 2 to interrupt every second:}\par
00392     {\cf20 // 200MHz CPU Freq, 1 second Period (in uSeconds)}\par
00393     ConfigCpuTimer(&CpuTimer0, 200, 243500); {\cf20 // 123 bpm}\par
00394     ConfigCpuTimer(&CpuTimer1, 200, 4000);\par
00395     ConfigCpuTimer(&CpuTimer2, 200, 200000);\par
00396 \par
00397     {\cf20 // Enable CpuTimer Interrupt bit TIE}\par
00398     CpuTimer0Regs.TCR.all = 0x4000;\par
00399     CpuTimer1Regs.TCR.all = 0x4000;\par
00400     CpuTimer2Regs.TCR.all = 0x4000;\par
00401 \par
00402     init_serial(&SerialA,115200,serialRXA);\par
00403     init_serial(&SerialC,9600,serialRXC); {\cf20 //set to 9600 for Bluetooth Chip, initializations and muxing done in Serial.c}\par
00404 {\cf20 //    init_serial(&SerialD,115200,serialRXD);}\par
00405 \par
00406     {\cf20 //Use as timer for ADCA}\par
00407     EALLOW;\par
00408     EPwm5Regs.ETSEL.bit.SOCAEN = 0; {\cf20 // Disable SOC on A group}\par
00409     EPwm5Regs.TBCTL.bit.CTRMODE = 3; {\cf20 // freeze counter}\par
00410     EPwm5Regs.ETSEL.bit.SOCASEL = 2; {\cf20 // Select Event when counter equal to PRD}\par
00411     EPwm5Regs.ETPS.bit.SOCAPRD = 1; {\cf20 // Generate pulse on 1st event (\'93pulse\'94 is the same as \'93trigger\'94)}\par
00412     EPwm5Regs.TBCTR = 0x0; {\cf20 // Clear counter}\par
00413     EPwm5Regs.TBPHS.bit.TBPHS = 0x0000; {\cf20 // Phase is 0}\par
00414     EPwm5Regs.TBCTL.bit.PHSEN = 0; {\cf20 // Disable phase loading}\par
00415     EPwm5Regs.TBCTL.bit.CLKDIV = 0; {\cf20 // divide by 1  50Mhz Clock}\par
00416     EPwm5Regs.TBPRD = 50000;  {\cf20 // Set Period to 1ms sample. Rampling rate: 1000 Hz}\par
00417     {\cf20 //(1/50MHz)*TBPRD = .001 s}\par
00418     {\cf20 // Notice here that we are not setting CMPA or CMPB because we are not using the PWM signal}\par
00419     EPwm5Regs.ETSEL.bit.SOCAEN = 1; {\cf20 //enable SOCA}\par
00420     EPwm5Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //unfreeze, and enter up count mode}\par
00421 \par
00422     {\cf20 //PWM9A - Buzzer (Change TBPRD to play song, tempo in Timer0)}\par
00423     EPwm9Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //count up mode}\par
00424     EPwm9Regs.TBCTL.bit.FREE_SOFT = 2; {\cf20 //free run}\par
00425     EPwm9Regs.TBCTL.bit.PHSEN = 0; {\cf20 //disable phase loading}\par
00426     EPwm9Regs.TBCTL.bit.CLKDIV = 1; {\cf20 //clock divide = 2}\par
00427     EPwm9Regs.TBCTR = 0; {\cf20 //start the timers at 0}\par
00428     EPwm9Regs.TBPRD = OFFNOTE;\par
00429 {\cf20 //    EPwm9Regs.CMPA.bit.CMPA = 0; //start duty cycle at 0%}\par
00430     {\cf20 // duty cycle = CMPA/TBPRD}\par
00431     EPwm9Regs.AQCTLA.bit.CAU = 0; {\cf20 //do nothing TBCTR = CMPA (not using compare register)}\par
00432     EPwm9Regs.AQCTLA.bit.ZRO = 3; {\cf20 //toggle when TBCTR resets}\par
00433     EPwm9Regs.TBPHS.bit.TBPHS = 0; {\cf20 //set phase to 0}\par
00434     GPIO_SetupPinMux(16, GPIO_MUX_CPU1, 5); {\cf20 //Buzzer}\par
00435 \par
00436     {\cf20 //use as timer for ADCB}\par
00437     EPwm12Regs.ETSEL.bit.SOCAEN = 0; {\cf20 // Disable SOC on A group}\par
00438     EPwm12Regs.TBCTL.bit.CTRMODE = 3; {\cf20 // freeze counter}\par
00439     EPwm12Regs.ETSEL.bit.SOCASEL = 2; {\cf20 // Select Event when counter equal to PRD}\par
00440     EPwm12Regs.ETPS.bit.SOCAPRD = 1; {\cf20 // Generate pulse on 1st event (\'93pulse\'94 is the same as \'93trigger\'94)}\par
00441     EPwm12Regs.TBCTR = 0x0; {\cf20 // Clear counter}\par
00442     EPwm12Regs.TBPHS.bit.TBPHS = 0x0000; {\cf20 // Phase is 0}\par
00443     EPwm12Regs.TBCTL.bit.PHSEN = 0; {\cf20 // Disable phase loading}\par
00444     EPwm12Regs.TBCTL.bit.CLKDIV = 0; {\cf20 // divide by 1  50Mhz Clock}\par
00445     EPwm12Regs.TBPRD = pwm12prd;  {\cf20 // Set Period to 1 ms sample. fs = 1000 Hz  Input clock is 50MHz.}\par
00446     {\cf20 // Notice here that we are not setting CMPA or CMPB because we are not using the PWM signal}\par
00447     EPwm12Regs.ETSEL.bit.SOCAEN = 1; {\cf20 //enable SOCA}\par
00448     EPwm12Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //unfreeze, and enter up count mode}\par
00449     EDIS;\par
00450 \par
00451     EALLOW;\par
00452     {\cf20 //write configurations for all ADCs  ADCA, ADCB, ADCC, ADCD}\par
00453     AdcaRegs.ADCCTL2.bit.PRESCALE = 6; {\cf20 //set ADCCLK divider to /4}\par
00454     AdcbRegs.ADCCTL2.bit.PRESCALE = 6; {\cf20 //set ADCCLK divider to /4}\par
00455     {\cf20 //        AdccRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00456     {\cf20 //        AdcdRegs.ADCCTL2.bit.PRESCALE = 6; //set ADCCLK divider to /4}\par
00457     AdcSetMode(ADC_ADCA, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  {\cf20 //read calibration settings}\par
00458     AdcSetMode(ADC_ADCB, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  {\cf20 //read calibration settings}\par
00459     {\cf20 //        AdcSetMode(ADC_ADCC, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00460     {\cf20 //        AdcSetMode(ADC_ADCD, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);  //read calibration settings}\par
00461     {\cf20 //Set pulse positions to late}\par
00462     AdcaRegs.ADCCTL1.bit.INTPULSEPOS = 1;\par
00463     AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1;\par
00464     {\cf20 //        AdccRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00465     {\cf20 //        AdcdRegs.ADCCTL1.bit.INTPULSEPOS = 1;}\par
00466     {\cf20 //power up the ADCs}\par
00467     AdcaRegs.ADCCTL1.bit.ADCPWDNZ = 1;\par
00468     AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1;\par
00469     {\cf20 //        AdccRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00470     {\cf20 //        AdcdRegs.ADCCTL1.bit.ADCPWDNZ = 1;}\par
00471     {\cf20 //delay for 1ms to allow ADC time to power up}\par
00472     DELAY_US(1000);\par
00473 \par
00474 \par
00475     {\cf20 //Select the channels to convert and end of conversion flag}\par
00476     {\cf20 //Many statements commented out,  To be used when using ADCA or ADCB}\par
00477     {\cf20 //ADCA}\par
00478     AdcaRegs.ADCSOC0CTL.bit.CHSEL = 2;  {\cf20 //SOC0 will convert Channel you choose Does not have to be A0}\par
00479     AdcaRegs.ADCSOC0CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00480     AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA will trigger SOC0}\par
00481     AdcaRegs.ADCSOC1CTL.bit.CHSEL = 3;  {\cf20 //SOC1 will convert Channel you choose Does not have to be A1}\par
00482     AdcaRegs.ADCSOC1CTL.bit.ACQPS = 99; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 500ns}\par
00483     AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = 0x0D;{\cf20 // EPWM5 ADCSOCA or another trigger you choose will trigger SOC1}\par
00484     AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = 1; {\cf20 //set to last SOC that is converted and it will set INT1 flag ADCA1}\par
00485     AdcaRegs.ADCINTSEL1N2.bit.INT1E = 1;   {\cf20 //enable INT1 flag}\par
00486     AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; {\cf20 //make sure INT1 flag is cleared}\par
00487 \par
00488     {\cf20 //ADCB}\par
00489     AdcbRegs.ADCSOC0CTL.bit.CHSEL = 4;  {\cf20 //SOC0 will convert Channel B4}\par
00490     AdcbRegs.ADCSOC0CTL.bit.ACQPS = 14; {\cf20 //sample window is acqps + 1 SYSCLK cycles = 75ns}\par
00491     AdcbRegs.ADCSOC0CTL.bit.TRIGSEL = 0x1B; {\cf20 // EPWM12 ADCSOCA will trigger SOC0}\par
00492     AdcbRegs.ADCINTSEL1N2.bit.INT1SEL = 0; {\cf20 //set to last SOC that is converted and it will set INT1 flag ADCB1}\par
00493     AdcbRegs.ADCINTSEL1N2.bit.INT1E = 1;   {\cf20 //enable INT1 flag}\par
00494     AdcbRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; {\cf20 //make sure INT1 flag is cleared}\par
00495     EDIS;\par
00496 \par
00497     {\cf20 //2A and 2B - Motors}\par
00498     EPwm2Regs.TBCTL.bit.CTRMODE = 0; {\cf20 //count up mode}\par
00499     EPwm2Regs.TBCTL.bit.FREE_SOFT = 2; {\cf20 //free run}\par
00500     EPwm2Regs.TBCTL.bit.PHSEN = 0; {\cf20 //disable phase loading}\par
00501     EPwm2Regs.TBCTL.bit.CLKDIV = 0; {\cf20 //clock divide = 1}\par
00502     EPwm2Regs.TBCTR = 0; {\cf20 //start the timers at 0}\par
00503     EPwm2Regs.TBPRD = 2500; {\cf20 //set period to 50 microseconds (20 kHz)}\par
00504     {\cf20 // (1/50MHz)*TBPRD = 50 us}\par
00505     EPwm2Regs.CMPA.bit.CMPA = 0; {\cf20 //start duty cycle at 0%}\par
00506     EPwm2Regs.CMPB.bit.CMPB = 0; {\cf20 //start duty cycle at 0%}\par
00507     {\cf20 // duty cycle = CMPA/TBPRD}\par
00508     EPwm2Regs.AQCTLA.bit.CAU = 1; {\cf20 //clear signal when TBCTR = CMPA}\par
00509     EPwm2Regs.AQCTLB.bit.CBU = 1; {\cf20 //clear signal when TBCTR = CMPB}\par
00510     EPwm2Regs.AQCTLA.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00511     EPwm2Regs.AQCTLB.bit.ZRO = 2; {\cf20 //set to high at 0}\par
00512     EPwm2Regs.TBPHS.bit.TBPHS = 0; {\cf20 //set phase to 0}\par
00513     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2A}\par
00514     GPIO_SetupPinMux(3, GPIO_MUX_CPU1, 1); {\cf20 //ePWM 2B}\par
00515 \par
00516     init_eQEPs(); {\cf20 //call eQEP setup function}\par
00517 \par
00518     {\cf20 // Enable CPU int1 which is connected to CPU-Timer 0, CPU int13}\par
00519     {\cf20 // which is connected to CPU-Timer 1, and CPU int 14, which is connected}\par
00520     {\cf20 // to CPU-Timer 2:  int 12 is for the SWI.  }\par
00521     IER |= M_INT1;\par
00522     IER |= M_INT8;  {\cf20 // SCIC SCID}\par
00523     IER |= M_INT9;  {\cf20 // SCIA}\par
00524     IER |= M_INT12;\par
00525     IER |= M_INT13;\par
00526     IER |= M_INT14;\par
00527     IER |= M_INT6; {\cf20 //SPI}\par
00528 \par
00529     {\cf20 // Enable TINT0 in the PIE: Group 1 interrupt 7}\par
00530     PieCtrlRegs.PIEIER1.bit.INTx7 = 1;\par
00531     {\cf20 // Enable SWI in the PIE: Group 12 interrupt 9}\par
00532     PieCtrlRegs.PIEIER12.bit.INTx9 = 1;\par
00533     {\cf20 //Enable SPI}\par
00534     PieCtrlRegs.PIEIER6.bit.INTx3 = 1;\par
00535     {\cf20 //Enable ADCA1}\par
00536     PieCtrlRegs.PIEIER1.bit.INTx1 = 1;\par
00537     {\cf20 //Enable ADCB1}\par
00538     PieCtrlRegs.PIEIER1.bit.INTx2 = 1;\par
00539 \par
00540     {\cf20 // Enable global Interrupts and higher priority real-time debug events}\par
00541     EINT;  {\cf20 // Enable Global interrupt INTM}\par
00542     ERTM;  {\cf20 // Enable Global realtime interrupt DBGM}\par
00543 \par
00544 \par
00545     {\cf20 // IDLE loop. Just sit and loop forever (optional):}\par
00546     {\cf19 while}(1)\par
00547     \{\par
00548         {\cf19 if} (UARTPrint == 1 ) \{\par
00549 {\cf20 //            serial_printf(&SerialC,"Num Timer2:%ld Num SerialRX: %ld\\r\\n",CpuTimer2.InterruptCount,numRXA); //prints to BT app}\par
00550 {\cf20 //            serial_printf(&SerialC,"FwdBackOffset: %.2f TurnRate: %.2f\\r\\n",FwdBackOffset, turnrate); //prints to BT app}\par
00551             serial_printf(&SerialA,{\cf22 "X: %.2f Y: %.2f Z: %.2f\\r\\n"},ble_x, ble_y, ble_z);{\cf20 //print acceleration data from phone to tera term}\par
00552             UARTPrint = 0;\par
00553         \}\par
00554        {\cf19 if}(UARTPrint2 == 1)\{\par
00555            serial_printf(&SerialC,{\cf22 "LeftVel: %.2f RightVel: %.2f\\r\\n"},LeftVel, RightVel); {\cf20 //prints to BT app}\par
00556            UARTPrint2 = 0;\par
00557        \}\par
00558 \par
00559        {\cf20 //after n samples, pass data through Goertzel fxn}\par
00560        {\cf20 // use Ping Pong buffer}\par
00561 \par
00562        {\cf19 if}(RunPing == 1)\{\par
00563            goer_result = goertzel_mag(n_samples,NOTE,sampling_rate, adcb_arrayPing);\par
00564            RunPing = 0;\par
00565            {\cf19 if}(goer_result > thresh)\{\par
00566                note_detected = 1;\par
00567            \}\par
00568        \}\par
00569        {\cf19 if}(RunPong == 1)\{\par
00570            goer_result = goertzel_mag(n_samples,NOTE,sampling_rate, adcb_arrayPong);\par
00571            RunPong = 0;\par
00572            {\cf19 if}(goer_result > thresh)\{\par
00573                note_detected = 1;\par
00574            \}\par
00575        \}\par
00576 \par
00577     \}\par
00578 \}\par
00579 \par
00580 \par
00581 {\cf20 // SWI_isr,  Using this interrupt as a Software started interrupt}\par
00582 __interrupt {\cf18 void} SWI_isr({\cf18 void}) \{\par
00583 \par
00584     {\cf20 // These three lines of code allow SWI_isr, to be interrupted by other interrupt functions}\par
00585     {\cf20 // making it lower priority than all other Hardware interrupts.}\par
00586     PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\par
00587     {\cf17 asm}({\cf22 "       NOP"});                    {\cf20 // Wait one cycle}\par
00588     EINT;                                 {\cf20 // Clear INTM to enable interrupts}\par
00589 \par
00590 \par
00591 \par
00592     {\cf20 // Insert SWI ISR Code here.......}\par
00593     {\cf20 //solve for filtered velocity in rads/s}\par
00594     LeftVel = .6*LeftVel_1 + 100*(LeftWheel-LeftWheel_1);\par
00595     RightVel = .6*RightVel_1 + 100*(RightWheel-RightWheel_1);\par
00596 \par
00597     {\cf20 //Turning}\par
00598     WheelDif = LeftWheel - RightWheel;\par
00599     velWheelDif = .33*velWheelDif_1 + .67*(WheelDif-WheelDif_1)/.004;\par
00600     eDif = turnref - WheelDif;\par
00601     {\cf20 //calculate iDif without integral windup}\par
00602     {\cf19 if}(fabs(turn)>3)\{\par
00603         iDif = iDif_1;\par
00604     \}{\cf19 else}\{\par
00605         iDif = iDif_1 + .004*(eDif+eDif_1)/2;\par
00606     \}\par
00607 \par
00608     {\cf20 //Calculate Balance and Turn COntrols}\par
00609     ubal = -K1*tilt_value -K2*gyro_value - K3*(LeftVel+RightVel)/2.0;\par
00610     turn = Kp*eDif + Ki*iDif - Kd*velWheelDif;\par
00611     {\cf20 //saturate turn so balance control dominates (controllefford between +-10)}\par
00612     {\cf19 if}(turn>4)\{\par
00613         turn = 4;\par
00614     \}{\cf19 else} {\cf19 if}(turn<-4)\{\par
00615         turn = -4;\par
00616     \}\par
00617 \par
00618     turnref = turnref_1 + (turnrate + turnrate_1)*.004/2.0;\par
00619 \par
00620     {\cf20 //Calculate controleffort for each motor}\par
00621     uRight = ubal/2.0 - turn + FwdBackOffset;\par
00622     uLeft = ubal/2.0 + turn + FwdBackOffset;\par
00623 \par
00624     {\cf20 //Send ControlEffort to PWM Motor Command}\par
00625     setEPWM2A(uRight);\par
00626     setEPWM2B(-uLeft);\par
00627 \par
00628     {\cf20 //Save Past States}\par
00629     LeftVel_1 = LeftVel;\par
00630     RightVel_1 = RightVel;\par
00631     LeftWheel_1 = LeftWheel;\par
00632     RightWheel_1 = RightWheel;\par
00633     eDif_1 = eDif;\par
00634     iDif_1 = iDif;\par
00635     turnrate_1 = turnrate;\par
00636     turnref_1 = turnref;\par
00637 \par
00638     numSWIcalls++;\par
00639     \par
00640     DINT;\par
00641 \par
00642 \}\par
00643 \par
00644 {\cf20 // cpu_timer0_isr - CPU Timer0 ISR}\par
00645 __interrupt {\cf18 void} cpu_timer0_isr({\cf18 void})\par
00646 \{\par
00647     {\cf19 if}(note_detected == 1)\{\par
00648         steeroff = 1; {\cf20 //when the note is detected, stop accepting accelerometer data as steering commands}\par
00649 \par
00650         {\cf20 // Blink a number of LEDS if the Goertzel value exceeds the threshold}\par
00651         GpioDataRegs.GPBTOGGLE.bit.GPIO52 = 1;\par
00652         GpioDataRegs.GPCTOGGLE.bit.GPIO94 = 1;\par
00653         GpioDataRegs.GPDTOGGLE.bit.GPIO97 = 1;\par
00654 \par
00655         {\cf19 if}(numTimer0calls <= songsize)\{\par
00656             {\cf20 //play the song}\par
00657             EPwm9Regs.TBPRD = song[numTimer0calls];\par
00658             {\cf20 //do the dance}\par
00659             FwdBackOffset = 0;\par
00660             turnrate = dance[numTimer0calls];\par
00661             numTimer0calls++; {\cf20 // only increment after note is detected}\par
00662         \}{\cf19 else} {\cf19 if} (numTimer0calls > songsize)\{\par
00663             note_detected = 0;\par
00664             numTimer0calls = 0;\par
00665             turnrate = 0;\par
00666             steeroff = 0; {\cf20 //can now control again with phone}\par
00667         \}\par
00668     \}\par
00669     CpuTimer0.InterruptCount++;\par
00670     {\cf20 // Acknowledge this interrupt to receive more interrupts from group 1}\par
00671     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00672 \}\par
00673 \par
00674 {\cf20 // cpu_timer1_isr - CPU Timer1 ISR}\par
00675 __interrupt {\cf18 void} cpu_timer1_isr({\cf18 void})\par
00676 \{\par
00677 \par
00678     CpuTimer1.InterruptCount++;\par
00679 \}\par
00680 \par
00681 {\cf20 // cpu_timer2_isr CPU Timer2 ISR}\par
00682 __interrupt {\cf18 void} cpu_timer2_isr({\cf18 void})\par
00683 \{\par
00684 \par
00685     UARTPrint2 = 1; {\cf20 //every 200 ms}\par
00686 \par
00687     CpuTimer2.InterruptCount++;\par
00688 \par
00689 \}\par
00690 \par
00691 {\cf20 // This function is called each time a char is recieved over UARTA.}\par
00692 {\cf18 void} serialRXA(serial_t *s, {\cf18 char} data) \{\par
00693     numRXA ++;\par
00694 \}\par
00695 \par
00696 {\cf18 char} sendback[10];\par
00697 {\cf18 char} past[14];\par
00698 {\cf18 void} serialRXC(serial_t *s, {\cf18 char} data) \{\par
00699 {\cf20 //    sendback[0] = data;}\par
00700 {\cf20 //    serial_send(&SerialA, sendback, 1); //every character that comes into BT will be echoed to Tera Term}\par
00701 \par
00702     {\cf20 //save past states}\par
00703     past[0] = past[1];\par
00704     past[1] = past[2];\par
00705     past[2] = past[3];\par
00706     past[3] = past[4];\par
00707     past[4] = past[5];\par
00708     past[5] = past[6];\par
00709     past[6] = past[7];\par
00710     past[7] = past[8];\par
00711     past[8] = past[9];\par
00712     past[9] = past[10];\par
00713     past[10] = past[11];\par
00714     past[11] = past[12];\par
00715     past[12] = past[13];\par
00716     past[13] = data;\par
00717 \par
00718     {\cf19 if}(steeroff == 0)\{\par
00719         {\cf20 //use phone accelerometer data to steer}\par
00720         {\cf19 if}((past[0] == {\cf23 '!'})&&(past[1] == {\cf23 'A'}))\{\par
00721             {\cf20 //incoming accelerometer data (arbitrary start point 0)}\par
00722 \par
00723             {\cf20 //float is a 32-bit value (4x8-bit)}\par
00724             {\cf20 //mantissa*2^exp where mantissa takes ~upper 21 bits and ~lower 10 is exponent}\par
00725             {\cf20 //meaning it is not a standard ascii}\par
00726             {\cf20 //create a union}\par
00727             {\cf20 //there will be six 16-bit ints that make up 3 floats}\par
00728             {\cf20 //for a union, takes up same place in memory}\par
00729             {\cf20 //float comes over in 4 8 bit chunks}\par
00730 \par
00731             {\cf20 //X}\par
00732             phoneaccel.rawdata[0] = (past[3]<<8)|past[2];\par
00733             phoneaccel.rawdata[1] = (past[5]<<8)|past[4];\par
00734             {\cf20 //Y}\par
00735             phoneaccel.rawdata[2] = (past[7]<<8)|past[6];\par
00736             phoneaccel.rawdata[3] = (past[9]<<8)|past[8];\par
00737             {\cf20 //Z}\par
00738             phoneaccel.rawdata[4] = (past[11]<<8)|past[10];\par
00739             phoneaccel.rawdata[5] = (past[13]<<8)|past[12];\par
00740 \par
00741             ble_x = phoneaccel.fltdata[0];\par
00742             ble_y = phoneaccel.fltdata[1];\par
00743             ble_z = phoneaccel.fltdata[2];\par
00744 \par
00745             {\cf20 //Interpret phone accel data as steering instructions}\par
00746             {\cf19 if}(ble_y >= 0.3)\{\par
00747                 {\cf20 //turn left}\par
00748     {\cf20 //            turnrate = -2.0;}\par
00749                 turnrate = -4.0;\par
00750             \}{\cf19 else} {\cf19 if}(ble_y <= -0.3)\{\par
00751                 {\cf20 //turn right}\par
00752     {\cf20 //            turnrate = 2.0;}\par
00753                 turnrate = 4.0;\par
00754             \}{\cf19 else} {\cf19 if}(fabs(ble_y) < 0.3)\{\par
00755                 {\cf20 //don't turn}\par
00756                 turnrate = 0;\par
00757             \}\par
00758 \par
00759             {\cf19 if}(ble_z <= -0.3)\{\par
00760                 {\cf20 //go forward}\par
00761                 FwdBackOffset = -1.0;\par
00762             \}{\cf19 else} {\cf19 if}(ble_z >= 0.3)\{\par
00763                 {\cf20 //go backward}\par
00764                 FwdBackOffset = 1.0;\par
00765             \}{\cf19 else} {\cf19 if}(fabs(ble_z) < 0.3)\{\par
00766                 {\cf20 //don't go forward or backward}\par
00767                 FwdBackOffset = 0;\par
00768             \}\par
00769 \par
00770             UARTPrint = 1;\par
00771         \}\par
00772     \}\par
00773 \par
00774 \}\par
00775 \par
00776 __interrupt {\cf18 void} ADCA_ISR({\cf18 void})\{\par
00777         adca0result = AdcaResultRegs.ADCRESULT0; {\cf20 //read ADC values}\par
00778         adca1result = AdcaResultRegs.ADCRESULT1;\par
00779 \par
00780         {\cf20 // Here covert ADCIND0, ADCIND1 to volts}\par
00781         adca0_volts = adca0result/1365.0;\par
00782         adca1_volts = adca1result/1365.0;\par
00783 \par
00784         {\cf20 //SPI Read Gyros and Accelerometers}\par
00785 \par
00786         GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
00787         SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 // Issue the SPIB_RX_INT when two values are in the RX FIFO}\par
00788 \par
00789         {\cf20 //write to TXBUF}\par
00790         SpibRegs.SPITXBUF = 0x8000|0x3A00; {\cf20 //start address (one register before accel)}\par
00791         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_XOUT}\par
00792         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_YOUT}\par
00793         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read ACCEL_ZOUT}\par
00794         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read TEMP_OUT}\par
00795         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_XOUT}\par
00796         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_YOUT}\par
00797         SpibRegs.SPITXBUF = 0x0000; {\cf20 //write 0x00 to read GYRO_ZOUT}\par
00798 \par
00799         AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;  {\cf20 //clear interrupt flag}\par
00800         PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\par
00801 \}\par
00802 \par
00803 __interrupt {\cf18 void} SPIB_isr({\cf18 void})\{\par
00804 \par
00805     {\cf20 //read from RX FIFO}\par
00806     Junk = SpibRegs.SPIRXBUF; {\cf20 //garbage value read}\par
00807     accelxraw = SpibRegs.SPIRXBUF;\par
00808     accelyraw = SpibRegs.SPIRXBUF;\par
00809     accelzraw = SpibRegs.SPIRXBUF;\par
00810     Junk = SpibRegs.SPIRXBUF;\par
00811     gyroxraw = SpibRegs.SPIRXBUF;\par
00812     gyroyraw = SpibRegs.SPIRXBUF;\par
00813     gyrozraw = SpibRegs.SPIRXBUF;\par
00814 \par
00815     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
00816 \par
00817     accelx = (float)(accelxraw*4.0/32767.0); {\cf20 // m/s2, this value is saturated due to offset}\par
00818     accely = (float)(accelyraw*4.0/32767.0); {\cf20 // m/s2}\par
00819     accelz = (float)(accelzraw*4.0/32767.0); {\cf20 // m/s2}\par
00820     gyrox = (float)(gyroxraw*250.0/32767.0); {\cf20 //deg per second}\par
00821     gyroy = (float)(gyroyraw*250.0/32767.0); {\cf20 //deg per second}\par
00822     gyroz = (float)(gyrozraw*250.0/32767.0); {\cf20 //deg per second}\par
00823 \par
00824     {\cf20 //Code to be copied into SPIB_ISR interrupt function after the IMU measurements have been collected.}\par
00825       {\cf19 if}(calibration_state == 0)\{\par
00826             calibration_count++;\par
00827             {\cf19 if} (calibration_count == 2000) \{\par
00828                 calibration_state = 1;\par
00829                 calibration_count = 0;\par
00830             \}\par
00831         \} {\cf19 else} {\cf19 if}(calibration_state == 1)\{\par
00832             accelx_offset+=accelx;\par
00833             accely_offset+=accely;\par
00834             accelz_offset+=accelz;\par
00835             gyrox_offset+=gyrox;\par
00836             gyroy_offset+=gyroy;\par
00837             gyroz_offset+=gyroz;\par
00838             calibration_count++;\par
00839             {\cf19 if} (calibration_count == 2000) \{\par
00840                 calibration_state = 2;\par
00841                 accelx_offset/=2000.0;\par
00842                 accely_offset/=2000.0;\par
00843                 accelz_offset/=2000.0;\par
00844                 gyrox_offset/=2000.0;\par
00845                 gyroy_offset/=2000.0;\par
00846                 gyroz_offset/=2000.0;\par
00847                 calibration_count = 0;\par
00848                 doneCal = 1;\par
00849             \}\par
00850 \par
00851         \} {\cf19 else} {\cf19 if}(calibration_state == 2)\{\par
00852 \par
00853             accelx -=(accelx_offset);\par
00854             accely -=(accely_offset);\par
00855             accelz -=(accelz_offset-accelzBalancePoint);\par
00856             gyrox -= gyrox_offset;\par
00857             gyroy -= gyroy_offset;\par
00858             gyroz -= gyroz_offset;\par
00859 \par
00860             {\cf20 /*--------------Kalman Filtering code start---------------------------------------------------------------------*/}\par
00861             {\cf18 float} tiltrate = (gyrox*PI)/180.0; {\cf20 // rad/s}\par
00862             {\cf18 float} pred_tilt, z, y, S;\par
00863 \par
00864             {\cf20 // Prediction Step}\par
00865             pred_tilt = kalman_tilt + T*tiltrate;\par
00866             pred_P = kalman_P + Q;\par
00867 \par
00868             {\cf20 // Update Step}\par
00869             z = -accelz;  {\cf20 // Note the negative here due to the polarity of AccelZ}\par
00870             y = z - pred_tilt;\par
00871             S = pred_P + R;\par
00872             kalman_K = pred_P/S;\par
00873             kalman_tilt = pred_tilt + kalman_K*y;\par
00874             kalman_P = (1 - kalman_K)*pred_P;\par
00875 \par
00876             SpibNumCalls++;\par
00877             {\cf20 // Kalman Filter used}\par
00878             tilt_array[SpibNumCalls] = kalman_tilt;\par
00879             gyro_array[SpibNumCalls] = tiltrate;\par
00880             LeftWheelArray[SpibNumCalls] = -readEncLeft();\par
00881             RightWheelArray[SpibNumCalls] = readEncRight();\par
00882 \par
00883             {\cf19 if} (SpibNumCalls >= 3) \{  {\cf20 // should never be greater than 3}\par
00884                 tilt_value = (tilt_array[0] + tilt_array[1] + tilt_array[2] + tilt_array[3])/4.0;\par
00885                 gyro_value = (gyro_array[0] + gyro_array[1] + gyro_array[2] + gyro_array[3])/4.0;\par
00886                 LeftWheel=(LeftWheelArray[0]+LeftWheelArray[1]+LeftWheelArray[2]+LeftWheelArray[3])/4.0;\par
00887                 RightWheel=(RightWheelArray[0]+RightWheelArray[1]+RightWheelArray[2]+RightWheelArray[3])/4.0;\par
00888                 SpibNumCalls = -1;\par
00889 \par
00890                 PieCtrlRegs.PIEIFR12.bit.INTx9 = 1;  {\cf20 // Manually cause the interrupt for the SWI}\par
00891             \}\par
00892         \}\par
00893 \par
00894         timecount++;\par
00895 \par
00896         {\cf19 if}((timecount%200) == 0)\par
00897         \{\par
00898             {\cf19 if}(doneCal == 0) \{\par
00899                 GpioDataRegs.GPATOGGLE.bit.GPIO31 = 1;  {\cf20 // Blink Blue LED while calibrating}\par
00900             \}\par
00901             GpioDataRegs.GPBTOGGLE.bit.GPIO34 = 1;  {\cf20 // Always Block Red LED}\par
00902 \par
00903 {\cf20 //            UARTPrint = 1;  // Tell While loop to print}\par
00904         \}\par
00905 \par
00906         SpibRegs.SPIFFRX.bit.RXFFOVFCLR=1;  {\cf20 // Clear Overflow flag}\par
00907         SpibRegs.SPIFFRX.bit.RXFFINTCLR=1;  {\cf20 // Clear Interrupt flag}\par
00908         PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
00909 \}\par
00910 \par
00911 __interrupt {\cf18 void} ADCB_ISR ({\cf18 void})\par
00912 \{\par
00913     adcb0result = AdcbResultRegs.ADCRESULT0; {\cf20 //read value between 0 and 4095 from ADC}\par
00914     {\cf20 //MAX9814 sensitivity = -44 dBV meaning the signal corresponds to 6.3096mV/Pa of sound pressure}\par
00915     {\cf20 //ADC values 0 to 4095 correspond to voltages 0-3V, mic produces 0.5 to 2.5 V (values ~682 to ~3412)}\par
00916 \par
00917     {\cf20 //Ping}\par
00918     {\cf19 if}(PingPong == 0)\{\par
00919         adcb_arrayPing[adcbcount] = adcb0result; {\cf20 // add ADC reading to array}\par
00920         {\cf19 if}(adcbcount == (n_samples-1))\{\par
00921             adcbcount = -1; {\cf20 //incremented to 0 at end of interrupt}\par
00922             RunPing = 1; {\cf20 //check in while loop}\par
00923             PingPong = 1; {\cf20 //switch to Pong buffer}\par
00924         \}\par
00925     \}\par
00926     {\cf20 //Pong}\par
00927     {\cf19 if}(PingPong == 1)\{\par
00928         adcb_arrayPong[adcbcount] = adcb0result;\par
00929         {\cf19 if}(adcbcount == (n_samples-1))\{\par
00930             adcbcount = -1; {\cf20 //incremented to 0 at end of interrupt}\par
00931             RunPong = 1;\par
00932             PingPong = 0; {\cf20 //switch to Pong buffer}\par
00933         \}\par
00934     \}\par
00935 \par
00936     adcbcount++; {\cf20 //increment count}\par
00937     AdcbRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;  {\cf20 //clear interrupt flag}\par
00938     PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; {\cf20 //clear PIE peripheral so processor waits until next interrupt flag}\par
00939 \}\par
00940 \par
00941 {\cf18 float} readEncLeft({\cf18 void}) \{\par
00942     int32_t raw = 0;\par
00943     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U}\par
00944 \par
00945     raw = EQep1Regs.QPOSCNT;\par
00946     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00947 \par
00948     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00949     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00950     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00951     {\cf19 return} (raw*(TWOPI/600.0)); {\cf20 //wheel rotation in radians}\par
00952 \}\par
00953 \par
00954 {\cf18 float} readEncRight({\cf18 void}) \{\par
00955 \par
00956     int32_t raw = 0;\par
00957     uint32_t QEP_maxvalue = 0xFFFFFFFFU;  {\cf20 //4294967295U  -1 32bit signed int}\par
00958 \par
00959     raw = EQep2Regs.QPOSCNT;\par
00960     {\cf19 if} (raw >= QEP_maxvalue/2) raw -= QEP_maxvalue;  {\cf20 // I don't think this is needed and never true}\par
00961 \par
00962     {\cf20 // 5 North South magnet poles in the encoder disk so 5 square waves per one revolution of the}\par
00963     {\cf20 // DC motor's back shaft.  Then Quadrature Decoder mode multiplies this by 4 so 20 counts per one rev}\par
00964     {\cf20 // of the DC motor's back shaft.  Then the gear motor's gear ratio is 30:1.}\par
00965     {\cf19 return} (raw*(TWOPI/600.0));\par
00966 \}\par
00967 \par
00968 {\cf18 void} init_eQEPs({\cf18 void}) \{\par
00969 \par
00970     {\cf20 // setup eQEP1 pins for input}\par
00971     EALLOW;\par
00972     {\cf20 //Disable internal pull-up for the selected output pins for reduced power consumption}\par
00973     GpioCtrlRegs.GPAPUD.bit.GPIO20 = 1;    {\cf20 // Disable pull-up on GPIO20 (EQEP1A)}\par
00974     GpioCtrlRegs.GPAPUD.bit.GPIO21 = 1;    {\cf20 // Disable pull-up on GPIO21 (EQEP1B)}\par
00975     GpioCtrlRegs.GPAQSEL2.bit.GPIO20 = 2;   {\cf20 // Qual every 6 samples}\par
00976     GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 2;   {\cf20 // Qual every 6 samples}\par
00977     EDIS;\par
00978     {\cf20 // This specifies which of the possible GPIO pins will be EQEP1 functional pins.}\par
00979     {\cf20 // Comment out other unwanted lines.}\par
00980     GPIO_SetupPinMux(20, GPIO_MUX_CPU1, 1);\par
00981     GPIO_SetupPinMux(21, GPIO_MUX_CPU1, 1);\par
00982     EQep1Regs.QEPCTL.bit.QPEN = 0;    {\cf20 // make sure eqep in reset}\par
00983     EQep1Regs.QDECCTL.bit.QSRC = 0;   {\cf20 // Quadrature count mode}\par
00984     EQep1Regs.QPOSCTL.all = 0x0;      {\cf20 // Disable eQep Position Compare}\par
00985     EQep1Regs.QCAPCTL.all = 0x0;      {\cf20 // Disable eQep Capture}\par
00986     EQep1Regs.QEINT.all = 0x0;        {\cf20 // Disable all eQep interrupts}\par
00987     EQep1Regs.QPOSMAX = 0xFFFFFFFF;   {\cf20 // use full range of the 32 bit count}\par
00988     EQep1Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend in Code Composer}\par
00989     EQep1Regs.QPOSCNT = 0;\par
00990     EQep1Regs.QEPCTL.bit.QPEN = 1;    {\cf20 // Enable EQep}\par
00991 \par
00992 \par
00993     {\cf20 // setup QEP2 pins for input}\par
00994     EALLOW;\par
00995     {\cf20 //Disable internal pull-up for the selected output pinsfor reduced power consumption}\par
00996     GpioCtrlRegs.GPBPUD.bit.GPIO54 = 1;    {\cf20 // Disable pull-up on GPIO54 (EQEP2A)}\par
00997     GpioCtrlRegs.GPBPUD.bit.GPIO55 = 1;    {\cf20 // Disable pull-up on GPIO55 (EQEP2B)}\par
00998     GpioCtrlRegs.GPBQSEL2.bit.GPIO54 = 2;   {\cf20 // Qual every 6 samples}\par
00999     GpioCtrlRegs.GPBQSEL2.bit.GPIO55 = 2;   {\cf20 // Qual every 6 samples}\par
01000     EDIS;\par
01001     GPIO_SetupPinMux(54, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2A}\par
01002     GPIO_SetupPinMux(55, GPIO_MUX_CPU1, 5); {\cf20 // set GPIO54 and eQep2B}\par
01003     EQep2Regs.QEPCTL.bit.QPEN = 0;   {\cf20 // make sure qep reset}\par
01004     EQep2Regs.QDECCTL.bit.QSRC = 0;  {\cf20 // Quadrature count mode}\par
01005     EQep2Regs.QPOSCTL.all = 0x0;     {\cf20 // Disable eQep Position Compare}\par
01006     EQep2Regs.QCAPCTL.all = 0x0;     {\cf20 // Disable eQep Capture}\par
01007     EQep2Regs.QEINT.all = 0x0;       {\cf20 // Disable all eQep interrupts}\par
01008     EQep2Regs.QPOSMAX = 0xFFFFFFFF;  {\cf20 // use full range of the 32 bit count.}\par
01009     EQep2Regs.QEPCTL.bit.FREE_SOFT = 2;  {\cf20 // EQep uneffected by emulation suspend}\par
01010     EQep2Regs.QPOSCNT = 0;\par
01011     EQep2Regs.QEPCTL.bit.QPEN = 1;   {\cf20 // Enable EQep}\par
01012 \}\par
01013 \par
01014 {\cf18 void} setEPWM2A({\cf18 float} controleffort)\{\par
01015     {\cf20 //saturate value}\par
01016     {\cf19 if}(controleffort > 10)\{\par
01017         controleffort = 10;\par
01018     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
01019         controleffort = -10;\par
01020     \}\par
01021 \par
01022     EPwm2Regs.CMPA.bit.CMPA = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
01023 \}\par
01024 \par
01025 {\cf18 void} setEPWM2B({\cf18 float} controleffort)\{\par
01026     {\cf19 if}(controleffort > 10)\{\par
01027         controleffort = 10;\par
01028     \}{\cf19 else} {\cf19 if}(controleffort < -10)\{\par
01029         controleffort = -10;\par
01030     \}\par
01031 \par
01032     EPwm2Regs.CMPB.bit.CMPB = ((controleffort+10.0)/20.0)*EPwm2Regs.TBPRD;\par
01033 \}\par
01034 \par
01035 {\cf18 void} setupSpib({\cf18 void}) {\cf20 //Call this function in main() somewhere after the DINT; line of code.}\par
01036 \{\par
01037     int16_t temp = 0; {\cf20 // for reading RXBUF}\par
01038     {\cf20 //Step 1.}\par
01039     {\cf20 // cut and paste here all the SpibRegs initializations you found for part 3. Change so that 16 bits are}\par
01040     {\cf20 //transmitted each TX FIFO write and change the delay in between each transfer to 0.}\par
01041 \par
01042     {\cf20 //lab4 setup Serial}\par
01043     GPIO_SetupPinMux(2, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO2 and used as DAN777 SS}\par
01044     GPIO_SetupPinOptions(2, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO2 an Output Pin}\par
01045     GpioDataRegs.GPASET.bit.GPIO2 = 1; {\cf20 //Initially Set GPIO2/SS High so DAN777 is not selected}\par
01046     GPIO_SetupPinMux(66, GPIO_MUX_CPU1, 0); {\cf20 // Set as GPIO66 and used as MPU-9250 SS}\par
01047     GPIO_SetupPinOptions(66, GPIO_OUTPUT, GPIO_PUSHPULL); {\cf20 // Make GPIO66 an Output Pin}\par
01048     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 //Initially Set GPIO66/SS High so MPU-9250 is not selected}\par
01049     GPIO_SetupPinMux(63, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO63 pin to SPISIMOB}\par
01050     GPIO_SetupPinMux(64, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO64 pin to SPISOMIB}\par
01051     GPIO_SetupPinMux(65, GPIO_MUX_CPU1, 15); {\cf20 //Set GPIO65 pin to SPICLKB}\par
01052     EALLOW;\par
01053     GpioCtrlRegs.GPBPUD.bit.GPIO63 = 0; {\cf20 // Enable Pull-ups on SPI PINs Recommended by TI for SPI Pins}\par
01054     GpioCtrlRegs.GPCPUD.bit.GPIO64 = 0;\par
01055     GpioCtrlRegs.GPCPUD.bit.GPIO65 = 0;\par
01056     GpioCtrlRegs.GPBQSEL2.bit.GPIO63 = 3; {\cf20 // Set prequalifier for SPI PINS}\par
01057     GpioCtrlRegs.GPCQSEL1.bit.GPIO64 = 3; {\cf20 // The prequalifier eliminates short noise spikes}\par
01058     GpioCtrlRegs.GPCQSEL1.bit.GPIO65 = 3; {\cf20 // by making sure the serial pin stays low for 3 clock periods.}\par
01059     EDIS;\par
01060     {\cf20 // ---------------------------------------------------------------------------}\par
01061     SpibRegs.SPICCR.bit.SPISWRESET = 0; {\cf20 // Put SPI in Reset}\par
01062     SpibRegs.SPICTL.bit.CLK_PHASE = 1; {\cf20 //This happens to be the mode for both the DAN777 and}\par
01063     SpibRegs.SPICCR.bit.CLKPOLARITY = 0; {\cf20 //The MPU-9250, Mode 01.}\par
01064     SpibRegs.SPICTL.bit.MASTER_SLAVE = 1; {\cf20 // Set to SPI Master}\par
01065     SpibRegs.SPICCR.bit.SPICHAR = 15; {\cf20 // Set to transmit and receive 16 bits each write to SPITXBUF}\par
01066     SpibRegs.SPICTL.bit.TALK = 1; {\cf20 // Enable transmission}\par
01067     SpibRegs.SPIPRI.bit.FREE = 1; {\cf20 // Free run, continue SPI operation}\par
01068     SpibRegs.SPICTL.bit.SPIINTENA = 0; {\cf20 // Disables the SPI interrupt}\par
01069     SpibRegs.SPIPRI.bit.SOFT = 0; {\cf20 // This line may not be used}\par
01070     SpibRegs.SPIBRR.bit.SPI_BIT_RATE = 49; {\cf20 // Set SCLK bit rate to 1 MHz so 1us period. SPI base clock is}\par
01071     {\cf20 // 50MHZ. And this setting divides that base clock to create SCLK\'92s period, there is a +1}\par
01072     SpibRegs.SPISTS.all = 0x0000; {\cf20 // Clear status flags just in case they are set for some reason}\par
01073     SpibRegs.SPIFFTX.bit.SPIRST = 1;{\cf20 // Pull SPI FIFO out of reset, SPI FIFO can resume transmit or receive.}\par
01074     SpibRegs.SPIFFTX.bit.SPIFFENA = 1; {\cf20 // Enable SPI FIFO enhancements}\par
01075     SpibRegs.SPIFFTX.bit.TXFIFO = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
01076     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFTX[TXFFINT] flag just in case it is set}\par
01077     SpibRegs.SPIFFRX.bit.RXFIFORESET = 0; {\cf20 // Write 0 to reset the FIFO pointer to zero, and hold in reset}\par
01078     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFOVF] just in case it is set}\par
01079     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Write 1 to clear SPIFFRX[RXFFINT] flag just in case it is set}\par
01080     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // RX FIFO interrupt based on RXFFIL match}\par
01081     SpibRegs.SPIFFCT.bit.TXDLY = 0; {\cf20 //Set delay between transmits to 0 spi clocks.}\par
01082     SpibRegs.SPICCR.bit.SPISWRESET = 1; {\cf20 // Pull the SPI out of reset}\par
01083     SpibRegs.SPIFFTX.bit.TXFIFO = 1; {\cf20 // Release transmit FIFO from reset.}\par
01084     SpibRegs.SPIFFRX.bit.RXFIFORESET = 1; {\cf20 // Re-enable receive FIFO operation}\par
01085     SpibRegs.SPICTL.bit.SPIINTENA = 1; {\cf20 // Enables SPI interrupt. !! I don\'92t think this is needed. Need to Test}\par
01086     SpibRegs.SPIFFTX.bit.TXFFINTCLR = 1; {\cf20 // Clear Interrupt flag just in case it is set}\par
01087     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear overflow flag just in case it is set}\par
01088     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Receive FIFO interrupt flag just in case it is set.}\par
01089     SpibRegs.SPIFFRX.bit.RXFFIENA = 1; {\cf20 // Enable the RX FIFO Interrupt. RXFFST >= RXFFIL}\par
01090     SpibRegs.SPIFFRX.bit.RXFFIL = 8; {\cf20 //Interrupt Level to 7 words or more received into FIFO causes interrupt}\par
01091     {\cf20 //interrupt number of words in FIFO here AND in timer}\par
01092 \par
01093     {\cf20 //  EDIS;}\par
01094 \par
01095     {\cf20 // SpibRegs.SPICCR.bit.SPICHAR = 0xF;}\par
01096     {\cf20 // SpibRegs.SPIFFCT.bit.TXDLY = 0x00;}\par
01097     {\cf20 //-----------------------------------------------------------------------------------------------------------------}\par
01098     {\cf20 //Step 2.}\par
01099     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x13,0x14,0x15,0x16}\par
01100     {\cf20 // 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C 0x1D, 0x1E, 0x1F. Use only one SS low to high for all these writes}\par
01101     {\cf20 // some code is given, most you have to fill you yourself.}\par
01102     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
01103     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
01104     SpibRegs.SPITXBUF = 0x1300; {\cf20 //start address,  To address 00x13 write 0x00}\par
01105     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x14 write 0x00, To address 00x15 write 0x00}\par
01106     SpibRegs.SPITXBUF = 0x0000; {\cf20 // To address 00x16 write 0x00, To address 00x17 write 0x00}\par
01107     SpibRegs.SPITXBUF = 0x0013; {\cf20 // To address 00x18 write 0x00, To address 00x19 write 0x13}\par
01108     SpibRegs.SPITXBUF = 0x0200;{\cf20 // To address 00x1A write 0x02, To address 00x1B write 0x00}\par
01109     SpibRegs.SPITXBUF = 0x0806;{\cf20 // To address 00x1C write 0x08, To address 00x1D write 0x06}\par
01110     SpibRegs.SPITXBUF = 0x0000;{\cf20 // To address 00x1E write 0x00, To address 00x1F write 0x00}\par
01111 \par
01112     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
01113     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=7); {\cf20 //should this be 0?}\par
01114     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
01115     temp = SpibRegs.SPIRXBUF; {\cf20 // read the garbage receive values off the RX FIFO to clear}\par
01116     temp = SpibRegs.SPIRXBUF;\par
01117     temp = SpibRegs.SPIRXBUF;\par
01118     temp = SpibRegs.SPIRXBUF;\par
01119     temp = SpibRegs.SPIRXBUF;\par
01120     temp = SpibRegs.SPIRXBUF;\par
01121     temp = SpibRegs.SPIRXBUF;\par
01122     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
01123 \par
01124     {\cf20 //Step 3.}\par
01125     {\cf20 // perform a multiple 16 bit transfer to initialize MPU-9250 registers 0x23,0x24,0x25,0x26}\par
01126     {\cf20 // 0x27, 0x28, 0x29. Use only one SS low to high for all these writes}\par
01127     {\cf20 // some code is given, most you have to fill you yourself.}\par
01128     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1; {\cf20 // Slave Select Low}\par
01129     {\cf20 // Perform the number of needed writes to SPITXBUF to write to all 13 registers}\par
01130     SpibRegs.SPITXBUF = 0x2300; {\cf20 //start address, To address 00x23 write 0x00}\par
01131     SpibRegs.SPITXBUF = 0x408C;{\cf20 // To address 00x24 write 0x40, To address 00x25 write 0x8C}\par
01132     SpibRegs.SPITXBUF = 0x0288;{\cf20 // To address 00x26 write 0x02, To address 00x27 write 0x88}\par
01133     SpibRegs.SPITXBUF = 0x0C0A;{\cf20 // To address 00x28 write 0x0C, To address 00x29 write 0x0A}\par
01134 \par
01135     {\cf20 // wait for the correct number of 16 bit values to be received into the RX FIFO}\par
01136     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=4);\par
01137     GpioDataRegs.GPCSET.bit.GPIO66 = 1; {\cf20 // Slave Select High}\par
01138     temp = SpibRegs.SPIRXBUF;\par
01139     temp = SpibRegs.SPIRXBUF;\par
01140     temp = SpibRegs.SPIRXBUF;\par
01141     temp = SpibRegs.SPIRXBUF;\par
01142     {\cf20 // read the additional number of garbage receive values off the RX FIFO to clear out the RX FIFO}\par
01143     DELAY_US(10); {\cf20 // Delay 10us to allow time for the MPU-2950 to get ready for next transfer.}\par
01144 \par
01145     {\cf20 //Step 4.}\par
01146     {\cf20 // perform a single 16 bit transfer to initialize MPU-9250 register 0x2A}\par
01147     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01148     SpibRegs.SPITXBUF = 0x2A81; {\cf20 //start address, Write to address 0x2A the value 0x81}\par
01149 \par
01150     {\cf20 // wait for one byte to be received}\par
01151     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01152     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01153     temp = SpibRegs.SPIRXBUF;\par
01154     DELAY_US(10);\par
01155 \par
01156     {\cf20 // The Remainder of this code is given to you and you do not need to make any changes.}\par
01157     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01158     SpibRegs.SPITXBUF = (0x3800 | 0x0001); {\cf20 // 0x3800}\par
01159     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01160     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01161     temp = SpibRegs.SPIRXBUF;\par
01162     DELAY_US(10);\par
01163     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01164     SpibRegs.SPITXBUF = (0x3A00 | 0x0001); {\cf20 // 0x3A00}\par
01165     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01166     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01167     temp = SpibRegs.SPIRXBUF;\par
01168     DELAY_US(10);\par
01169     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01170     SpibRegs.SPITXBUF = (0x6400 | 0x0001); {\cf20 // 0x6400}\par
01171     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01172     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01173     temp = SpibRegs.SPIRXBUF;\par
01174     DELAY_US(10);\par
01175     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01176     SpibRegs.SPITXBUF = (0x6700 | 0x0003); {\cf20 // 0x6700}\par
01177     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01178     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01179     temp = SpibRegs.SPIRXBUF;\par
01180     DELAY_US(10);\par
01181     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01182     SpibRegs.SPITXBUF = (0x6A00 | 0x0020); {\cf20 // 0x6A00}\par
01183     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01184     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01185     temp = SpibRegs.SPIRXBUF;\par
01186     DELAY_US(10);\par
01187     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01188     SpibRegs.SPITXBUF = (0x6B00 | 0x0001); {\cf20 // 0x6B00}\par
01189     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01190     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01191     temp = SpibRegs.SPIRXBUF;\par
01192     DELAY_US(10);\par
01193     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01194     SpibRegs.SPITXBUF = (0x7500 | 0x0071); {\cf20 // 0x7500}\par
01195     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01196     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01197     temp = SpibRegs.SPIRXBUF;\par
01198     DELAY_US(10);\par
01199     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01200 {\cf20 //    SpibRegs.SPITXBUF = (0x7700 | 0x00EB); // 0x7700}\par
01201     SpibRegs.SPITXBUF = (0x7700 | 0x0000); {\cf20 // 0x7700}\par
01202     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01203     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01204     temp = SpibRegs.SPIRXBUF;\par
01205     DELAY_US(10);\par
01206     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01207 {\cf20 //    SpibRegs.SPITXBUF = (0x7800 | 0x0012); // 0x7800}\par
01208     SpibRegs.SPITXBUF = (0x7800 | 0x0000); {\cf20 // 0x7800}\par
01209     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01210     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01211     temp = SpibRegs.SPIRXBUF;\par
01212     DELAY_US(10);\par
01213     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01214     SpibRegs.SPITXBUF = (0x7A00 | 0x0010); {\cf20 // 0x7A00}\par
01215     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01216     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01217     temp = SpibRegs.SPIRXBUF;\par
01218     DELAY_US(10);\par
01219     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01220     SpibRegs.SPITXBUF = (0x7B00 | 0x00FA); {\cf20 // 0x7B00}\par
01221     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01222     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01223     temp = SpibRegs.SPIRXBUF;\par
01224     DELAY_US(10);\par
01225     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01226     SpibRegs.SPITXBUF = (0x7D00 | 0x0021); {\cf20 // 0x7D00}\par
01227     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01228     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01229     temp = SpibRegs.SPIRXBUF;\par
01230     DELAY_US(10);\par
01231     GpioDataRegs.GPCCLEAR.bit.GPIO66 = 1;\par
01232     SpibRegs.SPITXBUF = (0x7E00 | 0x0050); {\cf20 // 0x7E00}\par
01233     {\cf19 while}(SpibRegs.SPIFFRX.bit.RXFFST !=1);\par
01234     GpioDataRegs.GPCSET.bit.GPIO66 = 1;\par
01235     temp = SpibRegs.SPIRXBUF;\par
01236     DELAY_US(50);\par
01237 \par
01238     {\cf20 // Clear SPIB interrupt source just in case it was issued due to any of the above initializations.}\par
01239     SpibRegs.SPIFFRX.bit.RXFFOVFCLR = 1; {\cf20 // Clear Overflow flag}\par
01240     SpibRegs.SPIFFRX.bit.RXFFINTCLR = 1; {\cf20 // Clear Interrupt flag}\par
01241     PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\par
01242 \}\par
01243 {\cf18 float} goertzel_mag({\cf18 int} numSamples,{\cf18 int} TARGET_FREQUENCY,{\cf18 int} SAMPLING_RATE, {\cf18 float}* data)\par
01244 \{\par
01245     {\cf18 int}     k,i;\par
01246     {\cf18 float}   floatnumSamples;\par
01247     {\cf18 float}   omega,sine,cosine,coeff,q0,q1,q2,magnitude,real,imag;\par
01248 \par
01249     {\cf18 float}   scalingFactor = numSamples / 2.0;\par
01250 \par
01251     floatnumSamples = (float) numSamples;\par
01252     k = (int) (0.5 + ((floatnumSamples * TARGET_FREQUENCY) / SAMPLING_RATE));\par
01253     omega = (2.0 * PI * k) / floatnumSamples;\par
01254     sine = sin(omega);\par
01255     cosine = cos(omega);\par
01256     coeff = 2.0 * cosine;\par
01257     q0=0;\par
01258     q1=0;\par
01259     q2=0;\par
01260 \par
01261     {\cf19 for}(i=0; i<numSamples; i++)\par
01262     \{\par
01263         q0 = coeff * q1 - q2 + data[i];\par
01264         q2 = q1;\par
01265         q1 = q0;\par
01266     \}\par
01267 \par
01268     {\cf20 // calculate the real and imaginary results}\par
01269     {\cf20 // scaling appropriately}\par
01270     real = (q1 - q2 * cosine) / scalingFactor;\par
01271     imag = (q2 * sine) / scalingFactor;\par
01272 \par
01273     magnitude = sqrtf(real*real + imag*imag);\par
01274     {\cf19 return} magnitude;\par
01275 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
